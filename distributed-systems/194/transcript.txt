so distributed transactions are heart and soul of distributed systems and getting all the participating nodes to agree to that commit or about a distributed transaction is not an easy job in this video we talk about the two-phase commit protocol that takes baby steps to ensure that we can get all the nodes to either commit or abort while ensuring that the data never goes in an inconsistent state but before we move forward i'd like to talk to you about a course on system design that i have been running for over a year now the course is a cohort based course which means i won't be rambling a solution and it will not be a monologue instead a small focused group of 50 60 engineers every cohort will be brainstorming systems and designing it together this way we build a solid system and learn from each other's experiences the course to date is enrolled by 600 plus engineers spanning nine cohorts and ten countries engineers from companies like google microsoft github slack facebook tesla yelp flipkart dream 11 and many many many more have taken this course and have some wonderful things to say the coolest part about the course is the depth we go into and the breadth we cover we cover topics ranging from real-time text communication for slack to designing our own toy load balancer to creek buses live text commentary to doing impressions counting at scale for any advertisement business in all we would cover roughly 28 questions and the detailed curriculum split week by week can be found on the course page which is linked in the description down below so if you're looking to learn system design from the first principles you will love this course i have two offerings for you the first one is the live cohort discourse which you see on the left side and the second one is the recorded course which you can see on the right side the live code based course happens every two months and it will go on for eight weeks while the recorded course contains the recordings from one of the past cohorts as is if you are in a hurry and want to binge learn system design i would highly recommend you going for the recorded one otherwise the live code is where you can participate and discuss things live with me and the entire cohort and amplify your learnings the decision is totally up to you the course details prerequisites testimonials can be found on the course page at pitmany dot me slash master class and i would highly recommend you to check that out i put the link of the course in the description down below so if you are interested to learn system design go for it check out the link in the description down below and i hope to see you in my next cohort thanks say we have a distributed database with three nodes and we want our commit to succeed when the commit at all the db's succeed a simple example say we are doing a put k comma 10 right and the right this right should be successful when this write is made on all the three databases if it fails on any one of them we should not be considering this right at all right so this is what we are trying to achieve this is a classic case of distributed transaction when we are writing it in a transactional manner that either everyone succeeds or if even one of them aborts everything about right so before we jump into two phase commit we'll go through the assumptions there are three classic assumptions that will be made not very severe but very lenient assumptions that we are making the first one being that there is no message loss which means that when two nodes connected to each other via connection if this if one node sends message to other the message is not lost the connection may be broken that is fine in that case we would do a retry but your message once sent will not be lost primarily if we use tcp connection this is pretty much unshort right second assumption that a process failure can happen which means that while participating in a distributed transaction this like one of the node or the leader or someone something processes can crash but you still should be either committing or aborting and that should be unanimous third your graph is fully connected which means that every node knows about existence of every other node you cannot have a partially connected graph right so if i have n nodes in my cluster every node node knows about every other node in the cluster right and at the end of your distributed transaction you should ensure or the algorithm the protocol should ensure that no two processes can decide on different values which means that either everyone commits or everyone aborts but you cannot have that hey five nodes would commit but four are aborting right so the decision has to be unanimous and it has to be uniform right so now let's jump into the two phase commit protocol and let's see how it tries to ensure and in some cases does ensure a distributed transaction okay so two phase commit what it says is that say we have n processes participating in a transaction now here we are using a general term called processes it could be database it could be api servers it could be anything it just end processes they are participating in a transaction and what do we do is we choose a distinguished process say a now this a could be the leader node or the coordinator node having the largest uid something something some way through which we know that this process is going to be the coordinator in most cases it could be the first node that received the right request from the client that could become the coordinator or it could be the leader node of your network anything but a process a node has to become the coordinator of this two-phase commit protocol right now this two-phase commit happens in two phases that's why the name two phase commit phase number one where now what would happen is we are preparing to commit here what we would do is all the nodes if they can commit or abort they send this value to a given that a is your coordinator node right so a if i have a four node network a b c d a is my coordinator so i will be receiving messages from b c and d setting if they can commit or not right so a is the one who is gathering all the information about all other nodes and asking hey can you commit can you commit can you commit and they would be responding yes or no right so they would be responding if they can commit or not right in case it does not receive a message from any of the node it can assume by default that that node is going to abort right okay so a up until now has gathered all the decisions and it knows its own decision whether it itself can commit or not right and the idea is pretty simple if every node commits then the decision is commit if every node if even one of the node aborts the decision is about right so that the at the end of phase one a has information about all the nodes whether they are trying or whether they are whether they can commit or they can abort it knows its own decision so in totality a would know if the overall decision is going to be commit or abort in the phase 2 what would happen is your process a will broadcast this information like basically this decision to all the nodes in the network right so once a has understood that final thing either this commit or abort it will let this information percolate in the network well such that b c and d would be known i like would realize that hey are we committing or not right they would know they would know the decision from a because a is sending the message to every one of them so just to reiterate two face commit happens in two phases first one where everyone sends its decision to the coordinator node in the phase two your coordinator sends the final decision that the entire cluster is taking to every single one of the node as simple as it can be right okay in case in case if any node did not participate in round one due to any reason maybe crash maybe anything they will be deciding on the decision sent by a so whatever a decides because you did not participate you have to live like it's classic election case where even if you didn't vote the person who came into the power you have to abide to that person because that person is the leader slash king slash minister whatever you want to name it right okay this is a classic case of two-phase commit right now here the interesting part is obviously it is not full proof it's prone to a lot of failures and which is what gave us rise to other algorithms but now let's understand the failure scenarios in a network that implements two-phase commit protocol case number one where your coordinator node fails before initiating the first phase so what would happen let's say you got some right and you wanted to know whether my network is going to commit or abort but a coordinator node before even initiating the first phase whether when the other nodes are sending the the coordinator node the information their decision right if it failed which means that your consensus did not begin at all so all good so because nothing even got started even if your coordinator fails with at that time it's all good because you are not making any decision what would happen typically for coordinator it crashes the network automatically picks another coordinator through any leader election strategy right okay second if the coordinator fails after initiating the first phase which means that what would happen if your coordinator after initiating the first phase which means that while it is about to receive messages from the participating nodes what if some of the nodes sent a the message which means it send their decision whether they can commit or report if they send their decision to the coordinator node what would happen so some nodes who send that state are blocked on the coordinator to respond classic case because your coordinator failed after initiating the first phase which means if b and c send the decision to a the coordinator now b and c would be waiting perpetually to receive response from a that what's the final decision because they are just telling their decision now a needs to make the final decision and send them so if your coordinator fails after initiating the phase one the everything comes to a halt because the the nodes who send the messages to a they are waiting for a response to come from a but a is crashed so they will not get any information so this is a perpetual starving but you can solve it with timeouts and doing a re-election and what not but it is a critical case where up until the time your nodes realize that the coordinator is down everything comes to a grinding halt they are continuously waiting right case number three where your two face commit comes to a halt when the participant crashes before sending its preference to the coordinator because coordinator cannot proceed let's say you have three nodes or rather your network has four nodes one of them is coordinator three nodes are sending the first node the information so b c and d are sending the information to a what if b sent a message c sent a message but d crashed a is waiting for the decision from d up until the time a realizes that d crashes a is blocked so your entire two-phase commit comes to a grinding halt up until all the nodes can send their local decisions to a problem right this is a failure scenario the next one this is an interesting one so if a participant crash at phase two which means that they all let the coordinator know about the decision now coordinator is sending the final decision to the participant and at this stage if one of the participant crashed now what would happen right so the coordinator the coordinator does not know if the participant who just crashed crashed before applying the changes or after applying the changes right all the coordinators know the global decision right whether it had to commit or abort but your participant who crashed coordinator does not know that if the participant applied the changes or it or it was about to apply the changes at that time the crash happened so when here when the participant comes back up it does not know if it has to commit or abort problem this is a classic case so that is where obviously all the participating nodes needs to somehow maintain this state persistent so that even after recovering from the crash they have that information this is there to highlight this particular part now things become extra interesting in the fifth case where if coordinator and one participant die in phase two so every node send its local decision to a a made the global decision now what a did is a when it is broadcasting the information it is broadcasting the information one by one to each of the other node right so b c and d a sending message to bcnd individually say a send a message to b and after this a and b both crashed so when this happens the biggest problem here is when other nodes would be electing the leader other nodes are not aware on what the decision was made by a because they are yet to receive the message from n before that only a crashed which means the decision of the coordinator is not known by anyone right and now when the participant has when the participant has crashed the same problem comes back up again where after recovery participant does not know what to do so participant in itself needs to maintain the state if it received a message it crashed before or after and what not but this is a classic case where after recovering you are not like your system is not able to auto proceed primarily because it does not like the system the entire system is not aware of the final decision that has been taken so re-election after that things come to a grinding halt problem so that is where these are the challenges all that sounds so simple but in distributed systems anything and everything could go wrong and thinking of that such edge cases are not so uncommon you'll find them in your day-to-day use cases as well right so that is that we have to be extra careful when we are designing or picking up a particular protocol right so this is one of the reasons why two phase commit is called as a blocking protocol because in case of a failure of a colleague or a participant in most cases you are not able to confidently recover and resume your operations you might need some manual intervention here and then it's not so easy so there has to be a better way to do this which we'll be discussing in the upcoming videos right but just to do a quick complexity analysis of this we know that your two-phase commit happens for two rounds so that's your time complexity and your communication complexities because in first phase every node sends message to a which means n minus one message will be exchanged and in the second phase a will be sending message to n minus one nodes so the total number of communication happening or the combination complexity becomes two times n minus one so two n minus two is the communication complexity of this algorithm right that's not so critical as compared to the edge cases that we just saw which is where we introduced a new protocol called a three phase commit which will be taking a look in the next video right so yeah that's it for this one i would highly encourage you to draw a bit of flow diagrams to understand all possible failures in errors that we just talked about so that you understand the beauty and the beast of distributed systems because it's not it looks very easy but it's definitely not because a lot of edge cases are there that that basically pops up when you are working in a distributed environment so yeah that's it for this one if you guys like this video give this video a thumbs up if you guys like the channel give this channel a sub i post three in-depth engineering videos every week and i'll see in the next one thanks [Music]