EIG Algorithm for Distributed Consensus

Exponential Information Gathering for distributed consensus Reaching is extremely important consensus in " " distributed network any . eg : we cannot have two data nodes in a cluster such that one thinks price = $1000 while the other thinks price = $2000 the Depending on which node the request hits , user would see the value inconsistent view corresponding , giving an somehow the nodes need to value agree on one . . Achieving distributed consensus is easy when No failures - - is impossible when network unreliable - and tricky when unreliable process Exponential Information Gathering Core Idea : Relay the values across rounds , record the communication path , and decide .

Elk Data Structure Ela data structure tree that grows is a exponentially . The paths root the tree represent from the of 2 3 the communication path from which the . . . . . . . ' ' : : : ( , : received propagated ) message is : < I _ _ , - . I - - 12 ; 1h 31 : N n :p I :3 32 3 The tree constructed level : . is level by : : : : : 327 and is designed to hold all possible permutations 3271 of length K . ( distinct paths ) 32714 At each level K node has , every n - k children to maintain uniqueness of the path " " Root node is labelled as 13.2.7.1 ] if message labelled 4 a node received a . it holds the message in the tree along that path level 3- deep EIQ Hence the data structure is like a trie constructed over 3 nodes A. B and C A B L C AB 17C BA BC CA CB ABC ACB BAC BCA CAB CBA

The algorithm we assume at Max f- nodes would fail while achieving consensus . The algorithm runs for f -11 rounds chances giving for f processes to tail . In each round level in EIG Tree is built level , a new using preu Each maintains its own Elk Tree process The processes values from upon receiving 2 3 other nodes / processes their . . _ _ . . update . , own copy ' ' : : : , : : the tree of . < I _ _ , - . I - - 12 : I :3 1h 31 : 32 3in N n . : : : : / : : After f -11 rounds the nodes : , procs 327 to their local EIG Tree to decide the value refer . so , 32>14 Node takes the decision * independently Building the tree is a way to gather entire information The decision rule at hand is totally upto the use case . Round 1 : Every process i , 1. sends its value to the entire network ( including itself ) 2. receives value (v) from other node j update the tree [ j ] = V

at the end in the network of round 1 . every node will have the Elk Tree with same depth =L A B C V, Y V2 Round K 2 K , ft 1 : Every process i , 1. sends all pairs ( Niv ) from K - L level in the network where i is not in keg : process B would send tree IA ) and tree lc ] in round 2 process C would send tree / A ] and tree 113 ] in round 2 Node A can thus form the next level A B of the Elk Tree c v, u , % With path AB CB , , AC , BC - AB AC BA BC CA CB Node A will send the (Niv ) to tree 14 itself as well , thus receiving values of tree IB] and from A It uses these values to construct path BA and CA thus the entire level 1 completing . This process is repeated at each node and thus every node will have the exact same Ela Tree .

Thus we see how every node has the nodes 1. all values from all A B c V, u , 2. all values across all paths % AB AC BA BC CA CB The algorithm stops after ft 1 rounds Elk tree and gathers Each node simply goes through its own copy of all values seen so far set choose 0 if Singleton . if set has multiple values , choose default % Alternative decision strategy Depending on the use case , we may choose any decision strategy } I. pick the smallest one so long as we have total ordering 2. pick the newest one the values of $1000 , 9:00:00 am < Total ordering on timestamp $ 2000 , 9:00:01 am the latest nodes deciding on one < $1500 , 9:00:02am