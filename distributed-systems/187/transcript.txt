in a distributed system what if one of the nodes wants to efficiently broadcast a message in the network the situation is not as simple as it sounds because there is no single node that holds the information about the entire topology all they know is their immediate neighbors that's it in this video we take a look into an algorithm that powers synchronous breadth first search traversal in a distributed setup understand its time and communication complexity and talk about its applications but before we move forward I'd like to talk to you about a portion system design that I have been running for over a year now the course is a cohort based course which means I won't be rambling a solution and it will not be a monologue instead a small focus group of 50 60 Engineers every cohort will be brainstorming systems and designing it together this way we build a solid system and learn from each other's experiences the course to date is Android by 600 plus Engineers spending 9 cohorts and 10 countries Engineers from companies like Google Microsoft GitHub slack Facebook Tesla Yelp Flipkart dream 11 and many many more have taken this course and have some wonderful things to say the coolest part about the course is the depth we go into and the breadth we cover we cover topics energy from Real Time text communication for slack to designing our own toy load balancer to clickbusters live text commentary to doing impressions counting at scale for any advertisement business in all we would cover roughly 28 questions and the detailed curriculum uh split week by week can be found on the course page which is linked in the description down below so if you are looking to learn system design from the first principles you will love this course I have two offerings for you the first one is the live cohort viscose which you see on the left side and the second one is the recorded course which you can see on the right side the Live code base course happens every two months and it will go on for eight weeks while the recorded course contains the recordings from one of the past cohorts as is if you are in a hurry and want to binge learn system design I would highly recommend you going for the recorded one otherwise the Live code is where you can participate and discuss things live with me and the entire cohort and amplify your learnings the decision is totally up to you the course details prerequisites testimonials can be found on the course page dot me slash masterclass and I would highly recommend you to check that out I put the link of the course in the description down below so if you are interested to learn system design go for it check out the link in the description down below and I hope to see you in my next cohort so breakfast search is a very critical algorithm in any distributed system because it Powers some of the key features that we need for example if you were to broadcast a message in a minimum amount of time that first search comes at play right when you want to build a topological understanding of your network that first search comes at play when you want to compute stats about your network for example how big your network is or basically what's the diameter of your network is then again that first search traversal comes at play right now this breadth first search traversal is the algorithm that we'll be discussing is a synchronous algorithm now this what does this mean like you would have heard this term in quite a few videos that I put out that it's a synchronous algorithm so here the key idea of a synchronous algorithm is that every single node of the network participating in the algorithm they know when to move forward they are not like they are independent but they are synchronized to move forward together and the way they would be achieving synchronization could be pure time based ticks or maybe some sort of message passing system we are not going into that implementation detail but somehow they are synchronized because there are algorithms to achieve that but if I talk about it it would be a huge video on its own but understand this for now that synchronized like because this is a synchronous algorithm every single node would be taking its algorithm forward synchronously with other nodes so they would be moving forward in sync right okay now that we discussed okay this is the problem statement and this is what we are doing but what would be the output of our algorithm so because it's a breadth first search traversal the output of this traversal would be a breadth first directed spanning tree which means they see the the distributed Network they can it can be it can very well be a bi-directional network which means every two nodes are connected via bi-directional communication let's say TCP connection right but the output of this algorithm because what we want to do is this is not where we stop breadth first search is not where we stopped this is a building block to power a lot of other functionalities which means that we need to come up with something concrete that would help us uh build a lot of other systems on top of it so that is where the output of this algorithm will be a breadth first directed spanning tree now what is a spanning tree same as our graph algorithm in our typical DSA course uh spending tree is where you cover all the nodes of the graph but only a limited number of edges or rather a bare minimum number of edges for you to cover the entire graph right this is what the spanning tree is all about right it may not be a minimum spanning three but a spanning tree nodes with edges with the bare minimum edges that they converge right so just to highlight that point a node may be reached via multiple nodes but in a BFS spanning tree only one of them would be the parent right so this is what is important understand because this is what would lay the foundation for a lot of routing based distributed algorithm or traversal based distributed algorithm okay now we are converging again no matter how many edges are there we would be reaching to every single load with a subset of edges may not be minimum may not be maximum but the number of edges that we would need to cover we would be keeping it to a bare minimum right it may not be minimum weight while not talking about it but just be clarifying that okay so now that we know what the input is what the output is now in a distributed setup see how how interesting things get right now let's talk about the algorithm so because the algorithm is synchronous right so every node moves forward step by step round by round like they're synchronous in that way nodes proceed in sync and let's let's say the BFS the breadth first search has to be initiated by some node right it cannot be like like when you are building that topology you need to know okay hey this is the node which is initiating the breadth first search in my network now we say that let us say I 0 is the node that initiates the breadth first search and there are total nodes in the system now the algorithm proceeds round by round the first round is where I 0 sends a search message to its neighbor Now search is just a general terminology implementation like you just need to create a text message and then send to the nodes but I'm just classifying that message as a search message right so I 0 sends a search message to its immediate Neighbors because the only thing that the node knows are the immediate neighbors nothing else right so when and when a node receives a message right when a node receives a message it first checks that hey am I marked like did I receive a search message from someone else before if I haven't which means if I'm an unmarked node then I will first Mark myself that hey I received something now I am part of the spanning tree right and as soon as I know okay hey I've never received a message before and this is the first time I'm receiving the message I'm part of the spanning tree and I'll update my parent so whenever a node receives a search message if it is an unmarked node then it would be marking itself hey now I'm part of the spanning tree and this is from and this is the node from which I received a message so this node becomes my parent right and this is what the first round is going to be right now in the second round the nodes who received the message in the first round right like for example if not I zero send message to A B and C now in the second round a b and c would participate so the the idea is with every round the nodes who just received the message would participate in the next round right so the nodes who just received a message in the round one participates in the round two and they send a search message to its outgoing Neighbors and this process repeats until the entire graph is covered it's easy for me to say but how how do we do we'll talk about that right so here the receiving node takes action by marking themselves and continuing the process eventually every single node will be covered and would be having a and would be part of a spanning tree right and we would be covering the center but we would know for each node which other node is the parrot although it might be reached via multiple path we would know which one of that is the pad right now if we talk about the complexity analysis of this the given that the nodes proceed every round the time taken to cover the entire network will be proportional to what to the farthest because at each round my the nodes that received a message in the previous round they participate there right so what would be the time taken for me to cover entire network it would be the maximum distance between any two nodes in the graph and that is nothing but the diameter of the network so if the diameter of the network is 5 it would take me five rounds to reach that so the time complexity of this is the diameter of the network right and the number of messages that are exchanged which is the communication complexity will be what will be because we are sending how many messages in each round the number of outgoing edges from the nodes participating in them and once then that node participates they're not re-participating again so what would happen is the overall messaging otherwise communication complexities which is the number of messages exchanged would be equal to the number of edges in the network so this is the complexity because this is very different from our traditional graph algorithms on how we measure complexity distribute system we do it with time complexity and communication complexity right now here when we think about this let's say we built this spanning tree but in most cases what is happening here up until now is every node knows who it's who which node is its parent but parents should also know which one of the nodes chose it to be the parent so for example if I zero sends message to node a b and c and let's say A and C were already part of the spanning tree so B is the one who received the message for the first step and it marked i 0 as its parent so I zero needs to know that b marked itself as the parent basically just having an outgoing H does not mean that that node is the parent in this distributed spanning in this distributed breadth first padding tree right so we need to know out of a b and c which one chose it so basically I zero should know right who did that so how do we accomplish it so here what would happen is as soon as a node receives the search message and if it is marked like if let's say it is already part of the spanner it would say I will discard the message right so note discards the message and if it is not marked which means it is receiving the message for the first time it would update its local state with this as the parent so if we receive the message it would Mark I zero as the parent locally locally it's not any broadcast something happening right now this was the usual flow but now because I 0 wants to know who chose it to be its parent now what would happen the node B would need to send a message would need to send a message to i 0 hey I chose you as my parent now if only B sends the message that hey I chose you as a parent what about a and C if I zero does not receive message from AMC A and C because it's received system something could go wrong it would it might just wait infinitely for them to receive the message or it might just assume that the message was never reached there like so that's why we have to be very concrete with the implementation very robust with the implementation so what we do is whenever we send or wherever a node receives the search message from other node it would be sending back if it's a if it shows the other node as a parent or not so parent slash non-parent message is sent from all the outgoing nodes to the node from which it received the message right so that that node would know if it is chosen as a parent or Not by the other word this way the parent now also knows the information about the child that hey these are the notes in my directed spanning tree these are the nodes who picked who chose me right and this is how you would build uh like you would have your nodes getting to know your child as well as your parent like all those knowing that information right okay now comes the main part how would your algorithm terminate we discussed how it would take it would take diameter number of rounds to reason but how would you know or how would the nodes know that algorithms terminate because everyone's working independently they don't know on what's Happening How deep the network is they know something like n nodes exist that's it but if there is no Central there is no one node that holds all the information together this is the Beauty and the Beast of distributed system right again we can't do much about it so that is where and that is why throughout this series you would have seen how much stress are we putting into terminating an algorithm because that's extremely difficult when we are in a distributed setup single machine it's okay you can just run a graph algorithm and you know when the process ends distribute system you can't say much okay so this is where the approach that we take for the termination is called as converge cast we have heard of broadcast where we broadcast a message now converge cars is the opposite of that where everyone sends the message to one so it basically all the messages converts to a single node right so the core idea building on the child pointer that we talked about that a message sent to the outgoing edges the nodes report if it's parent or non-parent to the incoming node right now here just a slight twist to that that a node responds or to the to its parent only when it receives message from all of its children or all of its outgoing roads as simple as that so we are adding this blocker so that we maintain this synchronicity that hey once everyone like one like you would respond only after you received an acknowledgment from every single of your child this way you would see it very beautifully converges to the node that originated it so let's say I sent a message to A B and C let's say B has children d and e so B would wait for response like parent slash non-parent message from d and e when it receives message from both then only it would send reply to i0 right and this is the idea this is called as a converged cast in distribute system you'd say how complicated it is like like it was so simple it's not it's distributed system node has no information about what's happening at other node and which is where you have to rely on message passing you have to devise these algorithms such that you are not missing out on any case it looks like extremely small baby steps but that's how distributed systems are you have to take those extremely delicate baby steps to ensure that everyone's on the same page right so by adding this Blocker we are ensuring that the outgoing messages percolate and then a node responds only when it received all the messages or all the responses from its corresponding children and so on and so forth this way the originating node would know hey this is like these are his children and now the algorithm is complete and then it would inform key and then it would then it may again send a message in the network that algorithm is complete and whatnot but in this case it does not need to because it was not a leader election that you need to announce something it would just know that algorithm is complete right and then it can proceed to other use cases that needs to be built on top of the spanning tree right and again this is called as convergecast where we are converging back to something this is an important pattern in a lot of distributed algorithms right now here two very interesting cases first of all if the network is bi-directional it would be simple like for example if we send message to D if let's say I zero sent message to A B and C it's easy that on the same communication line a b and c can respond to I zero right because the communication line is bi-directional what if that communication line is unidirectional which means that i 0 can send message to a but a cannot respond back to i0 so how would a tell i 0 a would initiate another breadth first search to inform this message to I zero via some different parts so in a directed in a unidirectional distributed Network where the communication line are unidirectional it would have to recollect every node would be triggering another bet for search to inform its parent huge number of messages exchanged but you have no other way if the communication line is by if communication line is unidirectional you have to do this if it is bi-directional it can just respond back now you see the complexity of distributed system that you cannot even assume it's a bi-directional line you have to think about every single use case where we are deciding it and this is the ultimate beauty of distributed system right okay final thing to discuss in this video is applications applications of uh synchronous breadth first search traversal first efficient broadcast you you would have seen it from farthest of distance that hey this is the classic case where I can use this system to broadcast something to my network and I would do that everywhere received it okay so if a node in a distributed system wants to broadcast a message M it can just initiate the synchronized BFS algorithm with itself as the root the message would be propagated to all the children in the tree and they would be responding back acknowledging acknowledging acknowledging this traversal very heavily used for broadcast second is distributed computation you saw how converge cast was happening that a node waits for all of its children to respond this is a very classic case to power distributed computation further map reduce mapreduce is a classic case of this where you are sending a computation job throughout the network you are waiting for all the workers to come to compute then they send back the result and then you send back to the user right so distribute competition if you'd want to Fan out a computation in your distributed Network to in order to leverage the computational capability of your entire network this is the way to do it's a classic post order traversal if I talk about in a DSA language classic post order traversal and then as I said about Computing diameter of the network now what would happen is let's say I want to compute a diameter of a network which means that what is the farthest or what is the largest distance between any two nodes in my network now how can we achieve this every node initiates a BFS and thus they would be knowing which node is the farthest from that node and they would all converge flood each other with the same message and they would all know the global maximum of it and they would know the diameter of the network right so this particular algorithm breadth first search it's foundational for so many other things right and this are and these are the challenges that comes in when we are operating in a distributed setup like we cannot even assume anything it's the bare minimum assumption that we have to move forward with and I hope you like this and this is what I wanted to cover when it comes to breadth first search traversal in a distributed setup but now you see how challenging it can get how brittle the secret systems are but yeah that's the fun part of it right great so that's it that's it for this video If you guys like this video give this video a thumbs up if you guys like the channel give the channel a sub I post three in-depth engineering videos every week and I'll see in the next one thanks again [Music] thank you [Music]