Shortest Path in a Distributed System

Shortest Path in Distributed Systems Determining shortest path in a distributed system is an important problem to address . It finds its use case and affects the across many use cases performance of like most functionalities message to certain node - delivering a P2P network efficient routing in a - - internet works on similar algorithm Note: shortest is not just about the distance , instead it can also be about - congestion . Communication overhead , expensive communication channels , third party cable infra , etc . Hence , as a general problem statement . 50 two node we say each edge connecting 75 " u is directed and has a weight assigned This is the quantification to it . weight of cost / congestion / distance across nodes

Problem statement i 0 In a distributed network . Where nodes are L n connected via paths / edges having some weight 7 assigned , find a shortest path from a specific , L n a source to all the nodes . > < Shortest path : path with minimum weight Bellman Ford algorithm in a distributed setup Note: Because it is a distributed network no node knows the entire topology and weights . Most interesting thing Every process initially knows the weight about Distributed systems , all its incident edges and knows the has the complete of No one total number of nodes (n ) in the network information This algorithm is synchronous i. e. it proceeds " oeounds further synchronously in round to another All nodes move from one in sync via message passing or clocks .

the network Every node in 10 so > 2 knows total nodes n 72 - 100 < 7 - knows weight of the edge incident on it Every node keeps track of dist , that represents and holds the shortest distance to it from io Initially , disti = 0 and dist i. =D titi , , i 0 At each round node sends its Dist , every L n 00 to all of its neighbours . 7 Round I Outgoing , co s L ^ D Node io sends dist = 0 to its neighbours 00 > L 00 other node sends dis -1=00 to theirs Every Each node i. upon receiving an incoming dist from j , compares 1 . its oven dist 2. incoming dist + weight " ij distj wij j J 7 disti < Wik k distk

After comparing . it updates its own dist with the minimum of the compared value and this signifies the minimum distance ( until now ) from Io 7 dis ti = MIN ( dis ti , distj + Wij t neighbour j ) Classic relaxation step in Bellman Ford algorithm Given that . We also need to know the shortest path , every node keeps track of the parent . dist i relaxes the parent of the node is updated if the . distj = 50 i receives dist from j and K 10 j 40 and it relaxes dist s from 100 dist = 100 , 20 > to 40 ( incoming from K + wt ) k parent = j to K k Hence , i changes its parent distk = 20 Round n - 1 After n - 1 rounds , dist at every node will contain the shortest distance from Io and contain its parent shortest path parent will in

The algorithm discussed is just distributed variant the we a of classic Bellman Ford algorithm . Complexity Analysis ' ' Because rounds to the we require n - I complete algorithm , the time 01h ) where # nodes in the network complexity is n : . Because at every round . every node sends message ( dit ) to all its neighbours . the communication complexity is 0 ( n IEI ) where IEI are # edges in the network .