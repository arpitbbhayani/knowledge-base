so to keep our distributed systems efficient and performant, we have to ensure that the messages that are sent within the network they take up the most efficient path.
can we not use a traditional shortest path algorithm in this setup?
there is no single node that holds the information about the entire topology.
every single node simply knows about its neighbors and the incident edges, like the edges that are coming in or going out.
right in this video we take a look into a variant of a famous bellman ford shortest path algorithm and see how it operates in a distributed setting.
but before we move forward, i'd like to talk to you about a course on system design that i have been running for over a year now.
the course to date is enrolled by 600 plus engineers, spanning nine cohorts and 10 countries.
engineers from companies like google, microsoft, github, slack, facebook, tesla, yelp, flipkart, dream 11 and many, many, many more have taken this course and have some wonderful things to say.
so if you're looking to learn system design from the first principles, you will love this course.
the first one is the live cohort discourse, which you see on the left side, and the second one is the recorded course, which you can see on the right side.
the live code base course happens every two months and it will go on for eight weeks, while the recorded course contains the recordings from one of the past cohorts, as is.
if you are in a hurry and want to binge learn system design, i would highly recommend you going for the recorded one.
otherwise, the live code is where you can participate and discuss things, live with me and the entire cohort and amplify your learnings.
thanks, so determining the shortest path in a distributed system is critically important, right, because it finds its use case across so many things, and whenever it talks about performance, of delivering messages, you think about your test path first, right?
so some of the functionalities that it powers really well- or we need shortest path algorithm to power them- are: let's say you want to deliver a message to a specific node.
that is why you first construct the shortest path from a single node to all the vertices and then you send it across that.
and second is when you want to do an efficient routing in a p2p network, again a shortest path system would come in.
if i want to go to that mega scale, it works on this very similar algorithm, like not the entire internet scale, but on subscales of that.
so when we talk about shortest path, first thing that we have to definitely throw out of our head is it's not just about the distance.
for example, if two nodes of a distributed system are connected via communication line, a lot of things could go wrong.
so when you are doing the shortest path, it's not just a distance, it could be congestion, or rather it could consider congestion, communication overhead, expensive communication channels, third-party cable infra and whatnot.
so when you think about shortest path, it is not just the distance, it's not just the time, could be n number of factors that you may want to optimize on.
so, depending on what you want to optimize on, that became the weight of the edge and the idea is to go for the shortest path so that you are efficient, performant, cost efficient and what not, whatever you want to add, you can do that right.
so, as a general problem statement, we say that each edge connecting the two nodes in the distributed system has a weight assigned, and this weight is the quantification of costs: less congestions, less distance, less time slash, capacity, whatever you want to do, right, the idea is to do this thing very efficiently when nodes would need to communicate and node needs to know how to do that right.
okay, now coming to the problem statement: like, unless we define a good problem, we will not be able to understand the solution.
so, coming to the problem statement, in a distributed network, what we are trying to do is, where the nodes are connected via edges, having some weights assigned, find the shortest path from a specific source to all the nodes.
right, because anyway we are doing this distribute setup, we are anyway traversing through all the nodes.
why don't we just find the shortest part to all of them, which is where bellman ford in our, in our graph slash data structures?
distribute systems has great applications for the bellman ford shortest path algorithm.
right, and the shortest path is the path with the minimum weight.
okay, now let's look at how bellman ford algorithm beautifully sits in a distributed setup.
now here, just as a disclaimer, it's a distributed network, so no node knows the entire topology orbit.
everyone just knows the weights of the incident edges to it and the total number of nodes in the network.
we have to devise a shortest path algorithm.
okay, the algorithm that we are discussing is synchronous in nature, right, which means that it proceeds further in steps, synchronously or in rounds.
it could be clock based or basically time based synchronization, where everyone does it like every one second they would move forward, or it could be another message passing- that could be happening, but somehow synchronicity is maintained.
but this algorithm, the core of it, is it moves synchronously forward, like every node moves synchronously forward, step by step.
right, and this is where it is extremely important.
this is how synchronous algorithms are built like.
okay, so now every node knows n and the weight of the edges incident to it.
classic bellman ford implementation, but in a distributed setup.
so what every node would do is every single node would keep track of a distance, some variable called dist or some quantification called dist, which is which represents the distance, the shortest distance of that node from the source node.
now the source node could be i zero, let's say i zero is initiating the shortest path to all the nodes.
right now what we do is classic bellman ford use case.
the nodes are still not reachable, right?
at each round, every single node sends out its disk to all of its neighbor right.
so in round one, every single node, every single node participating it, sends out the dist that it has to all of its neighbors.
so i zeros, dist is what zero, so i zero will send zero to every single node that sits in its neighborhood right, and then every other node, because they all have distance infinity.
they would send infinity to their neighbors, right?
now, when a node receives a message, now what would happen?
so let's say a node, i received a message from j.
that when it received a distance from j, like the dist from incoming node j, what it would do is it would compare two distances.
first, the distance that it has, which means the distance that it has seen up until now, the shortest from i 0.
now, incoming distance is j, the weight of the edge it would know, because every node only knows the weight of its incident edges.
so the node would know the weight of this incident edge.
so it would do incoming list plus weight of this edge and it would compare it with its own dist.
so if the incoming distance plus the weight is less than the distance that it has already seen, which means that there exists a much shorter path than what it thought it was, so it would update.
and now when this happens, right?
so, after a node receives incoming dist from all of its neighbors, it does, it basically does this what it does, it continuously keeps on updating and eventually it would have the minimum value of what it has seen from its neighborhood.
right now, this is how a node would know about the distance.
now how would you know the path of it, which is where every node also keeps track of parent?
so if let's say, i had some distance from a particular node, but now let's have seen a better distance like distance plus weights edge computation.
i will update my parent whenever i can relax my distance, and this is how every node would also know about the shortest path from i coming from which parent.
it would not know the entire path, it would just know that from this parent i would receive, like i, i am in the shortest path from i zero- we are this parrot- or via this other node- and this is really important- of a step in a distributed setup, because, no, no knows the entire topology, which is why you have to take this extreme baby steps when you are devising the algorithm.
right and now you can very clearly see that when we are continuously relaxing, or when we are continuously updating the minimum distance at each node, after n minus 1 rounds, what would happen is the all the messages across all the nodes would be sent, or sorry, all the distances across all the nodes, across all the rounds, will be sent to all the nodes.
now, this way, what would happen is every single node after n minus one round would contain the shortest distance from i zero and the parent variable at each node would contain the parent like: from i zero to that node via which parent right.
and this is why every single node should also know n, because that's what it would know that the algorithm basically terminated, right?
okay, and this is a classic distributed variant of the famous bellman ford algorithm for shortest path.
and this is why- now you know that- why we need a single source, all node shortest path algorithm, because in a distributed setup the communication itself is so costly that while you are doing it, you would want to do it all rather than just doing it for one note.
okay, now quickly, quickly, concluding this video on the complexity analysis of this approach, because we saw that it would take n minus 1 rounds to complete the algorithm and every node would know what n is.
every node would know that round one is done, round two is done, round three is done.
that's why it's important for all the nodes to know n, the total number of nodes in the system.
so the time complexity of the system is order n, because where n is the n number of networks, you take n minus 1 round.
so order n is the time complexity of it right now because at each round, what is happening, every single round, every single node is sending message to all of its outgoing edges.
so the communication complexity, which means the total number of messages exchanged, would be equal to the number of rounds multiplied by the number of edges that you have.
so n into e, like order of n into e, is the communication complexity of this algorithm right now.
obviously, there are ways to reduce it if you'd want to, but you might not need to right.
order of n comma e is the shortest path, is the communication complexity of this approach, while order n is the time complexity of this approach.
now, it's important to understand this complexities because in distributed system, this is extremely critical.
and that is it about shortest path, right?
i hope you had fun understanding how things work in distribute setup, how we have to take baby steps whenever we are moving forward, otherwise it's it's going to be fully, fully chaotic, right?