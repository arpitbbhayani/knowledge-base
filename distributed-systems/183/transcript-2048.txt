see you in my next cohort, thanks.
so say, in a distributed system, we have a node which is acting as a leader and then other nodes are actually following it.
right now, what could happen?
that leader could go down.
and if the leader goes down, we don't want an engineer to configure some other node to be the new leader.
this has to be an automated process, which is where the leader election algorithm kicks in, where it helps us not to do this manual intervention and fix the system right with lcr algorithm.
this is one of the simplest algorithm that you could think about, but it's very effective, right?
this algorithm, it works in a synchronous mode.
synchronous mode means that every node which is participating in this election would know: hey, now my election is starting.
right, and this is what the synchronous mode is all about: that every node.
it's not that nodes are pitching in their words at their own time.
this starts and ends in a synchronous mode that everyone knows: hey, now it's first step, now it's second step, now it's third step, and everyone is participating in it, right?
another thing that this algorithm requires is: no matter how the topology is structured, there should be a way through which the nodes by the nodes of this distribute system needs to know what's in its clockwise direction, like the immediate neighbor in the clockwise in the clockwise direction, which means that it needs to form a unidirectional ring.
it may hold some other information, but this is the bare minimum that we expect: that every node needs to know some node in its clockwise direction so that it can form a topological unidirectional link.
right now, this algorithm is so beautiful that it runs or it works, even when we don't know the total number of nodes in the system.
we just know: hey, this is a distributed system having some number of nodes which are connected via unidirectional ring, but it does not in, but it does not need every node to know the total number of nodes in the system.
it's that beautiful of an algorithm that it's so simple that it does not need any additional information whatsoever.
right, every node has a unique uid.
it will be an integer or a bit string.
to be generic, it can be a bit string, but not a large enough.
every node has a unique identifier, unique implying two nodes cannot have the same id, and which is extremely important for this algorithm.
second is uids are comparable, which means, if you can do less than greater than on node, uids that you have, and every node knows its immediate clockwise neighbor.
again, we don't need any information about the total number of nodes in the system and this algorithm still works.
right now, let's take a look at this algorithm, what this algorithm is all about.
so, in this algorithm, every single node.
so as soon as someone detects that hey, leader is down and that node triggers an election into the system, now what would happen?
every single node, because it's synchronous, every single node would know that the leader is down and everyone knows that, hey, now the leader election process begins, right?
so, given that every single node participates in this election and every single node pitches itself to be the new leader, like when the leader is down, every single person of the gang says: hey, i want to be the new leader, right?
the pitch is very simple: it's just a message.
so every node creates a message with its own uid and send it to its neighbor, because that's the bare minimum expectation that we have: every node knows its clockwise neighbor, bare minimum expectation.
so what every node would do is it would pitch itself, which means that it would create a message with its own uid in it and send it to the neighbor that, hey, i would want to participate in this election and i want to be the new leader.
now what a node would do when it receives a message from its neighbor?
so, when a node receives a uid from its neighbor, it compares the incoming uid with its own uid.
now what it would do is it would say, hey, i have some uid.
let's say i have uid9 and my incoming uid is three.
it would compare the incoming uid with its own uid and would check.
so if incoming uid is greater than own uid, right?
so let's say i am nine and i received a message from three that three wants to be leader.
i, i know that i want to be the leader.
so now what it would do if, if your incoming uid is less than your own uid, you would discard incoming uid because, hey, you are smaller or you are younger, don't do you?
you cannot do that, right?
so you would discard the message coming from a node whose uid is lesser than yours.
but if yours is greater, oh sorry, if the if the incoming uid is greater than your own uid, which means that, hey, you were 9, but you received message from, let's say, 18, so 18 is greater than 9.
so now what you do is you would forward the uid to your neighbor.
so you would say, hey, i received this message from 18, i am 9, so i am forwarding 18 to my neighbor, right?
so this way, the larger the uid, the more it would go around the ring, right?
and if, if i receive the message from alex, so i receive a message with my own uid, because you, as a node, you are forwarding your candidate to your immediate neighbor.
but if it survives the entire ring and it comes back to you, which means that you have the highest uid, given that you have the highest uid, you declare yourself as the leader, right?
so here what would happen is, because every single node is participating, the message by the largest uid will survive the ring, because everyone is forwarding the message with the highest uid, right?
if it is greater than its own uid, it is just forwarding it.
so the node with the highest uids message would be surviving the entire ring and would be coming back to the originating node, and when that happens, it would know that, hey, i started like i have.
like the node would know that, hey, i have the largest uid, which means that i am the new leader.
and now this node would then announce this through another message, relaying into this network that, hey, i am the new leader going forward.
so what this algorithm does?
it basically says that the new leader is the one whose node, whose node uid is the largest.
and the way it does this, it basically takes this message and forwards it in, like every single node in this distributed system participates in it, creates a message, pitches itself, sends it, basically sends it to its immediate neighbor and the neighbor then basically relays it.
if it is, the incoming uid is larger than its own uid, right?
so this way, the only message that would survive would be from the node that has the largest uid and, given that that node, the message comes back to the originating node and it would know: hey, i have the latticeword and i'll be the leader, right, and this is a very simple literal election algorithm called lcr.
right, and now, when would this process stop?
because in a distributed system, the most important part is to know when to stop.
so, halting, like when would this algorithm hold?
there is no way for a node to know that the election is over, right?
only the leader would know that.
hey, now my message came back to me again, which means that now we know that the only the new leader would know that it is the new leader and would know that, hey, now it's time to stop the election.
so the new leader, because you don't know the total count.
so that's where the only the new leader can tell: hey, now this is going to stop.
now i am the new leader, so hold the election.
so the new leader.
when it knows that, hey, i am the new leader, because it received its own message, it would create another message and send, would announce itself to be the new leader in the system.
and that's how every single node halts the election process, right?
so when they receive this report message that hey, i am the new leader, they all, every node, halts the election process.
they store the new leader information locally and forwards the message to a cvj number.
so the bare minimum assumption that we are making is: every node only knows about its neighbor to its immediate right or in the clockwise direction, whether this is the.
they may know other nodes, but this is the bare minimum expectations that we are making.
so that's where, when a new leader announces, the message would be sent to the node next to it.
it would halt the election process on its own and then stores this information that hey, this is the new leader and forwards the message to the next node.
this way the entire ring would know that hey, this is the new leader and the election process would stop.
every node pitches itself the mess and every node forwards whatever incoming message it got.
if incoming uid is greater than this, the worst case of this the number of messages is n?
square because every node is doing it.
the message is sent to every node to the next.
so worst case is n?
square, where every node is forwarding every message to the next node unless it basically disappears to the node before that.
so the worst case: complexity, the number of messages.
the compute in it is basically called as communication complexity, the number of messages exchanged.
here the number of messages exchanged would be order of n?
square, because every node is not just receive, is sending the message for its candidature.
it's receiving message from its from its previous neighbor right, and the messages survive from from the previous neighbors as well.
so the overall communication complexity is order of n?
square, which might be problematic when your distributed network is large.
but for a smaller distributed network this would work just fine.
one more reason why communication complexity is important: because if you are exchanging large number of messages, what would happen is your network can get congested- congested with respect to the constant movement of packages operating at the network layer.
so any algorithm in distributed systems is always designed in a way to keep the communication complexity bare minimum.
square.
worst case communication complexity works very well for smaller network.
might not be good enough for the larger one, right, but yeah, this is what its amortized analysis is, and so yeah, that's it.
this was a very simple, intuitive lcr algorithm for later election.
now you see how people think when they write distributed algorithms, and this is what ideas: take baby steps that at every time you are moving forward in time, just take the bare minimum baby step that you could think of and you would have a very nice, robust distributed systems algorithm at hand.
that's it for this video.
if you guys like this video, give this video a massive thumbs up.
if you guys like the channel, give this channel.
so i post three in-depth engineering videos every week and i'll see the next one.
thanks [Music] you.