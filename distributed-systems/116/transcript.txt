so in the previous video we went through the theoretical part of distributed transaction using two phase commit protocol in this one let's implement a two-phase commit protocol locally right the idea or we we basically continue our same example of zometro's 10-minute food delivery and what we'll do is we'll go through the different components that we would need or the different low-level details that we would need understand the database schema understand how two phase commit protocol helps us ensure atomicity like how it guarantees atomic transactions we will do that and more importantly go through the code to see exactly how it's done okay so just just to give context to folks who have not seen the previous video i'll link it in the i card and i've and i'll actually put it in the description as well but just to skim it through let me just go through the the the basics of it so that everyone's on the same page right so what exactly is a distributed transition it's a transition that spans multiple machines basically in our case it's the the transition that spans multiple micro services so the the designer is the scenario we take is 10 minute food delivery by zomato the core idea here is like with respect to zomatos principle what it says that it will bulk purchase the food from restaurant keep it in the store and have a fleet of delivery agents who are there to delivery to to basically deliver the food within 10 minutes because the food is pre-purchased it just needs to be heat it just needs to be heated up and assigned it to a delivery agent to be delivered but now to guarantee a delivery under 10 minutes what zometo would have to ensure is that the food is available like when it shows to the user that the order is placed right this is very important when it shows to the user that the order is placed the food has to be available in the store and the delivery partner has to be available to deliver the food if either of the two is not there you cannot tell the user that you will be delivering the order in 10 minutes because what if food is not dead it will have to go to the restaurant get the food whatever deliverance is not that food will be heated up but deliverance is not there to deliver so you cannot guarantee a 10 minute delivery if both of these so this is a classical case of disabled transition which is what we would be making locally right so here the core part that we have to guarantee is unless both of them are there which means unless the food is available and delivery partner server then only you will tell user that the order is placed otherwise you will not tell the user that the order is placed right so order placing api should fail if either of the two conditions is not matched so what exactly are we trying to solve with distributed transaction here we are trying to solve that one order is assigned to one agent and so basically one order has one agent and one food item that's what we are trying to attain here and the more important part from the user experience part is that a user should not see order placed if it cannot be fulfilled right so the main thing that we are solving is resource contention so let's say if there is one delivery agent agent one and that particular delivery agent like that should not happen that two orders are assigned the same delivery agent or the same food item is not assigned to two orders right so resource contention is what we are solving and that too in a distributed setup so the end goal here is our end user should never see order placed if we were not able to get one food and one delivery agent assigned to it right so it's all about the user experience while solving for resource contention over here right so the the the two phase commit protocol is pretty simple what it says that it just splits the problem into two parts first is uh it splits the solution in the two part not the problem solution in the two parts the first phase is the reservation phase or the preparation phase what it would do is let's say you have three services order store and delivery as we discussed in the previous video so order service will talk to store service and say hey reserve food order service will talk to delivery service and say hey reserve an agent this is not about assigning an agent to an order it's just about reserving that particular person for delivery who anyone can use it anyone like it's not just a specific order that for whom that particular agent is assigned anyone it's just that agent is put on hold hey some order is that you have to go so you are reserving an agent for it then orders then now that the preparation now that the preparation phase is done there will be a phase of assignment or there will be a phase of commit when because you have kept aside you have reserved a food and an agent now the only thing that you have to do is just assign that food to an order and assign an agent to an order that's all you have to do so by splitting this into two separate phases we have we will achieve atomic transactions and you'll say hey but if i reserved something and but i did not but but the assignment failed due to some reason right so basically reservation reservation happened but assignment failed due to some reason so obviously you're not reserving something for eternity right the reservation will come with the timer and this timer is long enough to be honest the timer is long enough so that if the service goes under uh if if basic service goes under maintenance or if it goes down when it come back there should be a chance for it to revive the transition obviously this being a critical service you would not want to let it go down for a very long time but in any case your reservation will not span hours right you would have a timer set which say that hey after this much time my resources would be free like the food packet that you reserved for a particular order will be free will be now available for some other order to be picked so in this implementation what we are doing is we are keeping things simple to just understand how it is implemented and we will not go into the details of timer implementation so i'll assume that the timer is there for now what would happen because of this because we are not implementing expiration what would happen is items would be perpetually reserved if there is any issue we will see that in the demonstration as well the item will be perpetually reserved if there is any issue while booking so if it is reserved but not booked so item would be perpetually reserved but to solve that problem you just need an expiration on the key or cron job or a or a redis key expression anything would do that's that's pretty simple but that is assumed but for just to keep it otherwise the video would be too long to keep things simple we are not implementing timer but we'll get the gist we'll get the essence of it so let's go through the schema of delivery service so we'll start with delivery service to understand what my core database schema would look like obviously i'm not given exhaustive list of fields these are very specific list of fields that we need for distributed transactions to work right so uh let's say i have a table called agents in my delivery service i have a table called agents agent has an id agent the second column is is reserved what does this say they say that if this agent is reserved for any order any order not just a specific order but any order if this agent is reserved for any order yes or no basically a boolean field and an order id right so order id is the currently like the the order which the agent is currently serving is what this order id column will define right so three critical columns over here id is reserved an order id obviously you can pick and choose on more detailed implementation but i am just taking it to the basics for us to understand the two phase commit protocols implementation then is reserved is to implies that agent is reserved for some order and order id is the order that the agent is currently serving so once the order delivery happens the the rows would be reset as it is reserved will be false and order id would again become done right a basic basic like we're going with a very basic implementation but even scaling it is not really difficult because no matter how much the traffic is you have a you haven't scaled up version of mysql one central database to hold that part of delivery service so you'll have few set of servers for delivery service each one of them making a call to uh mysqldb to basically to basically manipulate this table right and it basically gets request from orders service the second schema is for store service now this is an interesting schema because what i've done is i've split uh my food items into two sections the first is food which means that let's say there is a particular restaurant there is a particular dish let's say burger king's burger so this would have list of all food items obviously restaurant and all is missing i don't care about this in this implementation so here what it would have is it would have id and name just just for just for prettification sort of thing so one burger one name is barrier right but then we have another entity called packets these are actually barcoded packets which are placed in the store so zomato purchased it from the restaurant and placed it into the store and every single one of that packet is barcoded or it's or it has an id basically right which means that when i am assigning a basically when i'm assigning a food packet or a food to an order it's more like i'm assigning an actual packet with a specific id to an order so that exact packet will be delivered as part of that order and just to keep things simple so here the the the packet schema would something like this id food id so this is the this is a globally unique identifier for a packet this is the food id which means that this packet belongs to this food so that you can use it to list it onto a restaurant what not then again is reserved which means if this packet is reserved for some order and order id so to which order will this be is this packet associated to right so by splitting this we'll get a very nice sense of row level locking that we would want to take like playing at row level granulator packet level granularity is what we'll what we'll achieve with this thing again similar to delivery service the flow the architecture is pretty simple you'll have store service talking directly to a scaled up version of mysql to handle everything that you want four apis that we would be exposing two on each uh delivery service and store service delivery service first api slash delivery slash delivery slash agent slash reserve which would reserve a delivery agent slash delivery slash agent slash book which would assign the delivery agent to an order i should have worked up on norman clinton but you you basically get digest and second is store service who whose job is to like first ap endpoint is to slash store slash food slash reserve which would reserve a packet for a particular food in the store and slash store slash food slash book which means it would assign that packet to a particular order okay now high level architecture pretty simple your your order service is acting as your coordinator right the order service is the coordinator which means it's an end user pacing service that your end user when trying to place an order makes a call to this particular service order service and what order service will in turn talk to is order service will talk to store service and delivery service so store service has its own database delivery service as its own database so pretty simple and this is exactly what we'll be making locally right so the flow of the request or the flow of the communication between services goes like this so user makes a call to order service saying hey place this order with for this food and whatnot so order service will first reserve the food and says first reserve the food it would the the call will go to store service and it would reserve the first available packet for that particular food so if i say burger the first available packet will be reserved for this and as soon as it is reserved it will be made unavailable for any other order to be reserved right that's how we are protecting our resource we are ensuring an exclusivity of our resource second reserve agent which means reserve the first available agent which is there but the basically from the fleet it is of the first available delivery agent again similar to food we are reserving a delivery agent for some order so once it is there the food is there the agent is there we are done we are done with it the the people the the person and the food is reserved for some order we are not guaranteeing we talk pressing some order we are reserving that particular person this was the preparation phase now coming to the commit phase we'll call assigned food what assigned food will do is it would assign the first reserved food that it could find right for a particular food id it would find the first reserved packet rather first reserved packet and would assign it to an order and then assign agent assign the first reserved agent that we could find and once all of these four are successful we say order is placed right if any of this is unsuccessful as if i'm not able to reserve food because let's say packets are over if you're not able to reserve an agent let's say because everyone's they're out on the delivery we would return saying order is not placed so it's very important for your end user like it's not about how your system works it's more about what your end user experiences right for your end user what it would get it would get order not placed or food item not available or delivery agent not available something something basically depending on the use case depending on the product we can show a very fun a very uh fancy message out there right then assign food if assigned food is not there which means that now what why would this fail like let's say reservation in any case the flow is if any of this reservation fails we are returning order not placed and which means that in actual two-phase commit protocol i done a reservation but i am not booking it which means the items can be perpetually reserved but because of the timer the item would be made re-available after some time right but in our implementation we are not doing it we are not reviving an item to keep things simple but if we would do it the item would be made re-available for some other order to be to be reserving it right and then for assigned food and assign agent if i'm able to reserve food now the only job of my assigned food and assign agent would be what to just assign that food to an order id because it was already reserved no one else was contending for it the only job that remains for my commit face it's just assigning food and assigning agent so just a column change so when this is happen now this the chances of this succeeding is very high but in case it fails first of all why would it fail it would fail because because you have reserved no one else is contending for it so that's the best part right but why would it fail because service went down let's say your store service went down or your delivery service went down right when that happens that downtime will be very minuscule it will not be a gigantic downtime it will be very minuscule downtime which means you can have retries to try to book it but but if you would want to make it very strict that's what what i would propose for a 10 minute food delivery is to not uh this thing uh well when when we're getting a very strict uh uh distributed transaction so say if you are not able to assign food due to service bring down if you are not able to assign agent due to service bring down will not say that order is placed will stay order is not placed which means only when all of these four are okay then only will tell to the user that hey order is placed obviously actual implementation might vary because as business you would want to accept as many orders as you can and then figure out a deliver then then figure out the delivery agent to to deliver the food but hypothetically if you want to make a very strong guarantee when all of these four succeed then only i'll say order is placed so with our implementation some items might be as some items might be reserved might be perpetually reserved it's just a job of a cleanup job to to to basically revive them and with assigned food one more possibility is that that hey my assigned food happened but my agent service was down right so food was assigned to an order but my agent service was down what would happen in that case so when i say assign put which means the store was given a command to start heating up the food and preparing it for the agent to be basically preparing it for the delivery but my delivery service is done so the packet is reserved the packet is heating at the moment but there is no delivery agent to do it but here if you think your end user experience is not hampered at all because your end user for your end user experience the user saw what user saw order is not placed because you ran out of food or you or no no delivery agenda right your end user experience is not hampered you might have some business impact because you accepted a like you assigned a food to an order which is not ready which cannot be delivered because there is no delivery agent assigned to it ways to solve it is you may have retries you may have a background you you may have a background process that checks it repeatedly but that's a different pattern here what i'm guaranteeing is guaranteeing a seamless transactional experience for your end user so when both of them are there there only i'll work it otherwise i would not right and because we have reserved it there is no resource contention happening for them that's a very key point okay so now what are we focusing on we are focusing on that there is no inconsistent data like we are ensuring that no matter what happens we are not will not have an inconsistent data in our database right our end user experience is not broken at all right so here because we are not implementing timer or expiration or auto free up once food packet or agent is reserved they will remain perpetually blocked right but having an expiry solves this problem okay so how are we ensuring uh uh how are we ensuring atomic transactions to happen so first of all we are uh with the in the preparation phase what we are doing is we are seeing that finding and reserving food happens atomically finding and reserving an agent happens atomically finding packet or an agent or sorry assigning a packet an agent happens atomically so all of these four transactions all of these four updates that we are making across two different services they are all individually done atomically which means once a food packet is reserved it cannot be us it cannot be made reserved again right so once it is reserved it's reserved when we are locating a food packet we will always locate the first unreserved package so which means we have reserved the capacity for that and similarly for assigning the when we talk about assigning because it is reserved the only job we have to do is just assign it to an order so we are just we are just listening our scope of having failure and impact basically we are reducing our blast radius to be honest over here right okay so by ensuring atomicity we are ensuring that our current transit our concurrent transactions have no impact on it to place the order all four should succeed right otherwise you'll say order not place so end user experience is not getting happened if once you are very sure that you have food and you have delivery agent ready then only you are saying to the user that hey i'm there like i'm i'm basically be able to serve you or deliver the food to you in 10 minutes if any of this service fail we revoke the reservation so this is an extra step to ensure that hey if any of the call fail anything that i reserved i can explicitly free up as part of it but i'm not written it in the code but we can do that as part of obviously a lot of optimizations can be done over here but just to get that sense uh we are just implementing a very basic version of it then by adding a reservation state what did we achieve like you'll see hey if i have this part like my i if i have a separate uh prepared phase or if i have a separate reservation phase and i'm having a separate computer what exactly are we getting out of it because i could directly assign or i could directly assign a food i could directly assign a food to an order and um just wait for the delivery agent to be there or basically sign up food and deliberate to do that but here the idea is you would not be doing both at the same time so we are ensuring that we have the capacity to serve then only we are going forward and assigning it to it so we are reducing the scope of of inefficiency it's not and while doing that we are ensuring that our end user does not get a poor experience so we'll accept the order only when it is possible in our capacity to accept it and our exclusiveness to accept it right so by doing that we are just reducing the scope of our inefficiency the reservation is a process is a contention heavy process so let me solve that separately and then assigning is a very lightweight assignment so unless the service is down there will not be any impact so your assignment will always be successful because a very lightweight operation so you are reducing the scope of inefficiency in your system by giving a solid solid solid experience to your end user right so let's go through the code and see the actual implementation of it on how that thing works so i'll quickly go through uh i'll quickly walk you through my source code so here what i have is i've written a very basic implementation in golang so where i have three services so three repository three services but three's three will run on uh so uh on the store service and the delivery service will run on their own separate port so they're like totally separate processes out there so what do i have is i'll walk you through my code wait wait wait huh so here i have exposed two endpoints so this is my delivery service so i've exposed the first endpoint is slash delivery slash agent slash reserve which would reserve a delivery agent right then it invokes a function called reserve an agent which would reserve a particular agent in my db then reserve agent response it would return it and here i have another post request that says book an agent so as in assign an agent to uh to an order and that's what i'm doing over here book engine to an order right and this service runs on port 8082 right and here what do i have so when i am talking about the implementation part of it the reserve agent call that is there it starts at it starts a sql transaction it starts a sql transaction and then it first gets a row it first finds the first agent that is not reserved and not serving any order right which is not reserved and not serving any order is what it would find so first agent which is available it is finding it is taking an exclusive lock on it and once it has taken an exclusive lock on it it is updating that agent and setting is reserved to true which means marking that agent unavailable for any other order so this is what is preventing multiple transactions happening in parallel to not go and book that same agent so we are ensuring that we have enough capacity to serve it we are not over committing to our user and that is very important when you talk about transactions right you are not over committing something last right win should not come we are reserving we are making it atomic we are reserving it for so we are reserving it to ensure that no two can update it at the same time so ensuring the capacity before we commit it to our end user right so this is what our reservation looks like then coming to book agent book agent what it would do very similar start a transaction it would find the first that is reserved but not serving any order so reserved is true and is order and order id is null and then what we do is we update the agent set because now with respect to booking what we are doing is marking is reserved false as in now the agent is not reserved but it is serving an order so we are updating an agent to be is reserved as false which means now he or she is available he or she is not reserved to be honest but is serving a particular order so this order id when we are sitting it is still making him or her unavailable for any other order and done this is what we do will deliver service these two api similarly when we talk about the when we talk about the store service it would have two very similar function food reserve and food book same function and here with respect to the api implementation again pretty similar so here uh the same thing uh reserve food goes like this where i am going through my table finding the first unreserved food and for a particular food id as then i told you right that that food stable uh id one burger that that one thing uh food id something and authorize on order id is null which means that first packet select star from packets where is reserved is false which means any packet that is unreserved and food id is equal to something which belongs to a particular food id and is not part of any order so we are finding the first unreserved packet and then reserving it as part of that one transaction right similar to how we reserve this part and then we are committing the transaction in any case of failure we are roll backing it right then book food so similar to how we add book agent we are doing a book food over here where it says select start for packets where is reserved is to use so finding the first packet that is reserved belonging to a particular food and which is not assigned to any order and then we are updating it over here is reserved is false and order right is equal to something so if this being done in one transaction ensures that no two concurrent database transaction will have any impact on those row by also by taking an exclusive lock on them right okay so these were the two services now i'll run the store service over here and the delivery service over here right i'm just running the store service and the delivery service over here now what next now we need to have an order service so here order service i'm not making it an http based service but a very simple way on which i'm just concurrently assuming that i am the order service so i'll be concurrently placing orders for a particular food item so let's say i'm placing 10 concurrent orders for a particular food item and this means that at the end of my transaction there should be 10 delivery agent assigned to 10 uh and 10 and 10 foot packets assigned to one assigned to 10 orders right so here i am spinning up go routines basically i'm uh basically what i'm doing actually so so basically what i'm doing is i'm ensuring uh i'm ensuring that so i'm i'm basically firing 10 transactions in parallel trend order placing in parallel and when i'm doing that the place order what it would say so the place order accepts a food id so i'm placing an order for a particular food id i'm getting an order or an error if there is an error it says that order not place so this is what your end user would see so if there is any error order not place is what it would show to the user otherwise i'll say that order is placed with a particular id and now what place order would do is place order would make four api calls as we just discussed so place order is making literal http calls to what to first the food service to to store service to reserve the food if there is any error which means if the uh response code is not 200 i am directly saying would not available as soon as food not available it would return an error so here i am not proceeding forward i'm returning an error saying that food is not available for me to do in well for me to place an order so it would cascade here and say because error is here i'll get an error and error is not nil it would say order not placed so our end user experience is not broken it would say that if i'm able to reserve the food or if i'm able to reserve an agent so this is my preparation phase right then i'm doing a assign a food to an order and a sign of and assign an agent to an order right so by running this for actual http command i'm actually making a a very small distribute system locally to just check on what happens and whatnot so now let me play so how many before that how many so how many uh what's our db schema looks like so here i have agents agent not assigned to any order and then i have packets so i have 15 packets and i have 10 delivery agents here when i have 15 packets each packet belongs to the same food id1 which is what i've pre-populated the data with and input i have one and burger so that's just a foreign key reference that i would want to have right so now if i run this code go run orders main dot go what we would see that hey some orders are pasted 1 2 3 4 5 6 7 8 9 10 because we ran 10 orders in parallel here because we ran 10 in parallel the 10 orders were placed and if we go through the database we would see that orders are placed over here all 10 delivery agents are placed over here and all the foot packets you would see like there were 15 packets uh out of which 10 got placed after which 10 got assigned to a particular order right so now if i run this code again what would happen because my delivery agent because my delivery agent is already assigned to a particular order it should give end user order not placed right so let's see that in action uh i'll go through my id once again if i now run it again it would give me order not placed for all of them because deliveries are not available not available not available not available right and now once it cross delivery gender then it says food not available for not available deliveries or not because i'm running it in parallel what's happening is it is it is contending for food and this because these are 10 go routines hitting in parallel so what would this mean this would mean that hey food not available uh delivery not available the idea is whichever go routine got scheduled first at the end it should be five day leverage and not available and for rest others because there were 15 food items and 10 delivery agent for next 10 orders you might see deliberation not available or food not available once 15 are exhausted and it would set food not available so which is what we are exactly seeing deliveries are not available five times and then food not available five times right because delivery are not available because then if i fire it once again you would see food not available because it was able to first it was able to reserve the food because there were 15 food but not but delivery agent was not there so what you would see in the database is you would see that after this my delivery agent assignment does not change because there were 10 delivery agent there were 10 delivery agent but if i see through my packet you would see all of these five are now reserved right which means that they are now exclusively there for in like they are exclusively reserved no other transaction like any new order coming in to get it they would not get any of this packet so that's why you are seeing food not available error right because food is actually not available because it is reserved now if you see we have here the way to not perpetually reserved like obviously that would be a cleanup job or that would be a job that would be expiring these particular is results so let's after five minutes all of this fire become become available again some other order would come in and then it would get that same thing and if your delivery service is running and your order service is running it would attack uh it would assign that packet and that agent to that order right so so long as a delivery service and your this things are and your store service are working fine the only thing that would remain is like this assignment part but by ensuring that we have this reservation phase we are definitely guaranteeing definitely guarantee that if there is a transient error in your delivery service or if there is a transient error in your store service it is not having major impact on your system right it's all about getting that service up again and retrying so somehow having a cleanup job it will start accepting new orders so new orders are not impacted existing orders for which some assignment happened but some did not you can have a very small cleanup job but in the entire scene your end user experience is not getting hampered which is what the beauty of distributed transaction is because at the end you would say either all or none is what you wanted to achieve you wanted to achieve atomicity right you wanted to achieve autonomous city and this is how you attain atomicity over here right it's a pretty simple simulation and obviously this particular solution that we just discussed can very well be extended to so many other complex features that you can add for example a simple thread might just do a cleanup and you can simulate the entire 10 minute delivery of zometo locally so yeah that is it for this one i hope although a long video but i hope you see how easy it is to stimulate a lot of things locally never be shy of implementing it just get your hands dirty into distribute transactions normal transaction sql and whatnot there is so much more to explore that right so i hope this video this long long long video uh helps you in understanding distributed transactions better obviously there are better ways to solve this problem i'm not denying that but this is my way of demonstrating how you can first of all implement disciple transaction second of all simulate a disabled transition locally and third understand why those two separations are there how we are protecting uh the common resource against contention uh by adding exclusivity ensuring atomicity across all level across the transaction so that end user experience is not getting so i i've tried to cover a lot of those things in this one i hope uh i hope i added enough value it was fun for me to write it to be really honest like but uh i hope you go and try i'm not making this code base open primarily because i would want you folks to you know write it and see the magic it's pretty simple code base as you saw like not not many files not many lines of code but when you do it you'll hit upon so many new things and you'll learn more about databases more about disabled transactions by getting your hands dirty rather than just watching me talk about it right i have just covered the foundational part but getting our hands dirty is the real way of learning that's what i would highly recommend you to do that's why deliberately i'm not making this repository open source so that you write it on your own and experience the joy that i failed the first time i discovered transaction work right so yeah that is it for this one if you guys like this video give this if you guys like this video give this video a thumbs up if you guys like the channel give this channel a sub and i'll see you in the next one thanks satan