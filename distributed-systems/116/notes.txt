Implementing Distributed Transactions

Implementing Distributed Transactions Tomato 's 10 min Food Delivery - Distributed Transaction : A transaction that span over multiple physical systems , machines or computers . Scenario tomato : 10min food delivery by ☐☐ ☐ 20 Mato > ☐ ☐☐ ☐ ☐ ☐☐ s ¥ ¥ ¥ ¥ ¥ ¥ ☐ ☐ ☐☐ Keeps food ready Delivery workers Restaurants in their store are on standby To guarantee that the food is delivered under 10 mins tomato should accept 1 . Food is available in the store order only when 2 . Delivery partner is available to deliver " " One order A user should not see Order placed - one agent if it cannot be fulfilled One food item - order Inn [ Both were successful] agents order 2 Mr

Orders Two Phase Commit : store Delivery { "" " " " " "" split the entire flow in 2 phases Reserve agent > "M " 1. Prepare - Reserve g. commit assign assign - food , Note: Assign Agent To keep things simple > we are not implementing timer 2 place order Schema service : Delivery agents is reserved - -_ True id is reserved - order - id ! is reserved agent False 1 NULL for some order T T is reserved currently serving order 1- Delivery Svc ✓ MySQL

Schema : Store service ? Individual food items in the store Food pay,ey id id id name food - is reserved - order id - 1 Burger 100 1 False HULL I El store - service My sole API Endpoints : Delivery service / delivery / agent / reserve → reserve a delivery agent / delivery / agent / book → assign delivery agent to an order API Endpoints : Store service / store / food / reserve → reserve a packet / store / food / book → assign a packet to an order

High level architecture store place order 0 - orders ¥ Delivery MySQL Orders Store Delivery t " "" " "" " " " "" "" """ "" " " "" " " "" " "" reserve - agent available agent assign the first assign - food reserved food we find > assign the first assign - agent reserved agent we find , Order - placed <

Ensuring no inconsistent data To focus on data consistency a auto ( timer ) Note : Because we are not implement - free up . once a food packet one an agent is reserved , they remain blocked forever . But as we get expiry , the problem solves itself . } Four - Finding 2 reserving food happens atomically core updates are individually atomic Finding 2 reserving an agent happens atomically - . - As sing packet or an agent happens atomically concurrent transactions has zero impact . - To place the order , all 4 should succeed fails revoke the reservation - If any service , orders service will reservation have the By adding stage → we ensure we - necessary capacity