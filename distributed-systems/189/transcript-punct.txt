so nodes in a distributed system needs to exchange a lot of messages. a naive way to do this is to flood the network with the messages across all the connection lines, but this is highly inefficient and would unnecessarily congest the network. hence we need a distributed network to maintain a minimum spanning tree so that we can do a broadcast of this message to all the nodes in the most efficient way possible. hence, in this video, we take a look into the famous ghs algorithm to construct a minimum spanning tree in a distributed setup. we'll go through the algorithm step by step and see how spanning tree makes leader election a piece of cake. but before we move forward, i'd like to talk to you about a course on system design that i have been running for over a year now. the course is a cohort based course, which means i won't be rambling a solution and it will not be a monologue. instead, a small, focused group of 50- 60 engineers every cohort will be brainstorming systems and designing it together. this way, we build a solid system and learn from each other's experiences. the course to date is enrolled by 600 plus engineers spanning nine cohorts and 10 countries- engineers from companies like google, microsoft, github, slack, facebook, tesla, yelp, flipkart, dream 11 and many, many, many more have taken this course and have some wonderful things to say. the coolest part about the course is the depth we go into and the breadth we cover. we cover topics registering from real time text communication for slack to designing our own toy load balancer, to quick buzz, live text commentary, to doing impressions counting at scale for any advertisement business. in all we would cover roughly 28 questions and the detailed curriculum- uh split week by week- can be found on the course page, which is linked in the description down below. so if you're looking to learn system design from the first principles, you will love this course. i have two offerings for you. the first one is the live cohort discourse which you see on the left side, and the second one is the recorded course, which you can see on the right side. the live cover based course happens every two months and it will go on for eight weeks, while the recorded course contains the recordings from one of the past cohorts, as is. if you are in a hurry and want to binge learn system design, i would highly recommend you going for the recorded one. otherwise, the live code is where you can participate and discuss things live with me and the entire cohort and amplify your learnings. the decision is totally up to you. the course details, prerequisites, testimonials can be found on the course page at binary dot me slash master class, and i would highly recommend you to check that out. i put the link of the course in the description down below. so if you're interested to learn system design, go for it. check out the link in the description down below and i hope to see you in my next cohort. thanks, so say node wants to broadcast a message in a network, but this has to be extremely efficient. given that broadcasting a message across the network is one of the most common operation that a network always needs to perform, we have to be extremely efficient about it. to do this efficiently, we use something called as a minimum spanning tree, right? so first of all, what is a spanning tree? spanning tree of a particular network is a tree in which all the nodes of the network are covered, but only a subset of edges are covered, and that is a sweating tree. so we are. we are ensuring that we are covering all the nodes, but it is possible that we have that we are not covering some of the edges. now, a minimum spanning tree is a spanning tree such that the total cost of edges included in the tree is minimum. this is a classic graph algorithm. classic graph algorithm. but what does this mean for a distributed system? right, because why? why are we even learning that? so when in let's say, let's take an example- in a distributed network, if the nodes are connected via communication line having different tariff- so, for example, a communication line is from one of the provider, other communication lines from other provider. now if you want to send a message to all the nodes of a network, now what would happen? because the tariffs are different across different communication line, when you are broadcasting a message, you have to minimize the cost, the cost of moving a packet right or a cost of doing a broadcast. you have to do it in the most efficient way. this is where distributed networks comes in. this is where having a good knowledge of minimum spanning tree for the network comes in, because you can do that in the most efficient way possible, because you are minimizing the edges of it, and this is what makes this particular algorithm classic. now, i talked about tariff as an example. take it by congestion level: in in my network with the same connection, and what if one link is having very high load while other links are sitting idle again, minimum spanning tree is really important, right, because you are optimizing on time, you are optimizing on congestion, you are optimizing on cost- pick up, pick your favorite factor- and you would need a minimum spanning tree to solve this particular problem. right, and this is the core need of having a mst to be done in a distributed setup. so, distribute setup, right, given that we are working in a distributed setup, we, there would not be any node that has the entire topological information. so, hence, what we can at max assume is we can assume that every node knows the weight of all of its incident edges and the total number of nodes in the network. that's all we can assume, because we don't know how topologies every node is sitting independent, all it knows. hey, i am connected to these node, we are this edge, and the weight of the edge is this, and the total number of nodes in our network is n. that's it and that's all we have to work with. so if i were to, if i were to formulate the problem statement, it would be: find the minimum weight spanning tree for the entire network, such that each node slash machine decides which of its incident edges are part and not part of the spanning tree, right? so see, spanning tree, because it's a distributed setup, there would not be any node who would have the information about the spanning tree itself, because there is no topological information. every node would just know out of, let's say, if a node has four incident edges at the after this algorithm is completed, it should know out of these four edges, which edges are covered and which edges are not in the spanning tree, because there would not be anyone who don't have the entire information. this is the best part and the worst part about distributed system and this is what makes it really fun to understand them, right? okay, so what is the core strategy? the core strategy to construct a spanning tree in a distributed setup is we start small, with a forest of spanning trees and we repetitively merge them to create a single spanning tree, kind of like divide and conquer, right? so you would start with a large number of spanning trees, individuals penetrate and merge them, merge them, merge them to have a final complete, uh, to have a final spanning tree that covers the entire network, right? this is the idea. keeping this in mind, we'll go step by step to understand what's happening and how it's happening, right? okay, so we'll talk about this gss ghs algorithm. so the algorithm operates at level. now, each node, or each spanning tree, or each side, each subspanning tree or slash component- i'll use the term interchangeably, subspanning tree, spanning tree component- there they all mean the same right. each of the spanning tree operates at a particular level. the level starts like the bare minimum level. it would start, and then it would merge, merge, merge and so on and so forth. right? so what would have is, let's say, uh, at a particular state of my network, i have two components, each one having some nodes con, which are creating a spanning tree, a subspanning tree, within that. so every node or every component would have a leader and the component is identified by that leader. this is not the leader election or master slave. this is not like that. it's just a leader who is representing this entire component or a subspanning tree, right? so if i have two such component, they could merge and their leader would merge. right? that's a very rough idea. we'll go into the exact steps on how that's happening right now. again, gss ghs algorithm is a synchronous algorithm. so they, every node, proceeds synchronously to the next round, and which is what? a very, uh, big but a decent enough assumption that we are making. so now, what we'll do is we'll start with levels so that it becomes extremely clear. so we'll start with level zero. level zero, basically, where initially- this is your day zero, this is your initial setup- every single node is a spanning tree in itself. it is indeed a spanning tree in itself, right, because all the nodes are covered, no edges, and a subset of edges are got. there are no edges, so it's covered. so level 0 consists of all the nodes and no edges. each node is a spanning tree in itself, and for n nodes, we have a spanning forest of n spanning trees, right? so if i have n nodes in my network at level 0, where there are no edges covered yet, this is the spanning forest of n spanning trees. right, and now, what would be? and now, just to reiterate what every node knows at this stage: at this stage, every single node knows the total number of nodes in my network. the incident adjust to it. it has that information, but none of these edges, none of these edges are part of minimum spanning tree. yet, because there is no need. there are n spanning trees, each having a single node. so no edges are covered yet. and every single node knows the uid of its leader component or, sorry, of its leader node in its component. but here, because the component or the subspanning tree only consists of one node, everyone, every node it, knows its own uid. it knows that it is the leader of this component, right? so this is what we reach till this stage. now we go to the next level. now what happens once we are at that level, once we are at that level? now the next step is that each node within the component sends a search message. now what do we need to do? the idea is to merge the two components. right, to merge the two components, we need to know how they can be merged. so there has to be an edge connecting them, which means we first need to identify the edges that connect a node, or, sorry, that connect a component to some other component. so this is what we are doing, this is what we are identifying: that hey, from a particular component, which are the edges that go out to other component? now, because this is a distributed setup, no node in my component knows which are the edges that are outgoing edges. this is what we have to identify so that we can merge it. now these are the constraints that we are playing with in a distributed setup and that is extremely interesting. right? so nodes don't know. none of the nodes in my component know which are the edges that go out of that component. so that is the first step that we would do. so each node within the component sends a search message within the component to get m w o e. m w o e stands for minimum weight outgoing h. it's a big word. that's why m w o e. right, so the search message is broadcasted using what bfs? we saw it in a couple of videos back. right, so search message within the component is sent using bfs, like broadcast bfs. right now. it is just sent within that component. to do what when a node receives? when a node receives the search message, what would happen is it would be searching for an outgoing edge that is going out of the component. it's the responsibility of the node, because only the node knows the edges that are going out of itself. it is still not sure if it is connecting some other component or not. right? all it knows that i received the search message. now what i have to do is, i have to find all the edges that are going out of me and see which one is the minimum of that, right? so searches for an outgoing edge that is going out of the component. we'll talk about it how it does it, and out of all such edges it selects the one with the minimum weight. now, a node only knows its outgoing edge, but it. but how would it know if the edge that is going out is actually connecting some other component? it would not know, right? so in order for it to know, there is only one way: what every comp. we spoke about this assumption that every node in the system knows the component it is part of by the leader of that component. right, that's all it knows. so what every node would do is every node, upon receiving the search message, it sends a test message to its neighbors and the neighbors respond with the leader uid of its component. so every node knows the component that it is part of and the leader uid of that component, right? so if i receive the message, what i would do is i would send it to all of my neighbors saying, hey, i am this node, i have this leader, what do you have? it would say that, hey, i am this node, because it would know, like, this is the node and i am part of a component having this as a leader. now, if the leader leader matches, the both of these nodes are part of the same component. if leader uid varies, then they are part of the different component and that's how it would know that this particular edge that took me toward this particular node is connecting me to a different component. and this is how a node would know that one of my edge, or this exact edge, is connecting r component to another component, hence it is an out and and hence it is an outgoing edge to a different component. so for all of such edges, it would need to know the minimum of it, right? so now, what we do is by that. this is how we have to do, like. look at the baby steps that we took throughout. it's not very straightforward. you have to be extremely cautious when you are designing a distributed system. right? exact, small, extremely small baby step we took just to ensure the correctness of our system. right now, that every node knows, if applicable, one, one outgoing edge that connects itself to the com, to another component. right, so it would know that these are the peripheral nodes of my component, because this is what we have to find. and out of all the edges from the peripheral nodes, which one are connecting or which one has a minimum weight, is what every node keeps it ready. now, once these nodes know that, hey, this is the outgoing edge that is connecting r component to other component, what it would do is it would, it would uh, of all of these minimum edges, it would send this information back to the leader, that every peripheral load, it would send a message back to the leader using what converge cost, right? it would send the message back to the leader saying, hey, leader, of our component, these are the. this is the minimum outgoing edge from me as a node. now, leader would do a global minima of that. out of all such peripheral nodes, who has sent me one edge each? which one has the minimum weight, right? so this is how your leader would evaluate which one is the minimum weight. it would compute the global minima and that's how it would know that, hey, i need to connect to, like, i need our component to merge with that other component, right? and this is the idea behind this algorithm. now, now the leader knows that this component, that the component is part of has to merge with that other component. but it still does not know who the leader of that other component is. all it knows that the minimum weight it got was from this particular node of its own component. that's all it knows. that's all it knows. now it has to move to the next step. now the components combine over this mwoe minimum weight outgoing h right, the edge that was chosen by the leader. this is the minimum. the two components merge on that right. so we have leader of the node and the two nodes. they are connected by this minimum weight outgoing edge and these two components would merge on that. now how it happens? so leader of the component talks to the nodes connected via mwoe, the minimum weight outgoing edge, because the leader itself chose that edge. the leader knows about that edge. leader knows which node it came in from and that node knows the other node. so now what the leader would do? the leader would tell the nodes, both the nodes, to mark the edge that it belongs to this component. now, because now what would happen is because we have two component: if that edge that is connecting this two component, if it is marked to be part of this one to be part of this one component, then it's basically like merging the two components. so the leader would send a message to both the nodes connected via this mwoe to tell you, hey, change your edge. to tell that we are part of this one component. both of the nodes agree and they change it. and as soon as they change it, now this forms a singular component, but now that other component would have its leader. this component also has its leader. now how would the leaders be merged? who would be the leader of this merged component? so the way it would happen is the new leader of the merged component will be out of the two nodes, that whose who are connected by mwoe. the node having the larger uid becomes the leader of this merged component. right, you don't have to fight between the leaders. a new leader is elected as part of this merge process. when the two nodes who are connected by this minimum weight outgoing edge they merge, or like they are changing the edge, both of them knows each other, the both of them knows each other's uid and they would know: hey, my ui dislodger, i'll be the leader. done. and this is how a new leader is elected for this merged component and this information is broadcasted across the component to say, hey, now these two components are merged and i am the new leader of this and this is how merge happens. now we know how we are going. level uh, how merge happens and how new leader is elected. elected is in what is chosen, basically, and components are merged. right now we still need, like, how is level by level coming? like now you can very clearly see that because it's a distributed setup, there is no one component who is trying to forge his way across the network. like every node is independent and triggering this merge is is is independent of asking other component to merge in itself. but that's not how it should be right, because it would be a huge chaos. so we need to bring in order, which is where the concept of levels coming. so now what happens is the merge always happens or the algorithm proceeds level by level. when i say algorithm proceeds level by level, we start with level 0, where every node is individual. every node is an individual spanning trend itself. then the, when two level zero component merges, they become a level one component, right? so it would always happen that a level zero and a level one component would merge to form, sorry, a two level zero component would merge to form a level one component. right, and in case if a level one and a level zero merges, because it is possible that your node does not have a two, uh, uh, the number of nodes in the network may not be in the power of two, right? so it is very well possible that a level one component wants to merge with the level zero component. so when that happens, the, the resultant, the, the resultant level of the merged component is equal to the highest of the two. so level zero plus level one is equal to level one. but level zero plus level zero is equal to level one. so it goes at a, it goes at a higher level, right, and this is how the merging process happens. this brings in the necessary order in the merging process, because now, when you are merging, you are not just doing random merges, conflict, because you have to avoid conflicts. you have to ensure that you are not just, uh, you are not just allowing any subset of the network to go out and elect and move forward. it has to be a very rigid order in which it is happening. and this is how it ensures that there are no cycles, uh, there are no conflicts, there are no different algorithms triggering at the same time, and would ensure everything happens peacefully. and in case this is a little unclear, work it out with an example. you just imagine every single component is parallely operating, is is independently operating, and you will see how it can just change the course of it and how you can have a lot of conflicts in the network and how leveling solves that problem. right, you have to work it out with an example or just write a very small prototype of that. you'll very easily understand how, how critical this problem of handling this particular part is, right. okay, now the most important part of distributed algorithm termination. how would your algorithm know that the minimum spanning tree is constructed? this is where the level concept also comes in very well, that after this levels merge, eventually, what would happen? the entire spanning forest, because the trees are getting merged, the entire spanning forest will have just one tree. but how would it know that it only has one tree right? so in this case, the final case, you have one component. that component would have a leader right because whenever the merge happens one of the two nodes connected by mwoe, they form a new leader right. so the leader when it triggers another round to get: hey, who all are my outgoing edges? i want to merge with other components. when it does that, it would not find any because the nodes, when the message is received, when the nodes send it to their neighbors, it would not receive anything back, like it would receive the messages which would have the same leader uid. so every node would send null responses to the leader saying that, hey, there are no, like i do not have any edge that connects our component to other component. because it would happen like that. your leader would know: key array, there is no edge that i can go to, there is nothing. i have conquered the entire world. now i am good. and that's when the leader would know that algorithm is done. we have a spanning tree and now we can stop right. and this is- and if you think about it, this is how humans work this, how our medieval period was to and to increase the boundary. the king used to do exact same thing. the king used to order the, the villages sitting at the peripheral, to go and acquire other villages. that's all. that's how it happened to get that information. and then you merged it's, it's very like. that's how i say you distribute systems. entire domain of computer science is very similar to how humans have operated and distributed system is a classic, is a classic case where we go, we take those baby steps to ensure the correctness of the system. very much inspired by history, right, okay, now let's do the complexity analysis of this particular problem. so, because it's extremely important, right, because this weird system, uh, a network communication, extremely costly. so if you talk, think about complexity, analysis of that, we know that each level, because we are merging and merging and merging and merging at each level, what you would have is you would have at least two raised to k nodes, something, some power of two nodes, because you are merging one, one and one merging two. then these component, then each component having two, two nodes will combine to four. so it would have at least two raise to k, because there is chance that a level zero component merges with a level one component. so it would have three nodes, but at least two raised to k nodes would be there. so the at most the number of levels that would be, it would be log n, right. so the total number at max, the total number of levels in constructing the final spanning tree would be login right. so because each level takes order end time, because they're sending message to the nodes, receiving it back, its order n. if each level takes order n time, the overall time complexity of the system is order n- log n, where n is the total number of nodes in the network. and when we talk about communication complexity, what is happening is each, at each level, order of n messages are sent and order of e messages are received to decide m w o e, because leader, like every node, sends a message. outgoing nodes respond with this and the number of messages received is equal to the number of edges in the system. worst case, worst case. so it would be order of n plus e log n right, because the total number of messages would be the number of levels at each level: order n messages and plus order e to get the minimum outgoing edge. and this is the communication complexity of the system. there are ways to reduce the combination complexity a little out of scope. the video would be too long, might get a little boring, but this is the idea behind it, right? so this is the communication complexity and the time complexity of this approach. now let's see how our life becomes super simple when we already have a minimum spanning tree constructed and if you want to do leader election, because this shows that how one algorithm empowers hundreds of different use cases. now let's see, assume that we have a minimum spanning tree constructed in a distributed network using the gss- ghs algorithm we just discussed. right now, leader election becomes pretty simple. now this is a leader election. not that component, leader. that algorithm is terminated. now we are doing a leader election between them, right out of this node. we have to, we have to basically elect a new leader. so what would we do? assume that we have uids of some unique identification. a comparable uids is allocated to each node. it would be in any case right. so in this spanning tree, a node with no outgoing edge is a leaf node, a classic definition of leaf node. right so in this minimum tree, if every node would know if it is an internal node or a leaf node, even if it is a distributed setup, it would know that because during mst construction we decided that right. so now what would happen? its leaves would initiate a converge cast. this is why converge is a very important algorithm. so leaves would send the leader election converge cast message up the level. now, when this message is: when this message comes to an internal node, what would internal node do? internal node, let's say, is connected to six different nodes, so out of six it received message from one, correct? so remaining nodes are five out of those five. it would wait for it to receive messages from four and then the one node or one node that remains it to send any message. it would send a message to that node. so that would. it would combine the result and basically send it over that node. this is how it would converge, right. so it receives message from one, it waits for messages to receive from others. so basically, in a gist, every node waits for it to receive messages from its n minus one descendants in the spanning tree, again in the spanning tree, not general network. right in the spanning tree, it would wait for the messages to come in from n minus one of its descendant and once it received them it would send. it would combine the message and send it over the one edge which is remaining, over that one which it would be its parent typically like. but there is no parent- child relationship. that's why it has to be this bi-directional thing and you can very clearly see how it would determine. i received message from this and i have to send it over here and now. given this as a process, let's talk about termination again, termination, very important for distributed algorithms. so if a node, if a node, returns from all of its neighbors without itself sending any message- right, because that is the case where the root of the spanning tree received the message- so what would happen is if a node received all the message from all of its children without it even having to send a message, because converge class is initiated by whom, the leave node. so the root node might not even like root node, would not even be sending the message, right? so if this happens, then you'd know that this node becomes the leader, because this is the only node which is left to send any message and it is converged to this one root node and that becomes the leader. but there is another case. what if we have a star like thing where you have leaf across? because you would have leaf across the system and the leaf node triggers the converge cast, so it can come in from a lot of direction? and what could happen? they are all converging to this one center of this network, right? if that happens now, what? what would be a possible case. when it's happening this way, there would be two cases: either that node receives messages from all of its neighbors without sending anything, that becomes a leader. but there is another edge case where what if they all converge, such that there are two nodes, two neighboring nodes. they receive messages from each other. if two neighboring nodes receive message from each other, this means that one of them needs to be elected as a leader, because everything else is covered. two nodes receiving messages from each other is a classic case where it's an like, not really an even number- of nodes, but you can build an analogy on that level- but it's that that they are converging to this one place and now you are left with two nodes. they both send messages to each other because leader is still not elected. and this is where, when this happens, the node with the higher uid- because both of them would know, know the the uid of each other- the node with the higher uid uh- declares itself as the new leader. and this is how, and this is how you can power a leader election algorithm in a network who has all that has already constructed a minimum spanning tree. and this is the beauty of this algorithm, this is the beauty of how minimum spanning tree can power a use case like leader election and how simple leader election becomes in a distributed- and there are hundreds of ways to do that. we saw already four or five relation algorithms. this is another implementation of it, just that it has an assumption of having mst already constructed right- and this is the heart and the soul of distributed system- on how simple yet effective these algorithms are, but extremely brittle because a lot of failure scenarios are there. right, and that's it. that's it from me for this video. i hope you learned something really fun and interesting about disabilities, especially about minimum spanning trees and how we approached it right and the baby steps we took to ensure the correctness of the system. and that's it from me, the pro. that's it from me for this video. if you guys like this video, give this video a thumbs up. if you guys like the channel, give this channel a sub. i post three in-depth engineering videos every week. i'll see in the next one. thanks. [Music]. [Music].