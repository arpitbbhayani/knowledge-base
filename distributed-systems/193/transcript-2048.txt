so byzantine agreement is an important problem to address in a distributed network.
it is all about being tolerant of the nodes that are malicious in nature, which means that they are corrupt and are trying to ruin the sanity, integrity and correctness of the network.
right in this video, we talk about an algorithm that gathers an exponential amount of information to build a robust understanding of different values proposed by different nodes.
once we have this information, we reach a consensus such that, even if there are a few nodes who are malicious in nature, who sent random values to us, we would still be reaching the correct consensus.
but before we move forward, i'd like to talk to you about a course on system design that i have been running for over a year now.
instead, a small, focused group of 50- 60 engineers every cohort will be brainstorming systems and designing it together.
the course to date is enrolled by 600 plus engineers spanning nine cohorts and 10 countries.
engineers from companies like google, microsoft, github, slack, facebook, tesla, yelp, flipkart, dream 11 and many, many, many more have taken this course and have some wonderful things to say.
the coolest part about the course is the depth we go into and the breadth we cover.
we cover topics ranging from real-time text communication for slack to designing our own toy load balancer, to greek business live text commentary to doing impressions counting at scale for any advertisement business.
in all we would cover roughly 28 questions and the detailed curriculum, split week by week, can be found on the course page, which is linked in the description down below.
so if you're looking to learn system design from the first principles, you will love this course.
the first one is the live cohort discourse, which you see on the left side, and the second one is the recorded course, which you can see on the right side.
the live codebase course happens every two months and it will go on for eight weeks, while the recorded course contains the recordings from one of the past cohorts, as is.
if you are in a hurry and want to binge learn system design, i would highly recommend you going for the recorded one.
otherwise, the live code is where you can participate and discuss things live with me and the entire cohort and amplify your learnings.
the course details, prerequisites, testimonials can be found on the course page at pitt binary dot me slash master class, and i would highly recommend you to check that out.
i put the link of the course in the description down below.
check out the link in the description down below and i hope to see you in my next cohort.
thanks, so, reaching consensus is extremely important in a distributed network.
say, we have a database cluster in which one node thinks the value of price is one thousand dollars.
right, this is where the nodes needs to talk to, needs to talk to each other and come to a consensus key: what the value of price is, either 1000 or 2000.
this is the problem of distributed consensus right now.
we assumed up until now we always assume- that the nodes are genuinely, they are all genuine nodes, which means that the value that they are claiming they may be lagging in time, they may be slow, they may have crash, they may have some corruption, something right, but they are all genuine in nature.
what byzantine's agreement says is that, let's say, a node is malicious in nature, which means that node is deliberately trying to ruin the correctness of the system.
so, no matter what the nodes is deliberately trying to say- you know, the value is 5000, random number, right.
and if node is trying to do that, how can we reach a consensus, even in the presence of such nodes in the distributed network?
this is where we talk about an algorithm called exponential information gathering algorithm- eig algorithm, to solve this part.
the idea is to gather exponential amount of information so that we can reach the correct consensus, or we can reach the proper consensus that we should.
eig data structure is a tree that grows exponentially.
right, this tree is constructed level by level.
the construction procedure- i've talked about it in the previous video.
right, but here i'll just cover a pretty much gist of it.
so, because this trees cover is basically constructed level by level, at each level we would have all possible permutations of length, k.
so at level k, we would have all possible permutations of length k of all the nodes in the system.
so, for example, if i have nodes a, b and c in the network, then and if i am constructing a three level deep eig tree, so at the leaf of eig tree, what i would have is i would have all possible permutations of a, b and c.
now the idea of this construction is pretty simple: that my root node is labeled as an empty string, then i have the children of.
it is a, b and c, then ace children, like root node, had three children, then a- this worst level children- would have two children, then then only one child, right.
this way we would be covering the entire permutation range of length k at the after a div at the level k in my eig tree right.
this is the exponential information that will be gathering across the network.
right, okay, now the algorithm.
now here, the algorithm that we'll be talking about is how we would be achieving, we would be solving the byzantines agreement problem.
every node in the distributed network is sending information to every other node, such that every node, eventually, will have the exact same eig tree.
right now, the algorithm we will be discussing will be tolerant to f faulty processes, which means that, at max, f processes can be- uh, air processes can be malicious or they are trying to deliberately ruin the sanity of the system.
right, so we are will be making tolerant to f processors.
right, okay, so now, when a process sends informed information- maybe some junk, maybe some garbage value- to other nodes participating in the consensus, the consensus should not be prone to that.
the process propagates the value for f plus one routes and each processor node builds its own eig tree, right?
so every node is constructing its own eig tree independently for f plus one levels and the value it receives will be put into that corresponding path.
it's like a try: it would be put into that corresponding path and then eventually the judgment would be made again.
construction is covered in the previous video.
the idea is pretty simple: sending the value to the nodes of the path at n minus 1, at k minus 1 level, such that you are not in that path.
it basically covers the permutation, right?
right, because at every round every node will send its information to every other node of the previous lab, right?
so if a node receives a garbage value, the node ignores it.
for example, i say that the value should be an integer, but if i receive a string, say a, i would be discarding it and putting it as a null in the tree, right?
if a value should be in range, let's say 0 to 100, and i received 5 000..
so this is a very basic sanity check that you are making, that if a node is because a malicious node might not know the correct value or the or the possible value of that particular variable or by that particular key, it might send some garbage.
so, just as a very basic sanity check, if a random value is received, you throw it up right once the entire eig is constructed.
so, while the eig tree is being constructed, every node sends value to every other node.
when that happens, eventually you would have this entire tree filled with values that you received across multiple communication path.
now, because you know that there will be few faulty processes who are malicious in nature.
so how will you make this decision: to be fault tolerant or to be not followed to be tolerant to malicious users?
your decision process would happen ground up right, which means that all the leaf node would send its value to the node above.
the node above will pick the majority of the value that it saw in the children right.
so, for example, if the node a- sorry, if the node a, b- has one child abc.
so abc will send its value to a b, right.
that would become automatically, become the majority, and a b would accept that particular value.
what it would do is every node would see the value that it got at its base, oh, sorry, at its children, immediate children.
now for the non-leaf node, the value is equal to the majority of values of its children.
so if there is a clear-cut majority, then your final value of that particular level is equal to the majority that has just been formed.
right in case you cannot form agility, let's say you have two child, or sorry, two children- and you receive two different values of that, let's say one thousand and two thousand.
so that's when you would resort to a default value that you were not able to make that decision and that default value would be propagated up right.
you could very clearly see that if one of, if there are few nodes that are corrupt in my, if there are few nodes that are corrupt, what would happen is only some paths would be affected, not the entirety.
that's why it was important to gather exponential amount of information so that the fewer malicious users can corrupt only a small subset of path while most of the path would remain same in my particular tree.
now, the final value, the final consensus that you would form would be the one that would be formed at the root node.
right, the root node, when it's going ground up, ground of ground up, it's like basically post order travel, not really post order, but basically bottom up traversal the value.
the final value that would be getting at the root node will be the one that you will be forming the consensus, because every node has the same exact eig tree.
constructed independently, they would all be coming up with the same value.
right, and this is how you become tolerant to one of the loop: a few faulty nodes or few corrupt nodes, few malicious nodes in your network.
right, the final current sensors would be the one that is converged at the root level.
if no faulty nodes, there are no corrupt nodes.
all nodes would converge to the same majority value, for the few corrupt nodes, sending few corrupt values here and there will be absorbed and will not be propagated up.
that's why your route will be: will be tolerant to any or to a few malicious user in your network.
but if you have large number of malicious user in your network, then you are gone, and that's what happens with the 51 attack that you might have heard of.
right, so so long as there are few faulty net, few faulty nodes in your network, you're still tolerant enough.
but as soon as it becomes, or they have the majority, they would ruin your entire network.
right, and this is the idea: to become tolerant to agreement.
right, so that even if the fault tolerant nodes, or even if there are malicious nodes, you would still have a working system.