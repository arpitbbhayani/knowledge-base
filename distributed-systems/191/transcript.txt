so reaching consensus is extremely critical in a disabled system as we would have situations day in and day out where we need nodes to agree upon a common value the tricky part here is to achieve agreement even when the nodes participating in the consensus crash in this video we talk about the simplest algorithm called the flood set algorithm that helps us achieve fault tolerant distributed consensus we look at how it fits into the real world and talk about the complexity it occurs but before we move forward I'd like to talk to you about a portion system design that I've been running for over a year now the course is a cohort based course which means I won't be rambling a solution and it will not be a monologue instead a small focus group of 50 60 Engineers every cohort will be brainstorming systems and designing it together this way we build a solid system and learn from each other's experiences the course to date is Android by 600 plus Engineers spending 9 cohorts and 10 countries ingenious from companies like Google Microsoft GitHub slack Facebook Tesla Yelp Flipkart drip 11 and many many many more have taken this course and have some wonderful things to say the coolest part about the course is the depth we go into and the breadth we cover we cover topics ready from real-time text communication for slack to designing our own toy load balancer to cricbuzzles live text commentary to doing impressions counting at scale for any advertisement business in all we would cover roughly 28 questions and the detailed curriculum uh split week by week can be found on the course page which is linked in the description down below so if you are looking to learn system design from the first principles you will love this course I have two offerings for you the first one is the live cohort discourse which you see on the left side and the second one is the recorded course which you can see on the right side the Live code base course happens every two months and it will go on for eight weeks while the recorded course contains the recordings from one of the past cohorts as is if you are in a hurry and want to binge learn system design I would highly recommend you going for the recorded one otherwise the Live code is where you can participate and discuss things live with me and the entire cohort and amplify your learnings the decision is totally up to you the course details prerequisites testimonials can be found on the course page dot me slash masterclass and I would highly recommend you to check that out I put the link of the course in the description down below so if you are interested to learn system design go for it check out the link in the description down below and I hope to see you in my next cohort the reaching consensus is extremely important for any distributed Network see in a database cluster of three nodes one node says that the value of price is one thousand dollars while the other node says the value of price is two thousand dollars now depending on where the request goes we either get one thousand or two thousand this is the classic problem of having inconsistency in our data that is where we want the nodes to talk to each other and come to a consensus key what the actual value of Price is Right This is the classic problem of distributed consensus and achieving distributed consensus is easy it's easy when you have zero failures so your your node to node Communication channel is perfect your processes never crash achieving distributed consensus becomes extremely simple right it's just exchanging a bunch of messages and you'll have a nice consensus handy but it becomes impossible again a very strong word it becomes impossible when your network is unreliable which means that if there is no guarantee that if you send a message from one node for it to reach the other node if there is no guarantee to that then it is impossible to achieve distributed consensus in the previous video we talked about it through the two generals problem why it is impossible to achieve right now the third case where we assume some degree of failure of network but we think that what the processes are unreliable which means that while while building a consensus if processes crash how would we handle that this is what would be the problem statement for today we would understand that how do we set up distributed consensus where we assume processes could fail right so a formal statement for that would be that we have a complete n graph or node graph so which means that every node knows about existence of every other node right and a classic database cluster would would very easily be an example of that you might have 10 15 20 nodes in your cluster and every node goes about every other else right so all nodes and processes start with some value which means that every node or process knows here hey this should be the value of price for example and they all are trying to reach to a consensus on what the final value is going to be right and every node knows the default value for that maybe the old value was 100 and everyone's trying to update to either 1000 or 2000 so default value would be 100 it's just an example the problem statement is very generic right so that you can apply it to hundreds of cases or hundreds of applications per set right so what we want is we want all the nodes to agree upon one same value for the variable price now the possible value for the possible values of price would be stored in capital V it's just a nomenclature in capital V that would be all possible values out of which one every node would be agreeing on right so what do we want from our consensus we want that no two processes no two processes decide on different values which means that once we know that we reached the consensus no matter what every process or every node in your system would all agree upon that one value right be it VX or V 0 v x is the agreed upon value or V 0 the default value which means a transaction either commits or rolls back right if all processes starts with v belonging to capital V then they decide on V which means that if all processes say that the value should be 1000 and no one pitched any other value so then the value that everyone would be converging on has to be 1000 which means that they should not be picking a value which is out of their scope like every process should not converge and say 1001 is the final value right so the value that is selected should be the one that is proposed and if everyone starts with that same initial value everyone should be agreeing on that same initial value and all non-faulty processes eventually decides that if the process survives the consensus everyone should be in a situation where they have decided on the final value right now this we would achieve through an algorithm called the flood set algorithm the core idea of flood set algorithm is extremely simple extremely intuitive and that's the beauty of distributed systems it's very simple it's just that you have to handle a lot of failure cases okay so the core idea of flood set algorithm is that we keep a track of all the values seen so far e v as in every single node would keep a track of all possible values that they have seen so far and they use some decision rule some decision rule to pick one name so this is the core idea of it which means that in a complete graph every node would maintain a set w and W would be a subset of all possible values V right everyone would start with an empty they would put in their value that they think is correct and then they would somehow get from a video that not keep what possible values is right now what do we do so this is a synchronous algorithm which means every node would move forward synchronously right so if we assume that processes crash nodes would crash if you assume that we can assume that hey at Max F nodes would fail so f is the failure rate that we are assuming that F nodes would fail while this consensus is happening then the flood set algorithm would run for f plus 1 rounds right flood set algorithm would run for f plus 1 rounds which means that we are giving enough chances for the nodes to crash so which means after f plus 1 rounds if my nodes so at Max we are at Max we are saying that F nodes would fail even if they fail we would still reach the consensus right so that's why our algorithm would run for f plus 1 rounds right so that everyone gets enough chance to fail right and after f plus 1 rounds the processes that survive are the non-faulty processes and they have to make that decision and that decision has to be unanimous right and that's why this algorithm goes for f plus 1 rounds right so that everyone gets that chance to pay right okay so what's the flow as simple as that to make the decision right every process would say that hey the value of uh let's say price is one thousand someone would say two thousand someone would say three thousand right depending on where the API call went and how they are trying to converge now when you're trying to reach these consensus what would happen is everyone would have this W set right this W set would be the set that they are proposing of all values that they have seen so far so w would be the set in which they would first put the value that they think is the right one right so they would initialize their set with the value that they hold now for each round every node broadcast this W in the network which means that because every node knows about existence of every other node when they broadcast they send message to every other node right so every node broadcast W in the network when the node receives W from others it does a set Union and updates its w so what would happen is every round a node is broadcasting the value and it is and because it is broadcasting the value every node would be receiving W from every other node and the node would keep on doing set Union of all the values that it is getting which means after f plus 1 rounds or rather even after the first out also they would be getting all possible values that every single node thinks about it for example if some note think price to be 1000 some nodes think price to be 2000 so after f plus 1 rounds every single node in the distributed Network would have W is equal to 1000 comma two thousand right they are getting all possible values that all possible nodes think while setting up that consensus right now given that every node has the entire exact same information now all they have to do is just decide so if the W the set that the node has it contains just one element which means all the nodes during the first step itself they were thinking of the same value then they would be picking up that only element which is part of the sector right if not in case W contains more than one element every node is independent and then what they would do is they see that W has more than one element so they cannot decide which one to pick so they would pick the default v0 these are very generic statement now implementation is totally up to you right so if W contains more than one element which means that your your consensus could not be formed so you would pick the default option right so this way we see that if all nodes start with the same V after f plus one round the W would just contain v at every node independently and hence every node would be deciding on V to be the final value fine okay now what is an alternate decision strategy a simple example for that again that instead of picking a default value given that the first phase of this algorithm for the f plus one round nodes are continuously broadcasting the W the depth scene so far which means after f plus 1 rounds they all would have seen all possible values that they need to agree upon right after because they have seen all possible values all they have to do is just make a decision now they can make alternative decisions for example they can see I'll pick the smallest one out of it depending on your use case or you may pick I'll pick the newest one out of it like for example it's that uh at 9am like someone is setting one thousand dollars at nine zero zero zero zero uh someone said take two thousand at uh uh at basically one second past nine someone's hitting 1500 at two second pass nine to build a consensus you may choose to pick the newest value totally up to you so primarily the idea is so long as you have a total ordering of the values somehow you know that this would be the latest one right maybe through timestamp maybe through Global ID anything if you have a total ordering of values you may have that as a decision strategy because the first phase of this algorithm says that hey I'll ensure that I'm flooding the network with all the values that are there I'll ensure that every node has every value possible and they would just need to have their own decision strategy so you may choose to discard that if I have more than one elements in the set no one would make any decision people would fall back it's like aborting right someone would say that now that I have all the values we'll pick the latest one or we'll pick the smallest one we'll pick the newest one totally up to you depending on what kind of consensus you would want to build you would change your decision strategy right as simple as that so this is the beauty of this algorithm it's extremely simple to understand but extremely handy you'd see this in a lot of real systems out there right the key point if you have total ordering of the values it's up to you and how you want to decide if you don't have total ordering you may just decide to abort it fine now let's talk about complexity analysis of it you can very clearly see that the algorithm would take order of f plus 1 time because you are having f plus 1 rounds so depending on um how uh how much tolerance you want for the failure let F processes could fail f plus 1 would be the order in which like up until which your algorithm would run in each round every node sends its W to every other node so the communication complexity which means the total amount of messages exchanged would be equal to f plus 1 into n Square because in each round every node is sending n messages to n nodes so communication complexity for this algorithm would be order of f plus 1 n square right it's it seems huge it's not because your number of nodes would not be that substantial to be honest right five nodes said no 50 notes right when you're setting up consensus you are not doing it at an internet scale right obviously there are algorithms to do that much more efficiently but this on a smaller Network would work just fine right but understand the core idea behind it this is such a generic explanation now you can put it and yeah you can put it to use into your specific use cases right great that's it that's it for this video If you guys like this video give this video a massive thumbs up if you guys like the channel if this channel a sub I post three in-depth engineering videos every week and I'll see you the next one thanks [Music]