so leader election is important in every single distributed system out there, as it enables us to auto recover from failures. in this video, we take a detailed look at a synchronous ring-based algorithm called the hs algorithm and see how it works on a bi-directional network, in order n log and complexity. but before we move forward, i'd like to talk to you about a course on system design that i have been running for over a year now. the course is a cohort based course, which means i won't be rambling a solution and it will not be a monologue. instead, a small, focused group of 50- 60 engineers every cohort will be brainstorming systems and designing it together. this way, we build a solid system and learn from each other's experiences. the course to date is enrolled by 600 plus engineers spanning nine cohorts and ten countries. engineers from companies like google, microsoft, github, slack, facebook, tesla, yelp, flipkart, dream 11 and many, many, many more have taken this course and have some wonderful things to say. the coolest part about the course is the depth we go into and the breath we cover. we cover topics raging from real-time text communication for slack to designing our own toy load balancer, to quick buzz, live text commentary, to doing impressions counting at scale for any advertisement business. in all we would cover roughly 28 questions and the detailed curriculum, uh split week by week, can be found on the course page, which is linked in the description down below. so if you're looking to learn system design from the first principles, you will love this course. i have two offerings for you. the first one is the life cohort discourse which you see on the left side, and the second one is the recorded course which you can see on the right side. the live code based course happens every two months and it will go on for eight weeks, while the recorded course contains the recordings from one of the past cohorts, as is. if you are in a hurry and want to binge learn system design, i would highly recommend you going for the recorded one. otherwise, the live code is where you can participate and discuss things live with me and the entire cohort and amplify your learnings. the decision is totally up to you. the course details, prerequisites, testimonials can be found on the course page at binary dot me slash master class and i would highly recommend you to check that out. i put the link of uh the course in the description down below. so if you're interested to learn system design. go for it, check out the link in the description down below and i hope to see you in my next cohort. thanks, so in a distributed system where you have a leader and a lot of followers, there is a possibility that a leader node can go down. and if your leader node goes down, either you can do a manual intervention and configure another node to be the new leader, but it takes time, applause, viral intervention. so it's always better that your system auto recovers the way it does it it. it basically runs a leader election algorithm which automatically elects a new leader in a few seconds, and this is why leader elections are important in a distributed system. so the algorithm that will be talking about is called as the hs algorithm, which is also a synchronous algorithm, which means that every node participating in this election would know: hey, now the election is starting, now we are moving to the next round, then the next round in the next round, and now the election is ended. so they are all operating synchronously. when the election process starts, apart from that, they could operate on its own, but when the leader election algorithm starts, they are operating in a synchronous way. the best part of this algorithm is that its communication complexity, which means that during the leader election the number of messages exchanged is just order of n log n. or the lcr algorithm which we saw in the previous video. it had a communication complexity of order n square and this is just order n log n, which means that the total number of messages exchanged during the leader election is just order n log n, which is very efficient as compared to your previous lcr algorithm which was n square. now this means that there would be very less network congestion happening in the network, right? so this is a good part of this, of this algorithm. now this: although this algorithm works on a lot of topologies, but the bare minimum expectation that it has is that every node knows both of its neighbors, like its left neighbor and the right neighbor, or its clockwise neighbor and anti-clockwise neighbor. so it expects a bi-directional ring structure in between node can be connected to any other node, but at least the bare minimum connection that it expects is of a bi-directional ring where every node knows the node on its uh, now the immediate node in its clockwise direction and in its anti-clockwise direction. this is a bare minimum expectations that it has. right, the algorithm works even when the total number of nodes in the network are unknown, and- which is the great part, so not the. each node need not know the total number of nodes in the system. it would work without that as well. right fair bit of assumptions that we are making is every node has a unique uid, which are comparable, and every node knows both of its immediate neighbors so that it can form a bi-directional ring. so these are the bare minimum assumptions that we start with, and now we take a look at this very interesting algorithm and what it does, right. so here, when a node detects that hey, leader is down, it triggers a leader election and, because it is synchronous, every node would know: hey, now we are starting up a leader election, uh, in our network. so every node participates in this election and it pitches itself to be the new leader, because everyone wants to be the leader and everyone pitches to be the new leader. hey, i want to be the new leader right now. how would it pitch? every node creates a message with its own uid. it basically creates its own candidature and sends it to its immediate neighbors. here there are two neighbors right, one in the clockwise direction, another one in the anti-clockwise direction. so it creates a message and sends it to both of its neighbors, now in order. so here what would happen? in order to reduce, because the communication complexity is order n, log n, which means we have to do better than n square. so the idea here is not every node, like there would be multiple rounds in this algorithm, but the nodes who know that their uid is definitely less than someone in the network, they would be immediately stepping out of election, that hey, we are not participating in the election anymore, and this way the number of messages would be reduced. so the core idea is that the nodes, as soon as they identify that they are definitely less than some some of the node, step out. this would reduce the number of messages that are exchanged during this leader election and hence reducing the communication complexity. so here we add a concept of a local maxima and a global maxima, right. so node needs to know that if it is at least in the local maxima, if it is in the local maxima, then it has a chance of surviving when we are doing a global maxima. and here what we would do is we would start with a like core idea, i'm just talking about that every node will find out, hey, in the neighborhood of one, am i the local maxima? in neighborhood of two, am i the local maxima? in neighborhood of 4, if i am the local maxima. if in neighborhood of 8, am i the local maxima? if it is, then it is continuously surviving to be a global maxima. this is the core idea, right? so now here, what would happen is each of the participating node that you have in each phase i. so the election happens in multiple phases, right? so each of the parties, each of the participating node, in each phase i sends message up to 2 raised to i nodes. right. so in my 0th phase, phase 0, every node participates in the election that we know of and every node sends message in 2 raised to 0, equal to 1. so in its one neighborhood, so miss, every node would send message to a distance of one node in clockwise direction and in anti-clockwise direction, or left or right, right. so here they would be, making one neighborhood and find out and finding out: hey, am i the local maxima in this one neighborhood? in phase zero, it would no key. am i the like? do i have the largest uid in this range or in this neighborhood? local neighborhood of one? one neighborhood from my current node right. so let's say, if my node seven has 3 on the left and 9 on the right, now what would happen in phase 0? 7 would pitch itself and would create a message with 7 in it and send it to 3 and 9.. now what would happen is they would decide: k is 7 the bigger one. so, similar to elsar algorithm, we do something very similar over here as well, that when the neighboring node receives the message, then what they do is they compare the incoming uid with their own uid, right. so now let's say we have order three, seven and nine, so three would receive a message from seven. now what would happen here? as soon as three node receives a message from seven? what would happen is it would compare the incoming uid, which is 7, with 3. the 3 node would compare 7 with itself. 3. it would find that incoming uid is greater than its own uid, correct, because 7 is greater than 3. so what it would do is it would forward it to its neighbor until the hop sustains. i'll explain that in a minute, but it it basically classifies to be: hey, now i can forward this message, otherwise it would not right. so it would keep it. it would basically forward the message right now. what could happen is the incoming uid is less than its own uid, right? so let's say my incoming uid was seven. now let's say i'm talking about node nine receiving message from node 7.. what would happen is 7 would be set to 9. 9 would say that hey, incoming uid 7 is less than my own uids, i will discard the message. so message is not sent like. the message is discarded by that node, right. and now, if your incoming uid is same as your uid, you would identify yourself as the local leader. i'll i'll give an example, right? so let's let's take a detailed example and explain when this would happen. so here, when the message is sent, like, when a node participates in this phase of election, it sends message to its neighborhood, right. when it sends message to its neighborhood, it sends in some local neighborhood, let's say 1, 2, 4, 8, something. when it is sending the message in that neighborhood, once the number of hops exhaust, then the message is sent back to the originating node. so, for example, in phase 0, a node sends message to its immediate node, to its immediate neighbors, right, and then they would send back the message to the originating node because one hop is complete right. then in the second, in, in second phase, what would happen is, uh sorry, in phase one. so first was phase zeros, then in phase one, what would happen? two raised to 1 hops, right. so then it would do 2 raised to 1 hops, which means it would start from this node and send to its immediate neighbors and they would send to their neighbors. so now this node is evaluating that, hey, am i still a local maxima in neighborhood of two? if it is, then well enough. so once the message hits the nodes at distance of two hops from my current node, they would be sending back to the originating node. this way, slowly and steadily, we are increasing our neighborhood to see if we are still the maximum or not, if we are, well and good. so now what would happen is if we are forwarding a message in, let's say, hop to two, hops, right. and if we receive the message back from them. because what would, what could happen if your incoming if for the other nodes, if the incoming uid is less than its own uid, they are discarding the message, which means that if the message is discarded, they would not get reply from a particular side, right. and that is where what would happen is if a message, if a node receives the reply like it went in that direction and it receives the reply from both the sides, it means that it is still the local maxima in that neighborhood. now, here, subsequent phases that you have, is you would start with phase 0, phase 1, phase 2, phase 3, phase 4. so you are constantly testing yourself that, hey, am i the local maxima in two raised to zero, equal to one neighborhood, two raised to one, two neighborhood, or four neighborhood, or eight neighborhood. eventually, what would happen is your ring would exhaust and you would get, and you would get your probe med search directly, right, and if that happens, you would know that, hey, you are the leader, right? so here, a very simple way to see. this is how we are constantly increasing our neighborhood with each face and seeing that, am i still a local maxima? and now, eventually, what would happen? the message with the la, the node with the largest uid, would survive, because all other messages would be discarded, right. so this is what the core idea of this algorithm is all about. so here you can very clearly see how. and here one key thing to note: it's not that, because it's a bi-directional ring, every node only is supposed to know its immediate neighbors, right? so even though a node is stepping out of election- that, hey, i have a smaller uid, i'm definitely not going to be a global maximum, so i need to step out- but they would still be relaying the messages because the node is not expected to know any other node in the system. it's expected to know only its immediate neighbors on the left and on the right, right. so other nodes are still relaying the messages, but they're still doing it in a way that, hey, we would know that, hey, i'm, i'm basically forwarding this message till this hop, so they would continue to relay the message while doing that comparison of dropping the message or not, and all of that is continuously happening. right? but they're still relaying the messages and they're not like, hey, i won't do anything in the election because i'm not going to be the leader, right? so this is a very nice order n log n idea. now you can very clearly see how we are reducing the number of messages by moving in one neighborhood, then two, four, eight and so on and so forth, and which is what reduces the communication complexity of this algorithm, right? so here the node with the highest uid will be, will be surviving this entire drill, and what would happen is that would be the only one that would be left in the system. and when that happens, when a node receives its probe message- right, so the node. let's say, if in my ring i have six nodes, what would happen as soon as i hit my four neighborhood, like two raise to two as soon as i go to my second phase- what would happen is i would receive my own. sorry with it. i would receive my own probe message, right, because i'm moving it to eight hops. i only have six node in the system. so what would happen is i will go around the ring and come back to the same node again. so that's how you would know that hey, no one else is surviving, everyone else stepped out. no one else is the local maxima anymore. so because there are no local maxima and i'm the only one local maxima, which means i'm the global maxima, right, and this is how the message from a node with the highest uid survives the ring. and when a node receives its own probe message, it would know that hey, it has the highest uid and it can, and it is the new leader anymore. so now the new leader relays the message in both the direction and every node knows about it that, hey, this is, this node is the new leader, and this is how the new leader is elected in this system, by this algorithm. one key implementation detail that i want to talk about is: how would you know that the number of hops are existed, are exhausted? the core of this algorithm is that we are first checking in one neighborhood, then two neighborhood, then four hop neighborhood right. so you need to know that. hey, now i have, now my message has made four hops and now i have to come back again. so how do you do this? so the message that a node sends in a particular phase, it has three details: uid, which is the node that has i'm participating in the selection, so my uid would be there, plus the number of hops it needs to make. so 1, 2, 4, 8, 16, the hop count and the direction: is it left or right, is it clockwise or anti-clockwise? now, what this would help is, every time this message is forwarded to the new node, or or basically, to the neighborhood node, it would reduce the hops and send it forward, it would reduce the hop and send it forward, and on and so on and so forth. once it reaches the node and the hops are exhausted, it uses its direction and reverses it and sends it in the other direction. right, and that's how. this is the key implementation detail on how this is actually implemented. so the number of hops is spa, is stored in the message and is sent across and is reduced at every hop. once it becomes zero, it relays it back to the originating node in the opposite direction, and that's why we are sending the hops and the direction beat clockwise or anti-clockwise in the message itself. so this would help the road to know when to stop forwarding and when and in which direction to reply. right, and this is a very simple yet very efficient implementation of a leader relation algorithm. this is how it reduces the communication complexity, because each node is now only acting as a relay rather than pitching itself. the complexity has drastically reduced to order n, log n, because we are constantly increasing our neighborhood and a lot of nodes would constantly be falling out of the system and say would be falling out of the election. right, and this was the hs algorithm to do leader election in a distributed system with bi-directional, in a bi-directional ring, and that's the beauty of this implementation. so, yeah, that's it for this video. if you guys like this video, give this video a thumbs up. if you guys like the channel, give this channel a sub. i post three in-depth engineering videos every week and i'll see in the next one. thanks, [Music].