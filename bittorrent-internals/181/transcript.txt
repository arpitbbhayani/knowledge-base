so codeml is a disabled hashtable implementation and it is used as an overlay network for bittorrent instead of talking about micro details and how it is used in bittorrent today we spend time understanding condemlia in depth in this video we take a super detailed look into distributed hash table implementation and we would see how it can power the routing of request without having any central authority we look at how data and nodes are represented how it leverages xor as a distance function and how it always converges to the node that we are looking for but before we move forward i'd like to talk to you about a course on system design that i have been running for over a year now the course is a cohort based course which means i won't be rambling a solution and it will not be a monologue instead a small focused group of 50 60 engineers every cohort will be brainstorming systems and designing it together this way we build a solid system and learn from each other's experiences the course to date is enrolled by 600 plus engineers spanning nine cohorts and 10 countries engineers from companies like google microsoft github slack facebook tesla yelp flipkart dream 11 and many many many more have taken this course and have some wonderful things to say the coolest part about the course is the depth we go into and the breath we cover we cover topics ranging from real-time text communication for slack to designing our own toy load balancer to quick buzzes live text commentary to doing impressions counting at scale for any advertisement business in all we would cover roughly 28 questions and the detailed curriculum uh split week by week can be found on the course page which is linked in the description down below so if you're looking to learn system design from the first principles you will love this course i have two offerings for you the first one is the live cohort discourse which you see on the left side and the second one is the recorded course which you can see on the right side the live code base course happens every two months and it will go on for eight weeks while the recorded course contains the recordings from one of the past cohorts as is if you are in a hurry and want to binge learn system design i would highly recommend you going for the recorded one otherwise the live code is where you can participate and discuss things live with me and the entire cohort and amplify your learnings the decision is totally up to you the course details prerequisites testimonials can be found on the course page at binary dot me slash master class and i would highly recommend you to check that out i put the link of uh the course in the description down below so if you're interested to learn system design go for it check out the link in the description down below and i hope to see you in my next cohort thanks so to get information about the peers a node in a bit torrent talks to a central entity named tracker tracker keeps track of all the peers participating in the torrent sees how much they have uploaded downloaded and what not any peer who joins the network talks to this tracker to see hey give me 50 random peers to talk to and then the peers talk among themselves and then download and distribute the file but there is still a central entity tracker who keeps track of all the peers that are participating in the torrent now given that we have a central entity in the system two things could happen first it could go down so if a tracker goes down the entire torrent collapses second because it's the center entity it's prone to attack so attacker could just attack this one central entity and retrieve all the information that they need or they can take down the torrent so in either case this hybrid p2p implementation might be sufficient in most cases but not good in a lot so can we go pure p2p implementation in which there is no central authority or no central entity to keep track of anything right and which is what we discussed today we talked about something called as kadamlia so bittorrent uses something called as an academia as an overlay network right so there is so if like bittorrent can be implemented with a central entity called tracker or you or it can go pure p2p with by using an overlay network uh that is implemented using kadamlia right so cademia what it is so cademia is an implementation of a distributed hash table hashtable simple key value pairs right but if one node is not enough to handle a lot of data what do we do we distribute it across the node it's not just about storing large amount of data but also about having a pure p2p implementation of it so we would have a lot of nodes in our network and they are all storing some bunch of key value pairs right now what we need to do the beauty of this is there is no central entity now the request let's say i want to get a particular key value pair request can come to any node and that node needs to know who to talk to to reach to the node that holds the particular key value pair and this sort of routing and networking is the overlay network that i'm talking about right instead of going deep into bittorrent part of it we'll talk about this raw distributed hash table implementation which you can leverage and extend across hundreds of use cases out there right okay so to start our understanding of a pure p2p dht implementation we start with representation so how is every node and a key participating in this dht in this distributed hash table they are represented by okay so every node or every data in this dht implementation is gets a unique 160 bit or 20 byte id now this is a unique id unique there is no overlapping that could happen but this unique id would uniquely identify either a node in the system or appear in the system or the key in the system like the key value path that you are storing so key or node so basically how you can get it you can take the node ip pass it through the hash function and the ha and it would spit out a sha 1 uh 160 by 160 bit hash or you can take the key that you are storing pass it to the hash function you get 160 bit hash so the overall idea is the representation would ensure that everyone who is participating in the network gets this 160 bit or 20 byte unique id right and this becomes the the way for us to locate an object right okay now we talk about ownership now that we have assigned ids to the keys and the node who would own a particular key so any network any pure p2p implementation needs to first solve the problem of ownership as in given a key given a node or given a key and a set of node which node would this key reside on right this is called the ownership problem so we have the hash we have the unique id of the key and the node now what we could do is we could say that hey the node that is the closest to the key owns the particular key we can say that right but then given that we have ids assigned how would we know right how would we know which is the closest node right and this is where we need a way to define the distance metric now this is not a linear scale or a physical distance that you can say hey this is this much foreign that is that much far right so there has to be a very smart way to define a distance metric that would help us tell hey for this particular key out of this three n nodes or out of these three nodes node one is the closest one so my key k1 would be placed at node n1 right to do this comparison you need something called as a distance metric so what's a distance metric in order to find a closest node we need a distance metric that quantifies the closeness obviously now for any you for any euclidean geometry what we need is we need or any distance metric needs to satisfy three requirements first of all is distance of the point to itself is equal to zero right it cannot be positive it cannot be one two three something distance of x comma x is equal to 0 second distance of x comma y is greater than 0 if x is not equal to y for all x and y basically distance between any two points should be greater than should be greater than zero if the points are different so it cannot be negative or zero it could be zero only when both the points are same right and the third is called the triangle uh third one is called as a triangle inequality which says that distance from x to y plus distance from y to z is greater than equal to distance of x to z now this means that basically the shortest distance between the two points is always the straight line connecting them right it's a very simple way to put it this way so the three points can form a triangle it would still hold you x y y z and x z x z should be smaller or equal to the summation of the other two while if all the three points are collinear then x y plus y z should be less than equal x y plus y z should be greater than equal to x z right classic classic three conditions to meet our basically distance function so we can so this gives us this freedom like given that this is not a physical we could measure the distance in meters and kilometers here what we could do what we have to do is we have to define a metric or a function that satisfies this three requirement right so what kademiya uses kardemla uses a brilliant approach condemn layer uses xor raw simple fast efficient xor function in order to define the distance between the two node so distance between x comma y is equal to x xor y right so the two ids that we got 160 bit each we just take the raw xor of it and the integer represented by that becomes the distance between the two node so this is such an efficient implementation because it is not you don't have to do explicit measurement keeping track of things and what do i just raw simple xor function very efficient to compute repetitively even right and now let's see if xor actually satisfies all the three requirements first was ah distance between x and x is equal to zero distance function is xor for us x x or x 1 x or 1 like when 2 are same x are gives out 0. so d of x comma x is equal to 0 satisfied second d of x comma y should be greater than equal to zero so x x or y is definitely greater than zero uh because there is no sign bit compared so it basically cannot become negative so it's zero it's basically greater than zero so that's satisfied third is distance of x comma y plus distance of y comma z is greater than equal to distance of x comma z now distance of x comma y is x x or y distance of y comma z is y x or z so x x or y x or y x or z so y x or y cancel out to zero so it becomes x x or z and it's steady and it actually satisfies the third requirement is distance of x comma y plus y comma z is greater than equal to equal to was important greater than and equal to distance of x comma z so it satisfies all the three requirements that we wanted from our distance function which is basically simple euclidean geometry right so this shows that we can use xor as a distance metric right and which is exactly what cut api uses okay now that we know we have defined ownership we have defined a distance metric now let's visualize this distance and why it is important because it would help you define routing so given that we have distance metric based on xor let's see how we can visualize it visualizing it could be like if it was a physical decision i could just plot it with x y coordinates on the graph and do that but here it's xor xor is very different it's not like regular distance matrix so how do we do it so here to simplify the things instead of taking 160 bit representation i'm taking 4 bit representation right so the unique values would range from 0 to 15 both inclusive right so let's say my node n1 has an id of 15 15 is one one one one my key my node n2 is having id of 5 so 0 1 0 1 right and my key k a it has id of 6 0 double 1 0 right so when i have this so in order to find which node owns the key ka i have to take i have to find distance from ka to n1 ka to n2 right once i have the distance i can compare with whichever one is the smaller i'll go there right so distance between ka and n1 comes out to be 9 distance of ka and n2 comes out to be 3 so ka owns by n2 right so here when we do an xor the property of x or that when we are basically when we are computing the resistance we are doing an xor of the two numbers right the property of xor is when the two bits are same it spits out zero if they are different it spits out one so when i'm xoring the two numbers what i'm doing is so long as my most significant bits are same it the output would be zero zero zero zero as soon as it would start to differ i'll get output one so so for the common prefix the distance so basically more common the prefix between the two ids the smaller would be the distance because if my key and my node the id of them if they differ at the first at the most significant bit itself then it would output to one and because if the output is also 160 bit in 160 bit string the most significant bit would be set to one so distance would be longer right given that xr has this property we would we can confidently say that more common the prefix between the two ids the smaller the distance right so because if the prefix is same what would happen they would all start to when you do x or bitwise xor it would start to split zero zero zero zero zero as soon as the first differing bit comes up the output would be one so common the prefix smaller the distance this is such a beautiful way to visualize it it's all there in the research paper like i loved it when i was trying to understand highly highly highly recommend you to go through that as well and so common the prefix smaller the distance now this would give you this hint prefix prefix i want to store it somewhat the first thing that would come to your mind is hey can i store it in a try data structure exactly so that's a very good way to visualize it so what if we create a binary tree a complete binary tree where let's say i am using with four bits right so i'll have a binary tree of level four so let's say left subtree is one right subtree is zero and i continue to do it across all the depth so my node n1 whose id was 15 is represented by one one one one right so in my complete binary tree i traverse 1 1 1 1 i'll the final the leaf node would be where my n1 stays similarly for key similarly for key a and then n2 and here when you put it into the complete binary trend you place it there you can very clearly see that n1 and kb are close to each other while ka and n2 are close to each other so the xor metric that we were talking about that hey how would we identify how would we do that here it gives a very clear visual way to look at hey these two are actually close to each other right so we can visualize the distance metric that we were talking about in a try now this would help us with routing and that's the brilliant part of this algorithm okay given that we sorted this or given that we put it into a complete binary but if you look at this that if i have 160 bit then i'm unnecessarily creating a complete binary tree it's a waste of time space and resource don't do that so instead we instead of having a complete binary tree we create the path as needed so for example if i have my node n 1 that is id 15 it would be 1 1 1 1 but if i have not seen any key that is one one zero something i can just place my n one into the into the shortest path possible right so this way for the four examples that first so let's say if i take examples of seven different entities right n1 is 15 ka 6 n2 is 5 kb is 13 kc is 8 kd is 9 and n3 is 1 now if i want to place this instead of having a complete binary tree what we would have to do is we would just place it as at the smallest height possible right such that it disembed that it disambiguates itself from the other nodes right so instead of having the entire like instead of you needing to travel entire 160 bit just keep it at a shortest disambiguated path possible right and that's the idea this way you would save space and you would be reaching to the point much much much faster right so with this you and also if a particular sub tree does not have any node or any key placed in there you don't even need to construct it so just keep it bare minimum the essential that you need everything else you can discard right okay given this as a representation now let's talk about routing now this would make routing much much much fun okay so given that there is no central entity in the system how would you know where to go to right so let's say if you would want to fire get key k5 and you fired this request to node n1 node n1 holds one two three like key one key to key three and you requested key five the request came to node 1. now node 1 needs to know where this request should be forwarded to right so that's where node 1 needs to have some sort of routing table that knows where to go to but every peer or every node cannot know about every other node because if it does then if you have thousands and thousands of nodes then every node needs to know about every other node so memory consumption would increase plus if any node leaves the system or joins the system someone has to broadcast this information it's too much complicated right so somehow you need to find where to send this request to right so this is where the routing strategy would come in so let's talk about that so every node in the network would keep a track of a few neighboring nodes right and it would hope that everyone else in the network also does so so for example i might keep track of few nodes so if if i am being requested key 5 and i don't have it but either i might know a node that has it or a node that is closest to the node that would have it so somehow i need to know where to forward the request to right and this is what the key problem that your routing needs to solve that no matter which key is requested it would always take you in the right direction and take you to the node that would store the corresponding key that you are looking for right okay so here when you say hey my every node will keep track of few neighboring nodes imagine every node taking care of like randomly picking nodes it would not converge you cannot guarantee convergence if you are just picking nodes at random and just think hey you keep these fine or you keep that fan there has to be a strategy behind it right and this strategy is what the core routing logic comes in okay so what's the core idea the core idea of this is the visualization that we did with try that would come in handy so hear me out every node in the network knows at least one node in each of the subtree that it is not part of right so for example if i'm talking about node n1 which is at which is having the 4 bit ids 0 1 0 0 right 0 1 0 0 that's the id of node n 1 so node n 1 would need to keep track of three sub trees that it is not part of which are these three subtrees because its id starts with zero so the entire sub tree that starts with one it needs to have at least it needs to have contact in at least one of the node in that gigantic subtree that starts with one right then n1 was 0 1 so given that it starts from z it has a prefix of 0 1 the sub 3 that it left out is 0 0 so it would need to have at least one contact in zero zero the entire sub tree that start with zero zero anyone any one node any uh a contact with any one node in this sub tree is fine right then it has zero one 0 so which means the sub tree that is left is 0 1 1 so it needs to have one contact in subtree that has prefix 0 1 1 it needs to have one contact here and then 0 1 0 0 is where n 1 is stored so 0 1 0 1 is where it needs to have one more contact so basically if there are 160 bits sorry let me take care if there are four bits in the system your therefore uh if sorry if your id is four bit long you would have contact in four sub tricks right if you have 160 bit id you would have contacted at least or you need to have at least one contact in each of the subtree that you are not part of right so this way wherever if the request comes in for anything you would have a place to route your request to and which is what is needed with a good robust routing strategy now with this in place let's look at how routing would happen and this is the most beautiful part of cadamia i loved it like you cannot even express how excited was i when i got to understand and write a small prototype to implement this it's beautiful beautiful okay so now if let's say i have my uh let me take a very let me take a very concrete example over here so let's say we are node n one which is stored at zero zero zero zero which is the extreme right node in my uh in my uh network right or in this binary tree right extreme right node and i have n2 where i have to talk to i don't know n1 doesn't directly know n2 right but i want a key that is there with n2 and n2 is 1 1 1 1 which is the extreme left node right so now here because they don't directly know each other we need to have a way to route the request so now what you can do is you can slowly and steadily start to converge right so the idea is when you start with n 1 which is 0 0 0 0 what it would have is because you know that you want to go to 1 1 1 1 so from 0 0 0 to 1 1 1 1 what you know that i don't have to like i have to definitely go to the sub tree that starts with one you would have one contact let's say you have contact with node n a that is placed at one zero zero zero suppose you have a contact there right you would need to have contact in one of two at least one of the node in that subtree let's say that node is n a which is one zero zero zero so you would forward your request to one zero zero zero zero right you'll reach n a then n a would know a high i am an a which is one zero zero zero and this request needs to be forwarded to whom one one one one so it would find a contact in a sub tree because it is not part of in the subject that it is not part of it would be one one right and this node would have a contact in that sub tree because it's its responsibility to have it right so this node might forward your request to nb which is storing at one one zero one because it is part of that subtree one one it would follow the request two and then let's say this nb node directly has a contact with n2 which is 1 1 1 1 so it can directly send your request to n2 and this is the beauty of this design that you would always converge to the node that you are looking for because every node keeps every node in its routing table would have information about the node that at least one node that it is not part of its own sub tree and this is the brilliant of xor metric if you are confused work out with this example and if you take an example you'll understand it in very much depth on how this beautiful routing has happened okay one clarification when i say it would route the request it would forward the request it does not mean that i make a request to this node and that node makes a request to other node it would send back the ipin you would make another request right understand it well that it's not that it's acting as a reverse proxy slash load balancer no your forwarder request uh when i say form it would it's just a routing table right so it would give you the ipad of the machine that you need to talk to right and so on and so forth right so the responsibility of the node is to either give you the key value that you're looking for or give out the ipa test the machine where you can go to right that's how it would work so here because of the enforcement that we did that every node needs to have a contact to at least one node in all the sub trees that it is not part of this means that we would always converge upon the node that we are looking for without ever digressing and this is such a beautiful deterministic routing logic in a pure p2p network i loved this idea highly recommend you to draw this and solve it on your own but you would love it when you would understand it right okay so now given this what we know that each node would need to keep track of a small subset of nodes that it would talk to and it would put it in its routing table so kadamlia imposes or or basically kadamlia works on a udp protocol but it's not a mandate and then it's an idea you can use tcp udp webrtc whatever you'd want to use it like it's up to you right but the official paper says that hey ip udp port and node id which obviously you need to have ip and node id with you but udptc it's up to your implementation right so there is no one's forcing you to use a particular protocol over here right but it promotes you ah to solve this because you don't need a persistent connection whatsoever right okay so this is what every node in your or every node in your network would be storing is ip address of the node that ipad is of the neighboring port the port on which ip address of the neighboring peer the port at which the peer is listening and the node id of that peer so that you can hit that location very quickly right now you would say if i just store one node from each of the subtree what if that node goes down which is where what kadamlia says is instead of storing one they call it k buckets so for each sub tree for each subtree prefix that you are ensuring a connection to what you need to do is instead of having one node you would store k nodes for that so for example for our node n one we might have a subtree prefix of one our node was zero zero zero zero one zero so our subtree prefix one i would have three nodes i would have three contacts in the subtree that starts with one i might have three contacts in something that start with zero zero right and so on and so forth so the idea is instead of having one for each sub tree have multiple have k buckets it's called k bucket i don't know why it's called bucket but k bucket so for each sub tree have k contacts in it right and each of the k bucket so for each node for each subtree prefix the k bucket is sorted by time which means that most recently seen item sits at the tail of it and the least recently seen sits at the head right so for each prefix for each sub for each node for each subtree prefix the k buckets is sorted by time most recent at the tail least listened at the head right now we defined a routing strategy right we know how it always converges now what the next responsibility that we would have is to keep this routing table update because there is no central entity if a node joins and leaves the system or a new path is taken our routing table needs to be updated how would you do it so very simple idea whenever a node receives any message from any other node in the network any other node in the network it updates its appropriate k bucket with the node id right so for example if i am node n one and i never received a message from n a if i receive that message then i would update my routing table with an a's information in it into the corresponding k bucket right so if a node for the first time talks to me i'll make an entry into my k packet right this way the routing table across the entire network keeps updated so long as there are messages flowing through the nodes and if the messages are not flowing routing table would go still you can't do much about it right you because you don't have a central authority right okay but how how do we update the k bucket list because k bucket has a limit of k in it so whenever an entry is added or updated it would always become the most recently seen entry so it would move to the tail so that the least recently seen entry always stays at the head so what do we do if we receive a message and if my k bucket is not full i would add it to the tail of the tail of the k bucket right so if the k bucket is full right so now what we have to do we have to do something because k bucket is full and we have seen a new node so now what do we need to do the node to which the request or the message has come to we check for the least recently seen message or least recently seen node we would try to ping that node and see if it is alive if it is alive good we would move that node to the most recently seen node and discard the new node that has come in right if we do not get any response from the node from the least recently c node what we would do is we would delete this node because it is not responding we would add the new node to the tail of it so we would eventually have the k bucket but the least recently node is discarded because it did not respond right and if it responds if the new node responds we discard the sorry if the least recently seen node responds we would discard the new node that we are trying to make an entry to right so now you'd see array this means so basically what this beautifully exploits is that it is very much observed in a p2p network that if a node is online for a very long time it would continue to remain online in the future so the longer the node is online higher the probability of the node is to higher the probability of the node to remain online right so k bucket exploits this because if i'm pinging a node and if that node is alive i'm still retaining it in my k bucket i'm not discarding it i will be discarding the new node because it is very much possible that a node just joined the system does this thing for five minutes and then drops off but if a node remains in the system for a very long time there's a very high probability that would continue to remain as is right and this is how it promotes or it increases its probability of of having good connections or having connections with good peers purely by statistics key array i'll just keep my k bucket such that the most recently scene node continues to as is if my least recently scene node responds i would keep it and discard the new node right okay so now that we defined routing we understood so we understood distance we understood routing we understood how routing tables are updated we saw how it always converges now but let's talk about the communication interface on how on how two nodes in my codemlyon network talk to each other and what they do is every node is requested to expose four rpcs you can implement it however you want like it's just rpc is a very generic term you can implement it with rest you can implement with the raw tcp anything it's just four uh four apis that you need to expose the first one is the ping ping what it does it it probes the node to see if it is online or not it would just use to update the k buckets that's what it would use to uh so the first endpoint that it exposes is ping that a node pings at the node to see if it's online second is find node find node is your is an api that would when you make a request to a particular node it would help you find the node that you are looking for so if i have two nodes sorry if my request came to n1 right now n1 you fired find node to n1 n1 would fire find node to na because n1 doesn't know about n2 n1 has the closest one is n a it would fire the request find node to n a n a does not have address of n2 so what na would do is na would respond with the node that are closest to n2 in its routing table and this would go on so eventually n a like when you are talking to this you would be in response getting either the actual node or the ipaddress of the actual node that you're looking for or you would get the the addresses of the k nodes that are closer to the node that you are looking for right so the node itself does not forward the request it could use its route table to respond either the node that you are looking for if it has it or return the node or return the k closest node in your in its routing table right this is the find node implementation then find the value find value is because it's a distributed hash table you need to expose like given a key give me the value so what it does is it is exactly like find node but your but the machine that holds the key would return the stored value rather than just saying hey i'm present at this ip address it would send the it would respond with the value that you are looking for right again a clarification or again just reiteration of that that intermediate nodes do not forward the request they respond with either the node that you're looking for the value that you're looking for or the ip address of 50 closest node to the node that you're looking for it would not act as an intermediate forwarder right okay the lookup is a recursive you can very clearly see that find node is a recursive process that you would continue to do it unless you find the node from one node and then you for and then you would basically node n1 not needs to talk to n2 n1 doesn't know how to reach to n2 n1 broadca n1 call spine node across all the all the nearby nodes it would then call to other it would then call together and so on and so forth right you would continue to look out for n2 until you find one right and this is what happens so it's a very simple it's a very simple recursive lookup that would power uh the fine node function into the find value functionality in a pure p2p implementation right now let's talk about storing of key value how would we store a value or key value in the node so the store rpc that would be exposed it would instruct the node to store the key value in it use in memory hash table whatever it wants so it would store the value store the key value in the corresponding node so to store now let's say you would want to store something like you would want to store a key value in this p2p network you cannot now implementations would vary right remember diff like this is a generic dht implementation but however you'd want to implement for your use case it's up to you right for example some use cases might say hey i would store this key value only at this one node i would not store it at any other route you might want to do that or in some cases you might want to just distribute your key value the same set of key values across the entire spectrum and it's totally up to you so implementation would change but idea would remain the same right so to store a key value pair a node locates k closest node and sends them store rpc request right so for example if i want to store a key value pair in my p2p network let's assume that i want to broadcast it information so that every single node that i could know of stores this information stores this key value pair so that even if a node goes down i still have my key value paired floating in the network somewhere so what you would do is when you got when any random node got a request to store a particular key value right what it would do is it would first broadcast the store rpc across all its closest node then they would broadcast then they would store and then broadcast the store rpc to their closest store and so on and so forth this could be one of the implementation and depending on your use case you can alter the implementation there is no hard bound the beauty of this was the distance metric the routing logic implementation is up to you like your use case your implementation right and this way what you would see is that a key value pair is stored across all the nodes in your network right okay so now the implementation again implementation of store varies for use case for example do you want to have a single copy of a key value or you want to have multiple copies of key value do you want expiration or not do you want have a separate read write responsibility on nodes or not it there are so many variants of it you can just tweak something for your use case and work it around right some performance optimization is you can cache the key value pair throughout the chain for example if you are doing a lookup of a key value you would know that hey i got this key value like this is the closest node this is the closest node and so on and so forth you can then along that path cache the key value pair that you are looking for so that when the next time the request comes in for the same key because you would be traversing the same path you would not have to go to the target node you can just find your key value pair beforehand itself and you can just return it from there right so you can optionally cache the key value along the chain so that you don't have to always go to the to the target to the actual target node to get it it would be fairly distributed in the network right second if the node goes down the neighboring node because we are always broadcasting it if a node goes down some or the other node in the network would already have the key value pair that you have stored and this is a very good way to have a purely decentralized network no matter if node goes down or something happens you would still have your key value persisted across the network right and again the usage varies as per the use case so don't stick to it it says this and only implement this understand the idea understand the beauty of kadamlia is its routing strategy and resistance metric which is xor it's such a beautiful thing you can leverage you can plug it out put it at hundreds of other places and ensure that you have a pure p2p network and this is kadamlia and obviously there are a few other experimental part of it which i have not touched upon because it was very specific but this would give you that idea everything else is widely available on the internet this was hard to find i compressed si three four research papers information into this i got and more importantly i wrote a very quick prototype on my local machine to see if it actually work and it does right again highly encourage you to write a prototype rather than just having theoretical knowledge of it and it's beautiful beautiful world out there of p2p networks explore it right okay so this was kardemlia and this is what bittorrent uses to power its overlay network we did not go into the details of what exactly the torrent network would store what apis would it fire in other things because those are specific to bittorrent not really a dht implementation dht required its dedicated video it's a very powerful concept extremely powerful p2p concept and i wanted to cover it for so long so this is pure dht implementation detail and nothing else how to use it on bittorrent you can find it on internet uh because while you are implementing your own torrent seeder or tracker you would need that otherwise you would not but dht is is the foundational building block that you should definitely know of right so yeah that's it that's it for this video if you guys like this video give this video a thumbs up if you guys like the channel give this channel a sub this was the sixth video in the bittorrent internal series and i'll see in the next one thanks [Music] you