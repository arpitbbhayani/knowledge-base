the bittorrent is super, but what does its architecture look like? in this third video of the bittorrent internal series, we take an in-depth look into its architecture and understand different components in it, like trackers, seeders and leechers, and learn how they work together to be this amazing file distribution network. but before we move forward, i'd like to talk to you about a course on system design that i have been running for over a year now. the course is a cohort based course, which means i won't be rambling a solution and it will not be a monologue. instead, a small, focused group of 50- 60 engineers every cohort will be brainstorming systems and designing it together. this way, we build a solid system and learn from each other's experiences. the course to date is enrolled by 600 plus engineers spanning 9 cohorts and ten countries. engineers from companies like google, microsoft, github, slack, facebook, tesla, yelp, flipkart, dream 11 and many, many, many more have taken this course and have some wonderful things to say. the coolest part about the course is the depth we go into and the breath we cover. we cover topics raging from real-time text communication for slack to designing our own toy load balancer, to quick buzzes, live text commentary to doing impressions counting at scale for any advertisement business. in all we would cover roughly 28 questions and the detailed curriculum, uh split week by week, can be found on the course page, which is linked in the description down below. so if you're looking to learn system design from the first principles, you will love this course. i have two offerings for you. the first one is the live cohort discourse which you see on the left side, and the second one is the recorded course which you can see on the right side. the live covered based course happens every two months and it will go on for eight weeks, while the recorded course contains the recordings from one of the past cohorts, as is. if you are in a hurry and want to binge learn system design, i would highly recommend you going for the recorded one. otherwise, the live code is where you can participate and discuss things live with me and the entire cohort and amplify your learnings. the decision is totally up to you. the course details, prerequisites, testimonials can be found on the course page at binary dot me slash master class and i would highly recommend you to check that out. i put the link of uh the course in the description down below. so if you're interested to learn system design, go for it. check out the link in the description down below and i hope to see you in my next cohort. thanks, the bittorrent architecture consists of four key entities: the dot, torrent, file trackers, seeders and leeches. but before diving deep into it, let's talk about something called as pieces. so whenever we are sharing a file in the bittorrent network, the file is not entirely shared. the file is first broken into pieces and this piece of the file becomes a unit of transmission. so whoever wants a file would not download the entire file together. it would download a piece of a file. it would download all the pieces of the file and then concatenate to form the actual file right. so ps are like these are not randomly split, they are all the piece are of equal length except the last piece. for example, if i have a 3mb file and my piece size is 1 mb, and this piece size is configurable, you can have it from kbs, 2 mbs up to you. so if you have a 3mb file and let's say your p size is 1 mb, so you will create three pieces out of it- p1, p2, p3, for example- and each of this piece would then be passed through a hash function and we would compute a sharpen hash of it, which is a 20 byte long hash. all of these hashes are then placed into the dot torrent file. that is there, right? and this is the static information. that would not change, because your file is not changing. your static information would not change, and this is what is being used to download the piece from the peers and then basically joining it, right? okay, now the best part of this p2p network is because there is not one place to download the data from. it's a p2p network. you can go to any peer so long as it has the piece, it can give you that piece. so what happens is when you download the piece from, let's say, you have a seeder that has the entire file. you joined the network and then you downloaded a piece from the seeder. as soon as you download a piece from the seeder, you will inform the, your entire network- hey, network, i have this piece now. so if any one of you needs this piece, instead of going to the cedar, you can directly talk to me, and this way, all the peers, as soon as they download any piece, they would start informing everyone else. now, this is the power of p2p network. so it would not like. every peer would not have to go to this one server to download the piece. they can internally among themselves also exchange the pieces and eventually have the entire file downloaded. this is the actual power of p2p network, right? okay, now let's talk about the dot torrent file. in the previous video we saw the detailed structure of dot torrent file and about when coding that it uses to encode the file and what information it holds. but in the context of this bittorrent architecture, there are some key elements that are part of this dot torrent file. okay, so dot talent file is a very static file that we just saw. that has the pieces, information, file name, size and other information, but it holds one very critical info. it's called announce. announce is a tracker url, so the tracker is the only central entity in the bit. bitterness itself will basically come to that. think of a tracker like a, like a metadata store, right? whoever wants that. so you have the torrent file. in the torrent file you have the announced url, announce url. you'll go to that url to get the information about the peers, because you, as a peer, you don't know who all are in the network, unless someone tells you that. who would tell you that it's a tracker who would tell you that. so you first download the dot torrent file from your typical uh google search engine or your or your favorite torrent search. again, assume that you have the torrent file and from there you first go to the tracker to see, hey, which all peers are there in my network. depending on what it responds, you can then directly talk to the peer to download the piece, to download the pieces that you want, right? each torrent file is uniquely identified by something called as an info hash. we will. infohash is a shard, is a sharvan hash of the info section of the dot torrent file. in case you are not aware, in the previous video we talked about what holds in the info section and some that's the most important section of your dot or in file, but that that has that information. so each torrent file is identified by a unique info. we'll go into implementation details of it in the next video. but with respect to architecture overview, understand that there is something called as an info hash that would uniquely identify a dot torrent file. uh, in the ecosystem, right, okay, that was importance of the dot torrent file. announce url and that is what we'll use to talk to tracker, right, okay, now let's talk about tracker. tracker is brilliant. tracker is very lightweight. it's the only central entity as part of this p2p network. so for a particular torrent, it, the dot torrent file- contains a tracker url and that tracker will take every peer in the network connects to this tracker to get the meta information about who all are there in the network. right? the core job of tracker are three folds. first, it keeps track of the peers who hold the file, as in people who are part of this network. your tracker keeps track of them and that's why it's called a stacker, by the way. second, it keeps track of the peers who are downloading and it helps peer to find other peers to download data from. so your tracker is just a metadata server. it is just helping us hold the meta information about the network: that how many peers are there, who all are there, who are downloading, who all are seeders, who all are leeches and what not. it keep. it keeps the track of all of this information. so anyone who needs any information, this is the source of truth where they go to and there is not just one tracker in the world you can have like. basically there are thousands of trackers in the world and you make spin up your own tracker very easily so that anyone having the torrent file with that tracker forms that network, right? so it's a. it's a decentralized network where there could be multiple trackers, but you are connected to one tracker because you are interested in that one dot torrent file that you have to download the content that it possess, right, okay? so tracker itself does not download or transfer the file or the data that you are looking for. it just holds the information. so that is why tracker is very lightweight, right, okay? so what is this tracker made up of? so tracker is a very simple http server that understands normal http get put, post request, or rather, it only understands get request. it's very simple to build. so when you have a dot torrent file, you would first go to tracker to say, hey, i have this dot torrent file. or or rather, you would say you would extract some information from the dot org file and you'll go to the tracker and say, hey, i want to be part of your network and your dot and your tracker would send what it would send you information about: 50 peers, roughly 50 peers. 50 peers were part of this network, right? so then, now that you would want to download the file. then what you can do is, given that you now have information about 50 peers, you'll talk to each one of them to download the correspond, to download the pieces that you want, and the pieces information will be part of your dot torrent file. so, for example, in your network you would have seeders who has the entire file, you would have leechers who are who, like you, also wants to download the file. so what you'd, so what you would do, is you'd first go to tracker, get the peers information, then talk to corresponding peer to download, to download the pieces that you want, and then broadcast the information in the network. once you have a piece, when you, once you have all the pieces, you will just concatenate them and create your end and you basically create your final file that you wanted to download. okay, so once a machine receives a list of 50 peers, it adds it to the peer set. right, every peer reports its state to the tracker. so now what tracker is doing is tracker is not just holding the peer information. hey, these are all, yes, but it would also keep a track of the progress. when i say progress, as in how much has each peer downloaded, or each peer uploaded in the or from the network. so every period is the responsibility of every peer to send this information, the state information, to the tracker, for example. it would use this to uniformly distribute the load, as in when it sends out the peer information. it may skip to send out the information of a server that is heavily loaded, for example. like you can make tracker as complicated as possible. so the tracker is not only sending the information to the user, but it would all other peers in the network also send information to the tracker. keep this information with you. hey, i've uploaded this much, i've downloaded this much and i'm part of this network and i'm healthy and well and whatnot. right. so when tracker is actually sending this information about the peers, when, when you request for peers and tracker sends you that information, that information or that peer list, is that peers are added to the peer set and every 30 minutes it would try to, uh, or it would try to regenerate the peer set from the network so that it does not only go to the same set up here. so it would do that, okay. so if the number of peers in the peer set drops below 20, which means that, let's say, you're downloading a file and that particular file that you are downloading because you would have appears to download it from. and let's say, if now you have less than 20 ps because peers leave and like they join and leave the network, right. so if the peers are unreachable and you have dropped to below 20, right, what would you do? you'd again go to the tracker and say: array, though i was given 50 peers, but out of which 30 have left, i'm only left with 20, so, but i need more peers to download my file quickly. so can you give me more peers? so you would reach up to tracker to refresh your peer set, right? so you would go to that tracker and download it and and you would basically get the peer list and then you can talk to those peers. so whenever you fall below a threshold, you would go to the tracker and say: give me the peer list again, right? so at that time, whatever information your tracker has, it would send it out to you so that you can continue your fast download. so, maximum peer set. now, this is an important design decision that took. so maximum peer set that that a peer can have is 80, which means it can talk to 80 peers at max, at max, or sorry, it would be in the peer set, it would not even connect to them. but the maximum number of connections that any server could create is 80. obviously, before after that your machine would start to cry and then what it could hold is it could hold 40 at max for download and 40 for upload. now this is a very interesting decision. now imagine if you, as a peer in the network, you want to download a file. let's say you say that, hey, i would not upload to anyone, i'll only download the file and i'll leave the network. then what would happen if everyone starts doing it? then the load would only be there on a few set of servers. so what network wants to promote? this network wants to promote, uh, reciprocity that, hey, you upload and then only you can download. so, given that, as a use case, you want a nice blend, you want a very nice blend of having connections to download the content and upload the content, because there is a limitation on the number of connections that your machine can make, right? so that is where what it does is. maximum number of connections that your server needs to make for this network are 80, so it can connect. so you would have 40 reserved for download and 40 result for upload. this way you'd get a very nice distribution of: hey, you're not just downloading but you also have bandwidth to upload. choosing to upload or not is up to the peer, but you would have the bandwidth to upload it right. and once the as i uh said, i just reiterate that once the peer knows which p and uh the peers that it has, like every node, like, for example, you downloaded a bunch of peers. you have the peer list with you. you'd know which piece is held by which peer. given that you have this information, you can directly go to that and get this. and now how would you get this information? through gossip, we'll go into the actual implementation detail in the next video i'm just giving. i'm just basically setting up a good context over here, right, and all of this has specific algorithms, that power. it will go deeper into each one of them and see how it performs. okay, so just on a very high level. this is what your bittorrent arc look like. looks like. so let's say you are a peer, you have a torrent file and you want to download something, so how would you get this torrent file? so the step number one would be: someone first has to upload the original file in the torrent network. so the first seeder of the file- let's say there is a file, uh, let's say some ubuntu distribution- and this first seeder would first create a dot torrent file for it. from the file that you have, using any bittorrent client, pick any pick your favorite- you can create a dot torrent file and would upload the torrent file on a torrent server. now this would be a global search engine like, for example. this could be as simple as a torrent search engine that you know of, or maybe an official website of ubuntu where you are uploading this torrent and which is has its own search engine. now this search engine would help you search for torrents. so this is more of a application side of things, where people are using it to search for torrents and once they download the torrent file, then obviously this is out of picture. so first step is to upload the torrent file to this torrent server. then your torrent server syncs this to its own internal search engine. now you, as a peer who wants to download this torrent, you go to the search engine, you search for the torrent and you get the file. now you, as a peer have that file. now what would you do? now? your job is to first go to the tracker. go to the tracker and ask for the peer list. once you get the peer list, your track, your peer list might have five, five members, 10 members, 50 members, however it may be. you would then talk to each one of them to request for a download and then whoever has this, whoever has a piece of it, can share you that particular piece. and once you have this piece, you would trade the piece with other peers in your network. that, hey, your broadcast information key, i have this, i have this piece. whoever wants it? whoever wants it, take it from me. so there might be a piece p1 with pr1, there might be a piece p3 with pr3. now, p1 needs p3ps, p3 needs p1ps. so they would trade between each other key. whoever wants a piece can just grab it. and this is the beauty of this network: that instead of relying on just one server, that amongst themselves they are only sharing the content. okay, now, these were the key, like this was the key architecture overview of bitter. but just to conclude on our discussion, it's let's talk about cedars and leeches for a minute. so what seeders and leeches are. so cedar is a peer in the network that has the entire file. so someone having the entire file becomes a seeder. that it's not like. cedar is someone who does not need to download anything but it just is benevolent enough to just continue uploading it in the network. so large number of seeders. quickly your file gets distributed in the network. so cdr is appear that has the entire file. leecher is a peer that is downloading the file it. it is having some pieces, but not all. eventually a leacher would have all the pieces and then it would become a seeder, right? so leecher is not just downloading the file but it would also upload the pieces to other peers who wants it, right? so seeder is having entire file and it is only uploading. leachate is the one who is downloading the file and informing other peers the pieces that it has, and once a leecher has entire file, it becomes a seeder, right? these were the four key components of a bit torrent architecture. it's a very simple architecture, like it's all p2p network. so all it has is a huge set of machines to connect to and download pieces and just formulate it out right? the heart and soul of a good bittorrent network are the algorithms that power it, that ensures that that someone does not abuse the system. right, and which is what we would take a look in the future videos. so, yeah, that's it for this video. i hope you understood the bittorrent architecture and the key components in it and some of the design decisions. we'll go in depth into the implementation details of it, on how to write your own leisure, how to ensure that your network is fair and square for everyone and whatnot, right? so, yeah, that's it for this video. if you guys like this video, give this video a thumbs up. if you guys like the channel, give this channel a sub. this was the third video in the bittorrent internal series and i'll see in the next one. thanks [Music] you.