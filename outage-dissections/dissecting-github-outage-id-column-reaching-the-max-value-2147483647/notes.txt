Github Outage Dissection: When DB hits integer limit

Dissecting GitHub 's Outage When Database ID hits the maximum value On the tables May 5 , 2020 . One of with AUTO INCREMENT - ID column reachead the maximum value . CREATE TABLE ( id name Users id INT AUTO - INCREMENT PRIMARY KEY , name VARIHAR (8) NOT NULL 1; → signed has INT on MySQL is 4 bytes 2 range GitHub reached this value 2,147,483,648 to 2,147,483,647 ← its Caelum for - on ID 31 " Installation Token - 2 to 2 - 1 Impact : Actions , Pages Dependabot . When the ID reached the Max value as per GitHub id Inserts started !! failing • • • • - . r Errors thrown : Range Error 2147483647 Note: When I tried Duplicate key Error

What does this mean ? Auto value reached - incrementing stops when Max L , 2 , 3 , 4 , 5 , 6 , . . . . . - 100 , • . . - 2147483647 , 2147483647 2147983647 . . -. , , , Keep getting the same number For MySQL : 2147483647 1- I = 2147483647 to insert the So , it is actually trying / Duplicate Key Error now with the same I☐ again and again t To be honest a very poor error , should have been a special error considering how critical the error is . issue ? No mention How did GitHub fixed the Preventive Measure F¥ "" DB Monitoring service DB 2 Periodically pings and checks the last inserted id ☒ 0133 and alerts when 70% reached

How to mitigate ? Approach 1 : Make ID UNSIGNED / BIKINT Approach 2 : swap the table Approach 1 : Make ID UNSIGNED when table is small 2 you do not use negative IDs " " Range / SIGNED -2 to 2 I Double the : : space - " UNSIGNED : 0 to 2 -1 Steps : Do not lock rows during alteration £ SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED ; ← Do not checke SET FOREIGN - KEY - CHECKS = 0 ; for F. key to do it quick ALTER TABLE Users CHANGE id id IN -1111 ) UNSIGNED NOT NULL AUTO - INCREMENT , ALGORITHM = COPY , LOCK = SHARED t the table with the copy new " " altered column and not do it IN-PLACE

Approach 2 : swap the table like the table but original empty r Idea Create anothe table with : larger ID range Note : This solution would work when can live cuimout old data you steps : Do not lock rows during alteration £ SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED ; ← Do not checke SET FOREIGN - KEY - CHECKS = 0 ; for F. key to do it quick CREATE TABLE users -2 LIKE ← create table users ; empty Make - ID larger ALTER TABLE Users -2 £ CHANGE id id BIKINI 1127 UNSIGNED NOT NULL AUTO INCREMENT ; - ← Set auto Inc - ALTER TABLE Users -2 AUTO - INCREMENT = 214748364£ ; to the next value RENAME TABLE users to users - old , users -2 to users ; ← Rename table INSERT INTO users SELECT * FROM users - old ; t copy old data back