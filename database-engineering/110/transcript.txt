so in this video let's talk about what takes a database doubt uh what do you mean like what do people mean when they say that the database is down um what are quick short-term solutions to get your database up again which means get your applications up once again very quickly by minimizing the downtime and more importantly what should be the long term fixes that we should be doing in order to ensure that a database does not go down again for the exact same reason right so let's jump into the first one okay what takes a database down so a very typical so a very typical structure over here like a very typical high level diagram that we all have seen multiple times is that you have your set of users sitting over here they all connect to a load balancer the so whenever a user fires a request let's say hey i want to load my feed or i want to log in the request the http request comes to the load balancer load balancer forwards the request to one of the api servers the api server then makes a query let's say if we talk about a very simple sql database so api server will create a sql query will fire on the database will get the response and send it to the load balancer on load balancer will send it to the users right so this is a very typical flow that we all have seen numerous times right here one very peculiar thing if you look very carefully is we have taken care of scaling of our api servers like for example if today like let's say today we have two users and if we only had one api server then that would have worked fine but if the number of users increase we would want to horizontally scale our api servers which means more users you want to automatically add more api servers into the scheme of things so to do that we have load balancers auto scaling groups in aws and what not to take care of that which means we have horizontally scaled our api servers as in more number of people more number of request you would be horizontally scaling up your api server so that is taken care of but now if you look very closely your database is intact like your your database might not scale up like you do not typically on demand scale of your database like depending on the traffic you scale it up and then bring it down because it's not that easy it's not that operationally easy so that's where the problem rises okay if you anytime if you suddenly see a spike in your traffic which means let's say someone very famous tweeted about you or your product it will garner a lot of attention to it so like you might see a lot of users immediately flocking onto your website so this is that particular duration where you see a spike in the traffic that you're receiving now what happens when then like it's let's say you were you're having a very good normal day and you suddenly see a spike let's see what happens in this architecture for that so all the requests of all the users coming in after retweet uh after the tweet that a famous person made about you the traffic will reach load balancer the call request will come to load balancer and your load balancer pay like you have horizontally scaled repair servers so if even if large number of users flock into your website the api servers will scale it up so your api servers can handle the request the incoming request that comes to it like like no matter how large number of requests would come to it your epa servers are configured to be horizontally scaled but now if api servers become very high like like if if if they are if basically there are very large number of api servers what happens like they will they are ready to accept the traffic they will accept the traffic but what about your database right all of this every request that comes to our api server will translate into at least one at least one sql query that is going to hit your database so even if you have horizontally scaled repair servers your database is that one stateful component that is not that easy to scale up on demand and scale down on demand so that is where the load on your database increases so with such spikes you are you have configured your api servers to work just fine they would horizontally scale up but your database because it is that single point not really a single point of failure but it's that one stateful component that is not that that easy to on demand scale up and scale down will suffer it takes time for your database to scale up so when you see certain spikes that's where your database goes in trouble and which takes the system down with like which takes the database off so there are few possible reasons on what exactly happens when a database goes down so we'll basically touch upon that so when there is a certain spike in traffic and your database is affected so your database is not able to handle that much of load okay so your database goes down now this is the time when everyone is tensed array your database is not working are you what would happen array my users are not already we are not able to accept payments all of that thing so that's it's a it's a very tense moment on how to get your database back up again very quickly because every single minute of downtime is costing you business so that's where it's it's a it's a situation of panic or what what should we do to get it up again as soon as possible so this is your so getting your database up again is your number one priority at that moment and you have to do it as soon as possible because every minute of downtime costing you business right so let's see what do people mean when they say databases don't you know what exactly happens when people say database is done so first possible thing is your queries are taking very long time to execute very long time so when you say queries like your request came to an api server api server made a sql query and if there are like it if far too many queries hit your database your database has limited ram limited cpu limited disk to play with so which means that because it's at one stateful component it has a limited capacity if a lot of request comes in at that same time it might take your database to run or to it might take time for your database to execute to complete the execution of the queries so like let's say two queries your database can handle very well but what if there are 2000 queries so database in like it will take time for your database your threads on the database to you know uh evaluate and compute the results and then send it to the user so that is where your queries execution will take time second your api servers are not able to create new connections so when people say database is down it they it might also be possible that oh like your database when it's getting like when an api server is trying to reach out to your database your database is not even accepting a new connection so like because hardware is limited you can only accept a certain number of connections onto your database so if you receive more than that your database will not even accept the connections so that's what that also could happen that you have large number of api servers and eps servers are not able to even create new connections on your database third possible reason is your database server is continuously crashing like you would see the database up but it is constantly crashing and you can see it in the logs on what is exactly happening on your database server and you might find your database server is continuously crashing this typically happens when the disk is getting full that your database is booting up but there is no place to store the data your disk is full so that's where it basically is the most common play most common reason why your database continuously keeps on crashing right so there is some either some sort of file file corruption or basically some sort of file file system corruption or it is because of low like very low disk space that database is not able to write anything onto the disk right so in order to now if we jump like basic before we jump into short-term solutions and long-term solutions one very key point that i would want to highlight is you need to have a very exhaustive monitoring on your database very exhaustive because if you do not have an exhaustive monitoring you won't know e what happened like in order to fix your database like like in order to get your database up again you first need to know what happened like if you do not know what exactly happened what what would you fix you're like if you do not have exhaustive monitoring you might just restart your database like that's the that's the basically that's the ground zero of your solution like don't don't do it so unless you're sure hey this is something that would help me get my database up again so that's where you need to know he what is what what is wrong with my database on the first place like what is the root cause of it and then solve it right so that's where you need very exhaustive monitoring into understanding what has happened right so let's talk about a few short-term solutions uh that would minimize the downtime and would get your database up again very quickly so one possible reason of your database going down is because the connections have maxed out which means that because of the hardware that your database has it can only accept a certain number of connections a certain it may be hundred two hundred ten thousand twenty thousand fifty thousand one lakh something but this number is fixed because more than that it cannot even create tcp connections on that machine so your connections are maxed out so when that happens it means that your api servers will not be able to create new connections onto your database right when api is not able to create new connections onto a database so how like even though you have accepted the request from your users it is not getting executed on your database so yeah like your user will see 5x6 some error or worst time out after like let's say a minute they would say timeout key it could not get anything out of your database or or this part of your response so when this happens uh connections max out the first thing that you should be doing is to go and check e which are the queries that are running on my database from a very long time so here the trick is you'd say the connections are maxed out how will i able to create connection onto it so that is where there is something called as a root user through which if you connect so root user is always given priority to connect onto it so in most databases there is a separate set of pcb connections kept unused so that root user can connect to the database like even if a normal user are not able to do so root user will be able to connect to the database to solve this exact same problem so through root user login to your let's say if you're using mysql log into the mysql through mysql console login to your database and then find out which queries are running from a very long time so show process list is a very famous command to do that there are few others but show process list is typically the one that you should be going for to find out hey which are the queries that are running for a very long time which means those are the queries that because they are very long-running queries they have hogged up those cpu they have hooked up those uh tcp connections so you have to kill them as soon as you kill them a lot of short short sql queries will come and solve like will come and execute themselves and basically get the response and go away so killing that queries would free up those connections for other short term for for other short lived connections to create and execute and send a response back right but if you have persistently seen this like connections maxed out one like any way your database is not operational it's down like it might be partially operational but in that case one other way like if the traffic is genuine and you want to handle that traffic one very quick thing although it requires a downtime is to quickly scale up your database so let's say if you're using a managed service let's say by aws like aws rds you can quickly go and scale up your database to and basically make it 2x of the size if you're using 4gb of ram make it 8gb of ram double the cpu whatever the configure is double it when you do that although it requires a database reboot but you are sure that you will be able to handle those number of connections so if it's genuine traffic scaling up your database might not be a bad option because you want to handle it it's a very quick and hacky fix that you can go out when you have a max connection but then you need to be sure that hey i'm see i'll be seeing these number of connections continuously over some time that's why you would want to scale up your database very quickly another short term solution for a problem is cpu operating at 100 which means that your cpu has maxed out few possible reasons to solve that problem like this first of all you need to have a monitoring tool in which you see hey array cpu is is is basically constantly hundred percent so when you know that cpu is constantly under 100 which means that even though your database can accept large number of connections but there is no cpu cycles to execute it because it because the wait time is very high because there are far too many queries that have come in and you're able to handle the connections but you're not able to execute the query so that's where your cpu is operating at 100 and few fixes for that is first of all killing the queries that are running for the long time same solution there uh for the connections max not same solution for cpu maxwell so what like why would you like when you kill a when you kill a query that is running for a very long time what would happen the queries that run for a very long time because query execution typically requires a lot of cpu cycles obviously disc io is there but you will require a lot of cpu cycles there so when you require cpu cycles to solve that particular so to execute that particular query what would happen if a query is running for a long time and if there are such such queries that have either taken log on a database or are basically constantly hooked up and are very cpu intensive kill them it would free up your cpu to do something else so now not just pick any query to kill but find out which queries are non-critical which can be killed just kill them and uh most more often than not it's one of the recent deployments that would have triggered this like check if any recent deployment was done that led to that led to a push of a very inefficient query uh which is getting executed onto a database maybe a few joints here and there which were not needed maybe maybe very poor indexing that might have done on your database like you might have written a query that or someone else might have written a query which is literally scanning the entire table every time it is executed very stupid query that is written so reward those changes quickly identify if there was any deployment that was done and revert the changes very quickly then third reboot the machine it always works to be honest if you are very clueless just reboot the version if you know that you you do not need to scale up and cpu should not be 100 just just reboot it it would take a couple of minutes but at least you'll be able to minimize the downtime and you might see another hiccup but it will buy you some time and if you see a consistent usage of let's say your cpu was always around eighty percent and now it has hit hundred percent where you are not able to execute it that's where now that since you have seen consistent usage of cpu that's why you decide hey now it's time to scale the database up right so permanently scale the database up for that so these are some very quick short term solutions that you have to look out for you would see a lot of similarities but these sort of hacks and this sort of tricks are required to minimize the downtime we are not solving the problem for the long term we are only minimizing the downtime so that our business is back up again because like obviously like people should be using the product like like infrared cost comes the second your usage and your payments and other part your business is more critical than that so you would always want your business to thrive versus thinking hey i don't scale up because it will cost you x money business is more important okay now that we have seen short-term solutions let's move into long-term fixes for that so now you have fixed your database everything's fine the next step is uh you need to ensure that your database does not go down again for that exact same reason right find and fix those things permanently forever right otherwise you your sra team your devops team will be just sitting there solving that problem that same thing same thing goes went down and you know you'll be fixing the same thing involving into your uh into your application teams into that to debug that issue and what not you would want to immediately start working on the long term solution for that to ensure that your database does not go down again for the same there might be other reason for database going down but at least for the same reason it should not go down so let's say first of all what we should be doing is ensure that the right set of indexes are in place this is the most common reason that i have seen your database operating at 100 cpu like if you do not have the right set of indexes on your table that you are querying let's say you have a blogs table and in which there are a million blogs written a million blogs written and you want to fetch all the blogs written by a particular user so you'll fire query like select star from blogs where user id is equal to one two three so when you fire that query if there is no index on user id and you have a million blocks every time this query is fired it will have to scan the entire table so scanning that entire table will require a lot of discard to be done will require a lot of cpu cycles to be executed so query execution time will increase so that's where ensure that you have the right set of indexes in place because if you have if you had an index on user id for the table the query execution would have taken milliseconds if not microseconds to do it so audit the queries and see if you have the right set of index that's where you need to monitor the the queries that are taking a long time on your database to execute and see if it needs indexing of some sort and do that second check the database configuration parameters so every database has some boot up configuration parameters for example here i am taking example of mysql but every single database has some very similar uh flags that you pass in when you boot up the database so if you are on aws rds you would have seen a parameter group this is that so there are few database settings that these these settings come out of the box of database they have some default value but that value might not be relevant for your use case for example i will talk about a few of here so here i have listed five that i have seen in my personal experience that these five were the ones that if i changed my database performance shot up right so uh first one is innodb cmp per index enabled this is in odb like for the mysql storage in innodb the compressions per index enabled so by default it's true you need to i'm not sure by default while i forgot about it but you need to check if you really need compression on index what happens if you if it is compressed what happens if it is not compressed and see if you want to tune that parameter second is commit concurrency so innodb commit concurrency it says that how many threads in parallel can commit at the same time onto this data the max value i think for this is 1000 right but if you'd want like what's your current value what's the value that you desire to have and what kind of impact would it have like you need to load test and test key what is the impact of changing this parameter the third one is the most interesting one innodb flush lock at transaction commit this is something that uh violet's acid properties of your database so what flush lock says is that whenever you make a commit should you be flushing the commit log immediately or every one second like there are settings like zero one and two but what it says is that if you want to synchronously commit the if you would want to synchronously flush the commit log that has made uh uh that was just done onto your database onto the disk right so the commit happened onto the database do you want to immediately flush the commit onto the disk if you do so then every commit that happens onto the database requires a disk right right because it is immediately flashing there so that is where if you do not want to have that sort of guarantee immediately flushing it and you are okay losing out on some data right in most cases it might not be possible but if your database is not going down that often you can still do that so if you do if you want to set the flash frequency to one second so for one second it will bulk up it will put it in the memory buffer all the things that needs to be there in the commit log and then it would flush it so flush on the commit lock happens every one second which means for that one second you are yours you are not doing any disk i o it frees up your database to do something else so to handle large number of traffic you might want to evaluate hey should i have like what should be my flush request should it be synchronized or should it be once every second then similarly there is flush method and there is lock wait time out so lock my timeout is an important one where you say that how long should my transaction be waiting on a lock right which is like on on a lock of on a particular set of rows how long should i wait before i timeout so this is important one because if you have a longer wait time out so which means your transactions will be waiting for a longer duration for a lock and then it will time out so let's say if it is one minute so for that one minute that one one tcp connection for one client is waiting which not only gives poor experience to your user but also hogs up that one tcp connection so you might want to alter this parameter and set it to something that you desire for your application you know how long should it wait if it's too short then your client will see very quick error key a i'm not able to execute it so it it should sit somewhere in between but it totally depends on the application or the service that you are writing okay the next point is checking for notorious n plus one queries this is a very very interesting one because you know we all are recommended to use we all are recommended to use an orm to connect to the database so orm comes up with a particular set of issues of their own because it although it makes life simple for everyone but it has its own set of issues that it comes with so n plus one is a very notorious query you should definitely check out uh you should definitely enable logging onto your database to check if you suffer from n plus one query i will just spend few minutes to talk about what exactly is n plus one problem so let's say you have two tables uh you have blogs and you have users and every blog has one or less every blog has one author right now let's say you are rendering uh 10 blogs like and when you are reading 10 books you want to fetch the details of the 10 authors of those block so how would that query look like you would first like if you are using a very raw orf your ora will fire query like select start from blogs limited and then for each of that blog it will fire one query to get the author id of that block so select start from other where id is something so if you fetch 10 blocks then the next step would be it would just your orm will fire 10 different queries to fetch details of every user separately right so this is a problem of n plus one query so n like one five you you fired one query which which brought you ten and then you had to fire ten queries to fetch the next set of details right this is a classic n plus one problem which could have been solved with joins prefetches and whatnot so whenever you are writing a query like like whenever you are using an orm you need to check how many queries is one orm firing in order to resolve that particular that particular object right so blocks within that blocks author if you are fetching n block uh sorry if you would want to render n blocks into it how many queries does it translate to so enable like in your development environment enable uh the query logs on your orm and see if you suffer from an n plus one query problem it's a very famous it's a very notorious problem but in solving this improves your database performance by a huge margin and it ensures that your database is uh operating efficiently the next like last few things the next thing is upgrading your database to a newer version so a solid example like as a long-term fix let's say you are using like obviously it should not be always database upgrade but and and it's not that easy to upgrade either it's a very long term thing and it's a very big project a database upgrade a database version upgrade so but in if you are using a very old version of your database obviously it's not as performant as what it used to be like it's not as performant as the latest version that is that has been rolled out so an example of that is let's say my sequel 8 let's say you are having issues with replication your replication lag was very high so in let's say you are using mysql 5.5 let's say 5.6 something so you know that if your issue is with replication lag you means you need faster replication my sequel 8 gives you faster injection rate for replication so that you can ingest your data faster so earlier let's say this is how your master and replica used to replicate with like few threads not so performant this suddenly gets enhanced because it has a very fast replication so now it supports more thread in concurrence uh basically more more threads concurrently to answer this uh to basically take care of the replication which means very fast replication you will get right so there are a lot of nuances to take care of like uh do like upgrades are not easy it requires a lot of cross team efforts and what not but sometimes it is worth to upgrade your database to the latest version to gain that sort of performance so it might be one of the potential long-term fixes right and the final thing is evaluate the need of horizontal scaling right like you might just have one database uh in your system but if you have seen a spike evaluate if you would want to have read replicas for your database and move a bunch of read loads on to read replicas versus only master handling all the thing let master only take let master only take care of the rights and not worry about the reads right and let the reads be said to read replica directly from the business logic so that your master is free to handle right so that's where to handle more read load you would want to add more read replicas right but if let's say you have large write load and you know you already had rate replicas to serve read but to support more rights it's not possible to go beyond a certain hardware size of your master so that's where you might want to partition or shard your database and create a mutually exclusive set of shards to handle it to support more right load such that every request for a particular set of user always goes to a particular shard right so each chart is an exclusive set of data like let's say you have you are creating two shots half the data resides with first chart half the data which resides with the second chart in the business logic you can handle key if user if the hash of user id mod 2 is equal to equal to 0 move it to the first chart if it is one move it to the second chart right something around that so this is typically the last stage of scaling on doing multimaster or doing sharding on your database you might not want to do that especially on the sql load but at least you'll read replica offloading the read request at least would help you solve the problem in a longer run added replicas move more critical reads to your read replica and let a master be free up to handle rights and very critical right oh nice so these were few long term solutions that were critical that i've seen in place that solves a problem for a very long time so yeah that's all for this video now you i hope you have a very solid understanding of what happens like why database goes down what happens when database goes down few short-term solutions and few long-term solutions to help you solve that problem in the long run nice so yeah that's it for this one uh if you guys like this video give this video a thumbs up if you guys like the channel give this channel a sub and i'll see you in the next one thanks