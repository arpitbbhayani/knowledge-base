So we all know relational databases provides acid guarantees, but what is i in acid?
Now, what do we mean when we say that, hey, database gives you isolation.
Now, just to clear things up, isolation, like when database says, hey, we provide isolation.
So it's isolation between transactions.
So when there are two transactions running parallelly on my database, what kind of transparency one has over other, that's isolation.
The way database gives you tools to tune that, that is called isolation levels, which you can change.
Now, isolation level dictates how much one transaction knows about other, and given both of them are executing at the same time.
We'll let actual queries to see how this affects.
So there are four standard, like four SQL 1992 standard isolation levels possible.
First, we'll start with repeatable reads.
So the four are repeatable reads read.
First is repeatable reads.
Second is read commited.
Next is read uncommitted and for the serializable.
So first, let's start with repeatable reads.
Now repeatable reads is really interesting.
So what it does is it talks about you, it talks about giving you consistent reads within same transaction.
Let me take an example writing actual queries to help you understand on what that is all about.
So here, what I have done is I have created a very simple database which if I show you, select start from users.
I've created a simple user stable.
Let's do a describe user.
What we'll do is we'll quickly insert just one row in this table.
So now if I do select start from users, I would see one row ID one, name it.
Left and right, left will be transaction one always.
Right will be transaction two.
Now here, first let's start with understanding repeatable read.
So first what we'll do is we'll check what the transaction isolation level, what the current transaction isolation level is.
The current transaction isolation level is repeatable read, which is what we need.
So the command it be fire to get the current isolation level in my circle.
By the way, F fire, I'm using my SQL, right?
So this is all specific to my SQL, but I the concept of isolation level spans to all relational databases out there.
But the demo I'm running on my SQL.
Now select at the right at the right transaction underscore isolation gives me the current isolation level of my transaction.
So let me run it on other session as well.
And both session we see it's repeatable read, right?
Now let's see what repeatable read like what it does.
Now here what it says is that when I am actually reading the data like let's say I have one row.
We saw we have considered one row in the table.
So we have inserted user ID one name is a.
Now here let's say I start to transaction.
Let me set auto commit to zero.
Now if I what auto commit does is in case you are not running inner transaction auto commit automatically commits every single line as in when it happens.
But I'm explicitly setting auto commit to zero in both the terminals in order to ensure that there is no auto commit magic happening.
We'll start right simple queries for what's happening behind the thing.
I'll start my transaction to.
I'll start my transaction to.
I'll start my transaction to.
I'll start my transaction to.
So in both the places both sessions transaction one has initiated transaction to has initiated.
So I've read a row in transaction one.
So I've read a row in transaction one.
So select start from users where ID equal to one I got a this row is read in transaction one now in transaction to I would read the same row.
So both have read the rows both got a which makes sense.
Now what next let's say my transaction one updates the road now in my transaction one I'm firing an update.
So my transaction one fired an update it is yet to be committed.
So now what would happen is if I read the row in transaction one what would we get.
If I read the transaction one I would get the updated value because it is within this transaction you got the updated value.
You wrote you read a you updated now you're reading that row again you are you'll get updated.
But what happens when you read the same row in transaction to given that my transaction one has neither committed nor aborted what would my transaction to see when it is trying to read the same row.
It sees the old row which means that it does not matter.
If transaction one has made any changes unless those changes are actually committed the transaction T2 will not see and it makes sense it's it's basic sense right now right.
But things become interesting what makes repeatable read interesting now with repeatable read what happens is now let's say my transaction T1 commits transaction T1 made the update transaction T1 committed.
Now if I read the row I would get a underscore T1 now comes the interesting part what would happen transaction T1 committed now the actual value of row is a underscore T1 transaction T2 read the value it got a transaction T1 committed now if after transaction one after transaction one has committed if I read the row in transaction T2 what should we get if we fire this we still get a.
This is the beauty of repeatable reads that you can repeat your reads within the transaction and it would give you a consistent view of it because now what has happened is if this would not have been there not rather if you do this now it if it starts seeing the next the new value it seems wrong so repeatable read gives you this guarantees the first read that you do whatever value you see you would continue to see that same value no matter how many other transactions make any changes to that value so it is basically opaque to what has been done elsewhere in the system this is the concept of repeatable reads right now I hope you understand what repeatable is now no matter how many times my transaction T2 reads the same value it would always see this same thing but if my transaction T2 commits transaction T2 never change anything in this row if it committed and now if I start another transaction and read it you get the fresh value so you see how the reads are repeatable and consistent of within a transaction right so this is all about repeatable reads so now let's talk about the other transaction isolation level which is read committed in read committed what happens is when your transaction is reading the value it would always read the latest committed value which means that when my existing when my transaction is running it is possible for my transaction to read two different values for example my first transaction was running it read a particular value while it is rereading the same value again if in between these some other transaction committed then value that it would read would be the new one let me show you an example and see what's happening in this case so you know what I'll do is will just set the isolation level to read committed here you see set session transaction isolation level read committed in both cases I'll just quickly do a select and confirm that it is indeed read committed right in both cases it is read committed now what we'll do is will start a transaction I'll start a transaction T1 I'll start a transaction T2 now I'll my transaction one let me read this value in my transaction one I read the value I got a right so transaction one read the value it got a now let's say in my transaction T2 I fired an update I update the value of that row to a underscore T2 value got updated and as soon as value got updated if I read the value in my transaction T2 I would get a underscore T2 which makes sense now let's say my transaction T2 commit now when my transaction T2 committed transaction T1 is still running it has not yet committed but when I read the value the committed value is a underscore T2 so now if I read the value in my transaction T1 which is still running now what would happen when my transaction T1 is still running in case of repeatable reads it got that consistent view but if I fired this now it gets inconsistent view this is the difference between repeatable read and read committed in read committed what happened is in read committed it read the committed value even if some other transaction wrote that whenever my transaction is reading the value it is always reading the committed value so this is where you clearly see that within this same transaction I have not admitted a transaction at all I fired two reads and I am seeing two different values over here this is a problem why because with read committed you get a little better throughput but the problem that seems is that your reads that you are doing are now inconsistent the next isolation level that I want to talk about I'd like to talk about is read uncommitted so it is much more lenient and read committed read committed what happened is when I read I always read the committed value which means that when my transaction when other transaction committed the value now I'm re free reading it I would always read the committed value even though I am already running a transaction now what read uncommitted does is that I if my other transaction has made any changes to that particular row even if it has not committed I would see the uncommitted changes as well this is called as a dirty read problem let's take a look at what happens when you are like let's take a look at this problem in action so what I'll do is I'll set my transaction isolation level to read uncommitted right which means it is okay for me to read the uncommitted value in both the cases I would do that same thing in both the sessions if I just countervalidate my isolation level I see read uncommitted I see read uncommitted now I'll start my transactions in both the places transaction T1 started transaction T1 started or D2 started right now what I will do is my transaction T1 selects the row from my data is it got a row ID1 name A right now my transaction T2 is actually updating the row to a underscore T2 transaction T2 is running transaction T1 is running transaction T2 has not yet committed anything but because my transaction isolation level is read uncommitted if I read I get uncommitted value so what we are getting over here is we are getting not only the problem with the random with read committed side of things but it was anyway just reading the committed value here we are reading even uncommitted value so because now if let's say make a read again and then if I'm doing some processing on it I'm processing on value A underscore T2 which might be wrong because it is very much possible for my transaction T2 which has made some changes to roll back because if my transaction T2 rolls back I have done processing on the data which is rolled back by other transaction to do something some reasons so this is a problem but it's okay it gives you little higher throughput not significantly higher but it gives you little higher throughput so in order for you it's not it's okay for you to drop the correctness of data in some cases but you need better throughput you may go for this but this is read uncommitted that you are reading even the uncommitted data over here of other transaction so it is possible that the other transaction either commits or rolls back in either case you have processed on the uncommitted data by the other transaction right this is read uncommitted isolation level and here we see the problem of dirty reads right now the final isolation level that I'd like to talk about is serializable so what serializable does is up it's the strictest form of isolation level typically the slowest one as well so what it says it it enforces the serializability what that what I mean is every read that you do is a locking read so when I read a particular row in a transaction other transactions are not even allowed to read that particular thing so it just blocks everything that unless one has done processing it completely then only other transaction would move forward this is very strict serializability that it enforces and you can very clearly see how it would slow things down and it does to be honest it does slow things down right so let's take an example to understand what this is all about so here what we'll do I'll just commit an abort everything that I have so that all the changes are flushed out I'll revert my value to a and oh sorry my bad then I'll do commit okay so let me set my isolation level to serializable in both cases and in both cases it is serializable you can quickly check if my isolation level is serializable oh I just sent it again my bad I wanted to do copy paste isolation level serializable isolation level serializable okay at both places it is serializable now what we'll do like always we'll start a transaction transaction sorry transaction once started or so transaction t2 started transaction t1 started both transactions started now what we'll do is transaction t1 updates the row and update user set name a underscore t1 where I'd equal to 1 it fired then update right now when it fired update when my transaction t2 is trying to read that row what would happen it waits it is strict serialization so unless my transaction t1 commits or rolls back transaction t2 would not even move forward the select statement would not even return anything as soon as I do commit either commit or roll back you'd see the transaction t2 moving forward and reading the committed value in case I would have rolled back the transaction t1 it would have read the whole value here you see very strict serialization in place that you are blocking out every single thing that is out there that when I'm updating something and I'm reading something everyone else is not even allowed to process or move forward along that but just a warning it depends on the storage engine of the database that you are using some minor hiccups or not really hiccups but some minor customization some minor basic behavior changes you can observe but this is a big picture on how the four isolation level determines how reads and writes happen in your system right and I hope this cleared out isolation level once and for all for you folks right so whichever database you are using see the isolation level that are there and just play around with this just one row I just inserted one row one table one basic schema and I just changed it and understand what is happening behind the scenes right I would highly highly highly recommend you to do that and I really just solve it once and for all because this is one of the most commonly asked things that hey what are isolation levels how it actually affects what is prog like what is difference between locking and isolation love you understand what I of acid is this is what I of acid is how your transactions like what kind of transparency that your transactions offer you depends on the isolation level of your transaction right so I hope you found it interesting I hope you found it amusing it is it was really fun for me to basically compile this very quick demo a lot more videos on this database engineering topic will be coming out especially mostly members only video I and again it was fun for me to record as I hope it was amusing as equally amusing for you folks as well once again thank you so much for watching I will see you in the next one thanks a