in the previous video, we took a look at a very simple microsoft garbage collector, and the approach we saw was a simple depth-first search traversal with two distinct phases: mark and sweep. the algorithm required us to pause the program so that we can run garbage collection. this is called stop the world garbage collection, in which a program literally pauses, does nothing but garbage collection. so can we write a garbage collector that does not stop the world and runs concurrently with the program, giving us a massive performance boost? in this video, we take a look at something foundational called tri-color invariant, and the concept we discussed is something that was contributed by dijkstra, who is most famous for his shortest path algorithm. the tri-color invariant allows us to build garbage collectors that run concurrently with the program with very small pause times. but before we move forward, i'd want to talk to you about a code based course on system design that i have been running since march 2021, and if you're looking to learn system design from the first principles, this course is for you. yeah, because this is a cohort based course. it will not just be me rambling a semi-optimized solution, thinking it's the most amazing solution out there. instead, it will be a collaborative environment where every single person who is part of the cohort will can pitch in his or her ideas and we will evolve our system around that. right. every single problem statement comes with a brainstorming session where we all together brainstorm and evolve our system. that's why everyone understands the kind of trade-offs we made while making that decision. instead of just saying, hey, we'll use a particular queue, we'll have the justification why we use only that queue, why we use that particular database, why sequel, why not no sequel? right, how are we leveraging throughput? how are we ensuring that our system scales? that's the highlight of this course. this course is taken by more than 500 engineers to date, spanning nine countries and seven cohorts. right, people from all top companies have taken this course and the outline is very intriguing. it's very exciting. so we start with week one around. we start with the core foundation of the course, where we design online offline indicator. then we try to design our own medium. then we go into database, where we go in depth of database logging and take and see few very amazing examples of data log or database logging in in action and how do we ensure that our system scales through that. then the third week is all about going distributed, where we design our load balancer. i'll walk you through the actual code of of a toy load balancer and understand how tcp connections are managed and how simple it is to build load balancer. then week four is about all about social networks. week five is all about building your own storage engines, like we'll build that intuition on. if you were to ever design your storage agent, how would you do that? right? then week six is about building high throughput system. seven is about building uh ir systems, basically information retrieval systems, and adult designs, where we design our own message brokers like sqs. where we design distributed tasks scheduler. and we conclude the course with week eight, where we talk about the super clever algorithms that has powered or that has made those systems possible. right, i have also attached a video, verbatim as is, from my first code where we designed and scaled instagram notifications. i will highly encourage you to check this video out. right, and now back to the video. so let's start with the recap of the mark and swift garbage collection algorithm, in which we have we the input to our garbage expression is this object reference graph in which we know which object refers which other object, right? so when we have this sort of graph the what markings of garbage collection does is. it splits it into two phases. first is the mark phase. the mark phase: it starts from the root node and sees which all nodes are reachable from it. the nodes which are reachable from the root node are the ones that are live. everything else is garbage. so after the mark phase is complete, whatever is unmarked becomes the garbage. and then comes the sweet place in which all the unmarked objects which are definitely not reachable from the root nodes are marked as garbage and then are. then they are basically cleaned up. okay. so here if we take a look, if we basically closely take a look, every object is in one of these three states. first state is the life state, in which we know that this object is definitely life and is reached from the root, right. then the second is unprocessed. it means that these are the objects which are not yet processed, which means that the the depth first search traversal that we wrote the traversing is yet to reach that particular object. and the third one is processing, in which that we have seen that particular object but are yet to process the child of it, right, so we are yet to complete the entire depth first search on that particular node right? so these are the typical three states in which every object lies in this- uh, this classification or this sort of analogy from a depth first search into this three color variant or this three state variant was something that was contributed by dijkstra. so most modern garbage collectors are actually concurrent. because if a garbage collector is not concurrent, what would happen is we would always have to stop the world for us to run the garbage collection, which would increase, which would have us larger pause times affecting the throughput of our program. so that's where we would want to build garbage collectors that run concurrently with the program. so in order to do this, what we typically, or what dijkstra contributed, is something called as tri-color abstraction, but which gives us high concurrency, which means your garbage collector runs concurrently with the program and within the garbage collector itself, it can leverage multiple threads to do cleanup very fast. it has very small porcelain because it is running concurrently and doing incremental cleanups. it would have very small pause times and is correct. what do you mean by correctness? correctness implies that even though, when we are guaranteeing or when we are having this feature of high concurrency, we would still not be cleaning up the items that are life like. so, no matter what happens, we would always clean up something which is definitely a garbage, right? so what exactly is this tri-color abstraction? so the object reference graph that we just saw, it can be partitioned into three sets, or every object that we have in the object reference graph can belong to one of the three set. the first is the black, second is gray and third is white. so every object by default starts with white, right, and every object is right, which means every object is not processed, right, it's not yet seen, it's not yet traversed. then we have the gray set, which means when the object is seen, which means that we have started a traversal, but we are yet to complete the traversal for that node, which means that we traverse that node, but we- but we are yet to see the, but we are yet to go through all the, all the children's of that particular node. so then that node becomes a gray node and then, once we address all the children's of that node, that node turns black. so black objects are definitely life. gray objects is seen, it's partially processed, but it's not yet completely processed. so that's where they are gray. and then the white one, which are unprocessed, right. so in a typical state, what we see is we have the root list. these are the root variables, or the global variables, or the thread stack which acts as the seed point for our uh, for our object reference traversal. so here, let's say, we have one, two, three, four, five, six, six root nodes. each one of them will point to one object and that would have its own set of children, the, the, the object that it refers, like this object refers to this. four objects, this object, this object refers to these two objects and all. so everything that is connected to this root list is something that you can assume to be life, and everything which is not connected to this root list directly or indirectly will be the garbage. so if we visualize- sorry, if we visualize, uh, the overall coloring of nodes from black, gray and white, what we can typically see is, by the way here, because black on black background might not look good, that's why i'm painting it green, orange and white, like just just a heads up on that. so when we uh visualize this overall tracing based garbage collection, you can see it as a wave of gray nodes- this are the gray nodes- which separates the black and the white, and it moves across your object reference graph so slowly you would see like you'll start all nodes as white, and then the and then the gray wave swoops in behind. it leaves everything black, and then it, then it shrinks everything white into something and then basically it converts everything white into grain, then gray into black. so you can see a very nice wave of gray notes moving in the object, separating the black and the white, until all the nodes turn black, like all the reachable nodes turn black right. so this, although it's not just visual, but this is algorithmically very sound. when you are having this clear distinction between your black nodes, your white nodes, separated by your gray nodes, this clear distinction gives us concurrency. so how does this? tri-color abstractions makes things better. so what we want is: we want correctness, which means that a our garbage collector should never reclaim the storage of live objects, which means that, no matter what happens, i should, or our garbage collector should not be freeing up objects which are referenced by some other object. the variation that we discussed of black to gray, gray to white is something that would guarantee us that. now what? what happens here? again a smaller version of the previous graph that we just saw. we have a root list, we have the nodes connected to it, right, and there is this one subset of graph which is not linked to any node from the root, which typically means this: four nodes which are not connected to the root are the ones that would be cleaned up. other nodes, which are directly or indirectly reachable by the root, is something that is life, and our job is to identify this efficiently and concurrently. so here, what we typically see is all the objects that we have in the heap can be segregated into three sets, and these are mutually exclusive sets, because every object can remain, can have only one color. it's either white or black or gray. so white object, like every object, starts with white. so white objects are the candidate nodes to be garbage collected. by default, every node is garbage collected, right, because we don't know if it's reachable from the root node or not, right? so when we start our algorithm, every node will be painted right, right, and once we know that all the nodes are white, then we start our iteration. from the root nodes first, we mark all the root nodes as grey, and then from grey to black. so once all the nodes, all the root nodes, are marked as gray, then we start the depth first search, then those children nodes. once we have identified all of those tilde nodes and we have started processing them, those children nodes turn gray and the root nodes turn black and slowly suddenly everything turns black. right, so in the white set we have candidates that need to be garbage collected. so then we have the black set, the nodes that have no outgoing edge to white nodes. this, the nodes which are colored black, are definitely the nodes who are the nodes that are live. so these objects are live and they definitely don't have to be garbage collected. right, because they are live and they are referenced from the root node. and then comes the gray set. gray set are the nodes that are reachable from the root node, that are seen as children of some black node but are yet to be completely processed, right. so this gray set is something that sits between the black and the white and when we take a look we see every node will start from the white, will then transition into gray and everything from the gray will then transition into black. right, so gray nodes are something that are definitely live, but they are yet to be completely processed. so eventually every single gray node will turn black, not all white nodes will turn gray and the things that after and when we stop the item, we can stop addition when the grey nodes are, when this set is empty. so whatever is left in the white set is something that can be freed up, right. so what does our garbage collection flow look like now? we pick the objects from the gray set- right, because gray set is the one that we have just seen, we have not yet processed. we have just seen those nodes and we find all the children's of it. and from the white set we move it to the gray set. gray set: once it's complete its children iteration, it will move to the black set, right. so we pick an object from the gray set and move it to the black set color. uh, every single child of the gray, of the node that we just saw, of the gray node that we just saw, mark them as gray from the white set and then move this into black one. so this way we repeat this entire process until every single node from the gray set is complete or is processed right, once the gray set is empty, which means that all the nodes that we have processed, whatever is left in the white is garbage because it was not reachable by anyone from the root. now, what does this give you like? here, whenever our objects are moved from white to gray and gray to black, the algorithm gives us a very important property, and this property is: no black object references white, no matter what happens, because these are three exclusive sets- black, grey and white- and the nodes will transition from white to gray and gray to black. there will not be any node having which is a black node, which directly references the white node. and that is a very important property of our algorithm, because this exclusivity between, or this guarantee of our coloration that guarantees that no black node will ever connect to the white node. it is guaranteeing correctness, which means that because black node is definitely the live node and if it is referencing a white node, if that is not possible, which means that our program or a garbage collection is correct, which means that we would never be collecting an object that is life, right. so that is a very important uh property of our tri-coloration that would guarantee correctness of our garbage collection, right. but why? why do we have to do this like? why, like our dfs was working so fine? why? why do we even have to think about colors and all so here the main critical thing about tri-coloration method is that it gives us concurrency. so single pass dfs that we build with mark and with basically a simple mark and, uh, sweep garbage collection is not fast. we have to stop the world right. so here, when we are re-architecting these things into three different sets- black, gray and white- now you can very clearly see that whenever you are like, you can put as many threads like, let's say, you have basically an eight core machine. you can start sixteen, thirty, two hundred threads that continuously operate on this gray set only, whose job is to pick an item from the gray set, move it into the black set, mark every single child of it from the white side and move it to the gray set. this way you can like with single pass depth first search. you were not able to pull this off, but here you are making your systems reactive right by having this ability where you can run very like. you can run a thread as soon as like, you would have a set of garbage collection threads which are running on this gray area, which are concurrently running with your program. that was an important distinction that we wanted- and as soon as a node enters into this gray set, it is immediately picking that up, moving it into the black set, marking all the child of it from the white into gray right. so this way we are making our systems reactive. rather than running a periodic garbage collection, we can have a reactive system that reacts to whenever a node is added into the gray set, and obviously you would not run it continuously, but after a certain threshold- like, let's say, a gray set has 1000 nodes into it, then you will run a quick cleanup right. so by doing this you are making your systems runs faster on a smaller set of data, rather than doing that complete iteration across all the nodes every time. right. this method of collecting the garbage is on the fly. on the fly is a method that was contributed again from which this striker abstraction is picked up by, basically dijkstra and and leslie lamport- let's still upward- someone who we know from the distributed systems, clocks bay, amazing or like. he has done some fabulous work on distribute system and he has also contributed to the world of garbage collection and three others, uh, the the color of the notes that we like on the fly when we talk about an algorithm which is on the fly here like we with the stop the world garbage collection. what did we have? we used to stop everything and then we ran our mark and sweep. so, as in, we ran the algorithm that found out which objects were live and which objects were dead, and then we cleaned the dead objects or the garbage with on the fly algorithm. what would happen is the mutator thread itself, which means our program itself can start coloring the nodes, as in. as soon as a node and or an object is referenced from another object, you can mark that object as gray. and if your mutator can start and can simplify the coloring part of it, your job of garbage collector becomes very simple. and this is how your, your garbage collection and your main program can run concurrently. where our main program is job is also to color the objects with the appropriate colors in order to quickly uh in, in order to make a garbage collector uh, in order to make your garbage collection very efficient, so that it does not have to stop the world always right. so this is what on the fly, like an idea on the fly- is all about. we'll touch upon on the fly garbage collection in detail in some time, or, or in or in the next video or something, and which is where we would go into how exactly your concurrent garbage collectors actually work. right, we will look at the actual core algorithm behind it, but this tri-color invariant of this three exclusive subset, or three exclusive sets of your all the objects that you have on the heap, paves the way, or it lays the foundation, for us to have a concurrent garbage collector, right? so this was the key idea that i wanted to discuss in this video about tri-color invariant and how it lays the foundation for concurrent garbage collection, right? so, yeah, that's it for this one. in the next video, what we'll look at is we'll look at improving our mark and sweep garbage collection using this tri-color invariant and build a concurrent garage collector out of it. right? so, yeah, that's it from me in this one. uh, if you guys like this video, give this video a thumbs up. if you guys like the channel, give this channel a sub. i post three in-depth engineering videos every week and i'll see in the next time. thanks,