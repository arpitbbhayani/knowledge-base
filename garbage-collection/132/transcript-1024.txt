if you are trying to build your own garbage collector or trying to pick a garbage character for your specific use case, there are seven parameters that would objectively help you decide which one to go for.
in the previous video, we talked about why programming languages need an automatic garbage collection- primarily because engineers are unreliable- and in this one, we talk about the seven key metrics and characteristics of a garbage collector that can help us compare and judge which one is better than the other for a specific workload.
so the seven key metrics of a garbage collector are posting, safety, language, specific optimizations, completeness, throughput, space over it and scalability.
there would be some gcs who are great at throughput, great at pause time, great, uh, great- at safety, but they would be suffering from scalability, they would be very hap, they would have very high space overhead and they might not do a lot of language specific optimization, right.
again, best garbage collector is a myth, right, there is always one which is better than other in some particular use case.
this clearly indicates that, hey, there is no one calculator that is best across all, but every garbage collector will be better than all other in at least one use case.
so, which means that if that is that one use case that you that you direly need, you would have to go for that garbage collector right and most garbage colors now to get the performance.
when you see, knobs like these are all sort of tunable parameters which would help you tune the performance of your garbage collector for the load that you are handling.
but it's when you are picking a gc, when you're tuning the gc to the best performance, you need to know: hey, these are all the parameters that i can do, this is my workload- run the test and see how it is, how it is behaving and, to be really honest, after a certain scale, you, after a certain scale and after a certain stage of your career, you will be spending more time tuning these parameters than coding.
so if two objects are referring to a particular place in memory, which means it's live, so your automatic garbage collection cannot delete this or cannot reclaim this space, right?
there might be, like there are some garbage collectors to get to do better on other parameters.
so everyone wants our program and garbage collection to execute in as little of a time as possible.
so what happens is you're like if i would want to plot a very simple box, plot on if this is the hundred percent of your time, how much time goes into program execution, how much time goes into garbage collection.
when your gc is running, like in most cases, it would be the stop the world gc, which means that when gc is running, your program cannot execute.
they have short bursts of like, they have short cycles, or sorry, they have cycles of short garbage collection and then a long one, right?
your gc would try to run a quick garbage collection in a very short time, right?
that, hey, a garbage collector is complete, where you want to eventually delete all the garbage that is there, or you would want to collect all the garbage that is there in the heap, right, so eventually.
there should not be any object that is deleted or that is not reference, but it's still lying there, right, so eventually it needs to be cleaned up.
pause time is most, or more often than not, when a garbage collector runs it pauses the program execution.
these threads are stopped and only garbage collection threads run right, and when this happens, your business throughput or your program throughput is zero, which is why it's called stop the world.
any infra component, pick any, like specifically java service- you would see this more often- that there are so many stop-loss going high, your program execution stopped, your transaction needs to be restarted and so many things.
so now what happens is when this object movement is happening right, when these objects are being shuffled, the your program execute, because when objects are being shuffled, it's the actual memory address being changed from one to other, and when that happens, what your program like- if at the same time your program is also executing- what would happen is your program will point to some other location which does not exist, and all of those complications would kick in.
if you have a large amount of space available to allocate, or if you're using a sophisticated data structure, you would find which objects to delete in a very short time.
now, which means that if you know, or if your garbage collector knows, that this is the language on which it is running, so it can run that extra optimizations where it can exploit the features of the language, where each of the languages, in how objects are allocated in memory, how are they mapped into memory, or what kind of access pattern do objects we have like if, if a language only has persistent data structures, then every time you make any modification it will create a new copy of the data.
so going through that few hundred gb of heap every time, and if it is every time stopping the world, then your program execution is suffering so much, which is where your gc needs to know, or it needs to evolve itself such that if, even if the memory is high, it is still not doing, it is not always stopping the world for its garbage collection, and it is to do the memory management in the most efficient way possible, because there is a massive space to iterate and go through.