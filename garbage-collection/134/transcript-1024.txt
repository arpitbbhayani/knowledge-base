in this video, we take a detailed look into one of the most common garbage collection algorithm out there, called mark and sweep.
instead of just talking about the mark and the sweep phase of it, we will dive into the details and the nuances of the key decisions made by the algorithm and we'll take a look at two super interesting optimizations that would boost the performance of the algorithm by a massive factor.
similarly, for n global variables you might have, just over simplifying things, that you might have n such small graphs, right, and mark and sweep operates on this object reference graph, if you, if you may call it right.
in the marking phase, it starts iterating through all of these root nodes and sees which all objects are reachable from them.
the objects which are not marked are garbage because they are supposedly not reference anywhere, which has unreachable from the root nodes.
right, and when that is the case, you can your garbage collection can trigger, like in the sweeping phase, it can actually start deallocating the memory that it allocated to those objects before because now they are not referenced.
instead, what it does is it sees what's life and the objects that are not life become the garbage, which is why it is an indirection collection algorithm, right?
on the other hand, it does not know which which object is a garbage, so that's why it has to go through all the nodes, which is okay, these are reachable, so this is not garbage and what is not marked becomes the garbage, right?
so anything related to the program that you are writing is part of mutator thread, whose job is to mutate something in your heap while your, while there is something called as a collector thread, and this collector thread is the one that is running your garbage collection, which is what is called as a collector thread, right?
so to simplify our understanding of mark and sweep and obviously, as we move forward into this garbage collection series, we will.
the simplest way to trigger a garbage collection is when you are unable to allocate a new memory to it, or like when your programming language or when your usual business logic stuff is trying to do an allocation of an object but it is failing.
so, depending on the algorithm that you have plugged in, mark and swap reference counting what not, this would trigger the collection of the dead objects, right.
once it tries to reallocate if it is still unable to allocate, which means that literally there was no garbage available and your program is actually out of memory, right, that's where it might throw an out of memory error, which in most cases is a fatal error.
if it is not able to allocate the object, then to trigger the garbage collection.
once it triggers garbage collection, it would delete this and this because these are dead objects, and then try to really get.
so in this one, what we definitely want to identify is identify all possible root nodes, right, key, hey, these are all the global variables from which i will start tracing all of my live objects, like objects referenced from this global variable, are live object reference.
we will talk about this later, uh, in this particular series, but for now, assume that there is a function called get roots which somehow returns the roots, as in all the roots that you have the references to those objects which are the roots, uh, from which you would have to start your mark and sweep right.
now this is like a work list that you have, in which what you are doing is, once something is marked as life, you add it to the list so that you can visit the, you can visit the, the, the children pointers of this particular reference, of this particular object after some time, right.
what this does is that, for example, as because immediately as you added root into the list, you are immediately invoking the actual marking phase where you would trigger the, your trigger the depth first search algorithm, right, but here we are doing it every time the route is added, because what it would make mean is if, let's say, your, if you are waiting for all the routes to be marked and then you are triggering the marking phase, then your work list might be gigantic, right?
like normal dfs algorithm, for each route we initialize the mark, we we initiate the marking part of it in which we traverse all the objects that are reachable from it, right?
this way, the loop, this process, this depth versus travis, will continue until every single object that is reachable from the graph is reached or is marked, right.
so once we do that, after this phase, all the reachable objects are marked and then we can trigger the next set of process, or the next set of uh, or the next phase, which is the sweeping phase.
right after this step, any object that is not marked becomes the garbage, which is what our indirection collection algorithm was all about, right?
that would iterate over all objects and would sweep out all the garbage out there, right?
so in the same iteration of the sweeping phase, what we are actually doing is we are not only just freeing the object, but we are resetting the mark bit right, so that we are prepared for the next garbage collection cycle.
so this way we are- i look or we are- uh, the sweep phase is not only cleaning up the garbage but also preparing your memory management system or your object references for the next garbage collection cycle.
so this is one super optimization that you can leverage in order to speed up your entire garbage collection process, right, by just flipping uh the meaning of the bit, so that you don't have to reset it every time.