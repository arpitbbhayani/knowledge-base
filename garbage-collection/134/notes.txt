Mark and Sweep Garbage Collection

Mark and sweep garbage collection The core idea : PHASE 1 : MARKING collector traverses throgh the graph of objects and marking each one it finds PHASE 2 : SWEEPING collector traverses all the objects in the heap and deletes that are unmarked the root unreachable from Root : registers , thread stack . global variables Mark sweep is an indirect collection algorithm ↳ it live identifies what's ↳ everything else becomes the garbage Mutation and Collector Threads Usual development stuff garbage collector NEW nm> creating obj m m> COLLECTOR READ mm> Reading obj WRITE rum> writing obs

To simplify , we assume °" mutton threads stop , → ↳ while the collector thread is cleaning up stop the - - ween , , a, ↳ multiple mutation threads . but one collector thread the would increase complexity * we gradually Any atomatic memory management system has 3 tasks : - allocate space for new objects - identity LIVE objects - reclaim space occupied by dead objects when is collector thread invoked ? C) def new : when the NEW command is fired obj = allocate 1) but the natator thread is unable to allocate the object . if obj = NULL : collect C) obj = allocate 1) if obj = NULL : Invoke the " " raise out of Memory garbage collector return obj If still unable to allocate , throw error FATAL ERROR [often ]

Garbage occupied and in - use Runtime tries to allocate → , a chunk of memory but it fails , it triggers a cleanup and retries Phase L : Prepare the root list The garbage collector prepares the def get _ roots C) : list root traversing which it will return ROOTS ↑ identify the LIVE objects detailed implementation The root objects thread stack global wars are , in the future phase 2 : Mark roots and proceed mark roots C) def _ : Each root is marked and added to for root in ROOTS : the list . root . is _ marked = True list add [ root ) . Add the marked root to the mark C) list for further processing start the mark phase • ' * By invoking the Markt ) after each root we ☆ keep the list smaller → lesser load on memory But well can keep out as .

' ' Root Nodes The list we used to put all the marked roots and be other referenced objects can a stack and our marking becomes a DFS Phase 3 : mark For each root we initiate marking in which we traverse all the objects and mark them reachable from it . def Marko : and continue to do this till we have while not list . empty C) : visited and marked all reachable obj obj = list pop c) . for C- obj in CHILD ( obj ) : marked obj.is marked : continue . if already if c. - mark the child obj continue C- Obj . is _ marked =L Add the unvisited list addle obj ) . - child in the list * Any unmarked object is garbage

Phase 4 : sweep The iterates through sweep phase all the objects allocated on the def sweep C) : heap and for obj in OBJECTS : obj marked : - frees the unmarked objects if NOT . is _ - unmasks the marked object free ( obj ) I else prepare them for the next cycle obj . is _ marked = False ☆ Super Optimization : We can save effort to reset marked bit if we can flip the meaning every GC cycle CYCLE 1 Bit I → marked eg : : Bit 0 → unmarked CYCLE 2 : Bit 0 → marked Bit L → unmarked