How to pick a Garbage Collector

Metrics Collector of a garbage Pause Time Scalability Safety Space Overhead Language Specifics Throughput Completeness There are many garbage • ' There best collectors and each is no garbage collector one is superior than others in atleast From a study done on → one use - case by atleast 15% collectors garbage in 2000s Most Gcs lot Xx : Use serial GC * give you of knobs - a - Xx : Use Parallel GC to tune the performance for the load - XX : Max Qcpaase Millis you are handling - xx : ccctime Ratio - Xx : Min Heap Free Ratio be After a certain scale you will spending more time tuning these params than coding .

1. Safety collector must never reclaim the storage of live objects . Obj 1 obj 1 to and obj 2 are pointing my the location mut same in memory . obj 2 be Gc should NOT deleting & Pointers * No Dangling retaining the space 2. Throughput The time spent in garbage collection should be as low as possible . as possible . " " " " User wants garbage collection to execute in as little time program + its and execution Program Execution Gc Most Gc trades performance time in favour of higher program exec . throughput eg : once a while GC Will run an expensive defraymentation phase so as to allocation improve on program 's memory performance . 3. Completeness eventually , all garbage in the heap should be reclaimed complete cleanup in one shot is not desirable nor always possible Hence the word Eventual one cycle ifs many cycles

4. Pause Time Many garbage collectors pause the execution program this should be low possible during cleanup ; pause as as * One of the most important and impactful metric " " Most execution GC do not stop the world of Defraymentation but some limes to maintain the correctness it needs to object shuttling of references stop the world Obj I ✓ Objl he - obj 2 obj 2 ✓ Garbage collectors do their best to reduce the Pause Time but it comes with its own set of challenges & complications 5. space Overhead GC may require auxiliary data structures to track objects and decide efficiently but it puts additional load and consumption memory on To keep check objects already considered Bitmap Tables → a on graphs → To manage q maintain object dependency

6- language specific Optimizations A Gc may provide language specific to optimizations gain that extra ounce of performance eg : some languages are pure functional some languages have only heap allocation some languages may have explicit de allocation - some languages have only persistent data structures its constructs A GC exploits its understanding of the language and to optimize its execution . constant time because how objects laid * some Gc runs in of are out by the memory manager needs to leverage the 7. Scalability Gc modern hardware capabilities to make its execution faster . Servers and 100s GB of heap hence are growing . . . 10s and GC will have a lot of work to do going through this massive heap This would increase the Gc time and hence Gc that always Favoured stop the world become inefficient ↳ some Gcs have evolved 9 become Pause free