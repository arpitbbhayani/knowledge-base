Why languages have Automatic Garbage Collection?

Why programming languages have Automatic Garbage Collection ? Memory management : Our need to allocate objects programs memory and access them to do the job chatting → ← t, game accounting " " variable Every object we see on screen or we use are allocated somewhere in the memory There are huo possible places : I. Stack Heap [ allocation ] 2 . Dynamic memory I, t int a- 10 ; - int * books = malloc 110 * size of ( book)D - - allocates these many allocates size of (int ) on stack frame of bytes of memory on the program heap someone has to clean * When the function returns this mess the variable loses its existence . and is kin of cleaned up

? Why we need Heap in the first place - we can have objects that are too big or too inefficient to be on stack device in kernel eg : object to represent a a in CRM app or customer your To have - dynamically growing objects eg : Arrays , linked list . Trees - To have multiple functions using the same instance of object Function 1 Function 2 - To not pass a gigantic object across function Objects allocated in the heap are always addressed by Reference f. pointer

Explicit Deal location garbage Collection : Programming language provide support for deal locating the allocated object on the heap a f. delete 1) Ct -1 : free C) Ct -1 : free (a) T Explicit Deal location It is good that languages provide a cuay to deal locale but we cannot rely on engineers and developers the the to always free memory allocated Because - they might forget to do so the ceehich deal location is done path in - not invoked is always =- This path is I never taken if l - l : jreelai -

not used ? What happens if an object is not deleted 2 Memory leak ✓ And once this hits 100% Memory consumption to allocate process tries and chart will steadily increase a new object , the process CRASH objects allocated but > not deallocated What happens when an object is freed , but is still referenced ? a Pointer > Dangling b > When we reference an object > that does not exist , it is called C a dangling pointer . If we deference a dangling pointer the results are unpredictable

Best case The process might or might not crash in You could hope that because Pointer of Dangling it crashes Hence we get unpredictable behaviour Because of these reasons, the runtime engines of the programming languages provide a way to do Automatic garbage collection t. I ↳ More reliable Reduces Human Not prone to Efforts human errors