so deployments are definitely a pain if we are unsure about the changes we are releasing, but sometimes, even if we know our changes very well, something weird could happen in our infra. that would fail the entire deployment and put our infrastructure in an inconsistent state. so is there a way to address this? what if we have a place to deploy our changes and validate them before it hits production and we have a super quick way to roll back if something goes wrong? this is the core idea behind blue green deployment. in this video, we take an in-depth look into this deployment pattern called blue green deployment, understand why we need them, what problem it actually addresses, learn how they are actually implemented, talk about its benefits and challenges and conclude with some points to remember when we adopt this deployment pattern. but before we move forward, i'd want to talk to you about a code based course, or system design, that i have been running since march 2021. right, if you're looking to learn system design from the first principles, this course is for you. yeah, because this is a cohort based course. it will not just be me rambling a semi-optimized solution, thinking it's the most amazing solution out there. instead, it will be a collaborative environment where every single person who is part of the cohort will can pitch in his or her ideas and we will evolve our system around that. right. every single problem statement comes with a brainstorming session where we all together brainstorm and evolve our system. that's where everyone understands the kind of trade-offs we made. while making that decision, instead of just saying hey, we'll use a particular queue, we'll have the justification why we use only that queue, why we use that particular database, y sql, why not? no right? how are we leveraging throughput? how are we ensuring that our system scales? that's the highlight of this course. this course is taken by more than 500 engineers to date, spanning nine countries and seven cohorts. right, people from all top companies have taken this course and the outline is very intriguing. it's very exciting. so we start with week one around. we start with the core foundation of the course, where we design online offline indicator. then we try to design our own medium. then we go into database, where we go in depth of database logging and take and see few very amazing examples of data log or database logging in in action and how do we ensure that our system scales through that. then the third week is all about going distributed, where we design our load balancer. i'll walk you through the actual code of a toilet balancer and understand how pcb connections are managed and how simple it is to build load balancer. then week four is about all about social networks. week five is all about building your own storage engines, like we'll build that intuition on. if you were to ever design your storage agent, how would you do that? right? then week six is about building high throughput system. seven is about building uh ir systems, basically information retrieval systems and add-on designs where we design our own message brokers like sqs, where we design distributed task scheduler. and we conclude the course with week 8, where we talk about the super clever algorithms that has powered or that has made those systems possible. right, i have also attached a video, verbatim as is from my first quote, where we designed and scaled instagram notifications. i will highly encourage you to check this video out. right, and now back to the video. so blue green deployment is a deployment pattern that reduces the downtime by having two identical production setups called blue and green. so the idea here is that we should have a place to test our changes, to validate our changes, before it hits production. hey, but this sounds like dev or q environment. are we talking about them? no, right. so dev and qa environment is where your developers would develop or your qa would test, right. and then it comes to your production in a. in a normal setup, what you typically find is that your production account is different from your dev and qa account and very few people, very few senior engineers, would have access to your production setup right, which means that, no matter how well you try, you would never have an identical production setup in your dev environment. for example, you would not want to copy your entire production database into your dev setup so that you have a very quality queue environment, because it would shoot up the cost. it would, more importantly than that, you are having a risk of basically pii leaks, basically personally identifiable information, like your other number or your social security number or your email id, phone number, those sort of links. okay so, and plus your data size in production would be huge. copying it into your dev environment might not be the best decision. so what we actually want is that, after all the testing dev qa is done, when i am taking it to production, i just want to deploy that one last time to just see if everything's okay. if it is okay, then i would want to make a switch right. so this is what gave rise to blue green deployment. so the idea here is to have an identical production setup. so this, the two fleets of our production machines. they are all part of our production account. they are not part of their account. so the idea here would be that whatever traffic we get, let's say, all of the traffic goes through a router. now this router could be an api gateway or a load balancer, right, anything. the the traffic goes over here. now here what we would have it configured as. we would have it configured as either forwarded traffic to the blue setup, which is the old setup, or the green setup, which is the new setup. so what we would do is we would have two parallel fleet of instances running, one running the old code, another one running the new code, and a router would send traffic to either one of them and it would be entire traffic to one. it's not that half of the traffic goes to blue, half the traffic goes to green. no, only one of this two fleet would be live, the other one would be idle. so the idea here is we create a separate fleet of instance, we deploy the new version of our code there, we validate those changes there and once we are okay, we would make that switch from old infra to new infra in one shot. right, this is what blue green deployment is all about now. [Music] during an api or or basically whenever we do normal like why, why did we okay, apart from testing, why, like like, why else do we need this particular kind of setup? give you one very practical example of this. so, more more often than not, we write our normal web servers, api servers, rest api endpoints and whatnot. so what typically happens is, whenever we are deploying a code on a machine, we would typically would want to restart the machine. if not the machine, we would want to at least restart the web server process. for example, django server, spring boot server, or or basically your normal catalina server. you would want to reboot it. so when you reboot it, during the time the reboot is happening, your web server or your api server is unresponsive. so the request that came to that machine for that duration of the time are failing right. so here in, or like so, which means that although we are not having a mega downtime, but we are having micro downtime, like we would see some 5x6 happening, because while this obviously the reboot is fast, it would happen in a second. but for those for- but let's say for that- one second of period, the request going to that server is resulting in a 5x6. a lot of transient errors would come in, something that we see day in and day out, like almost every single deploy. whenever the deployment happens, we see an elevated 5xx, and that's fine. so now bluegrain deployment solves a problem for us, right? so here what we would have is like: why is this problem even occurring? if you think about it, the problem is occurring because your server needs time to boot up. but is it getting the time? no, because we have immediately triggered a deployment, like in- not in case of blue green, like, basically, blue green addresses this problem, but in a normal, classic rolling upgrade, if you would do, we would want to put the changes in the server and reboot it, right. if we do, that server becomes unresponsive for some time. your api starts throwing 5xx right. so micro downtime per server you would experience. so that's where blue green deployment comes in, where we say that, hey, i'll prepare a separate fleet of instances that is warm, all ready to serve traffic. once we know that. then we flip the entire traffic in one shot, right. so the key advantage- is the key advantages that we get with blue grid deployment- is that we get a simple rollout, we get very quick roll back and we get easy disaster recovery. we'll talk about disaster recovery later. it's a very fascinating point, okay. so now enough of theory. how tell me about how it is actually implemented? so, like the how we discussed in the previous video with respect to the canary deployments, here also, what we would need is: you need a proxy seating in between, which can be an api gateway or a load balancer, right? but the idea here is, in order to implement this, what we would have is the first and foremost thing that we would have to ensure is that our database changes, if any, or our code changes, if any, they are forward and backward compatible. we need to ensure that, for example, if we add a new, if we add a new attribute in our api response, we need to ensure that the old version of the app would also work and the new version of the app- all would also work. so, forward and backward compatibility- both we would have to take a look at right. we would have to ensure that that happens, then only we can go for the blue green deployment, because if the changes are not compatible and if you create a separate return, everything would be a mess. don't do that. ensure that your changes- and you would anyway be ensuring that your changes- are always forward and backwards compatible. so that's not a concern, but just be double sure that, hey, i have my changes, which are rough, forward and backward compatible. step two is you set up your parallel infrastructure, which means that your api server fleet that you have that is serving your api request, you create a parallel setup. literally, if you have seven servers in your old setup, you create a separate setup with seven servers in it. now what you do is you take the new version of your code and you deploy it into the green fleet. so green fleet is the new fleet, blue fleet is the old one, right? so what we do is we put the changes into this new fleet that we created. so the blue fleet was on version one zero zero. the green one is on version one zero one. it is still not serving any traffic right now. once the fleet is set up, you may want to just validate the correctness of the new setup with respect, to do a, do an integration test, do a regression test, finals led test, check the core vitals of the cpu: memory and basic- uh, basic non-functional vitals are okay or not. once we do that, we then configure our router, or our proxy that was sitting in front, to now start to transfer 100 percent of traffic from blue to green. we just did all of our setup on the blue, on the green fleet. now what we would do is would configure on the router: hey, now flip all the traffic, move all the traffic to green fleet. this way, your entire traffic gets switched in a fraction of a second from blue to green, from version one zero zero to version one zero one, okay. so now, once you're now, this is where, well up, this switch is actually your deployment, where you're switching from blue to green. once this is done, you would want to still wait for some time, let's say 5 minutes, 10 minutes, 15 minutes, 2 hours, depending on your use case, depending on the criticality, and you would want to check if everything is working fine. if everything is working fine, you then you can then terminate the green, uh, the old infrastructure, the old infrastructure, which is the blue infrastructure, and then your the, the new. the green infrastructure that you just created is now turned blue, because that becomes the old one, right? so that's why it's called blue green deployment, right? so blue is the old one, green is the new one. these are just nomenclatures, but the idea still remains the same: having a parallel setup and then basically doing a flip in one shot. right? so here in case, if something goes wrong, let's say you move the traffic to green and something broke- your roll back is pretty simple. blue in front is already there, provisioned with seven instances, or six instances that you wanted. you can just make a switch in your router. hey, move all hundred percent of the traffic to blue setup, right. so rollbacks are simple, deployment is simple. plus, you would not get any downtime, because now that you have prepared your fleet, uh, and you have provisioned it for the necessary load- because, like seven servers in old, seven servers in you, you are very well provisioned for that- making a flip will not cause any issue whatsoever, right? okay? so now let's take a look at pros of having blue green deployment. although grass is green on this side, but let's still look at on the overall pros that we get by using a blue green deployment. first of all, we just saw how it makes roll backs super fast and simple because we have a router sitting in between. either the 100 traffic goes to green or to the blue, right, so long as we have infrastructure running, both the infrastructure running, we can very easily flip the traffic between the blue and the green, depending on, uh, how stable our release is right. so roll backs: in case of a failure or in case of any issue, rollbacks become pretty simple: version v zero, basically version one zero, one, two, one zero zero. it's just a flip, just a small configuration chain, and within a second your entire traffic would be serving from the old fleet. right, so rollbacks are pretty simple. second, downtime during deployments is minimized. so in most cases the down times are not major, it is minor. minor or basically micro down times where few requests failed during your web server uh reboot or reload during that time. so how are we even solving that problem? because we would already have a separate fleet set up. it would have the time to do a boot up for the api server to load and everything, so it would have that time. so cold start problem is basically: does not, does not exist for these micro down times, right, so incoming traffic, because it is immediately flipped, no scope of downtime whatsoever in flight request can be served, and then the new request can be moved to the newer fleet- right. so this is a very solid advantage that we get out of this. next one: deployments are quick. deployment is just a flip of a switch. you- you take your time putting your code into the newer fleet, but the actual deployment when? so basically, what's the deployment duration? deployment duration is the time when it takes, like the time it takes for you to serve 100 of traffic from the new version of the code. here that happens at the flip of a switch, which is lightning fast. so you don't need to wait for the changes to happen across all the servers slowly and steadily to see if it is working fine or not. this is very fast, right, a big advantage. now comes the main part. disaster recovery plan is super simple. what is disaster recovery? what if something happened in the middle? let's say you deployed your changes. right, you deployed your changes. you have two, two parallel setup, a blue setup, a green setup. you made the flip, your changes went to the green one and you are happy. after two days, what you suddenly saw? you suddenly saw your server started crashing, something weird happened. uh, your, your network of that particular fleet got partitioned and there is a major outage where you are not able to connect to this particular setup of yours. now what you would do is because you, it's expensive, but if you constantly have a blue setup running, then recovering from this disaster is a piece of cake, because if a major outage happened on the new deployment, it happened. it, let's say, after one hour or two, are you? you discovered that my green fleet is not working at all. this is a disastrous situation because you are not able to serve your users and your business is down. you can just make a flip to the blue setup, like the old setup, so your disaster is recovered. so your disaster recovery plan is super simple. you just have to redo like. basically, disaster recovery plan and roll back are exactly same, right, but disaster recovery plan is when something is majorly disastrous, so you are recovering out of it and it is a very simple process for you, right? so blue greens plus, even if you don't have that setup running, like the best cases, you have that blue setup already running and you are just flipping the traffic. but even if, in case, you don't have that because you have adopted blue green deployment, you would have those necessary scripts and automations to take your old artifact and create a fleet out of it. so your disaster recovery plan looks like a normal deployment and would happen very quickly, as we just saw right. so you would have a very simple- uh, you will have a very simple disaster recovery plan and you, like, you'd already have the necessary automations in place because your normal deployment and your disaster recovery looks exactly the same. then your deployments can happen at regular hours. this is a big advantage for a developer productivity because now, because you are creating a totally parallel infrastructure, whenever you are deploying the changes to this new fleet, the old traffic is not getting affected. once you have validated the changes, then you are making the switch. so, so long as our infrastructure can take the load upon a 100 traffic flip, you can do deployments during day hours, like during, even during peak business time, right, although you are incurring a little extra cost of 2x or infrastructure, but that is okay if you would want to guarantee all of this. and then a very interesting, a very interesting example, or sorry, a very interesting advantage of going for bluegreen deployment is that we can debug by a release field, for example, in blue green deployment. what you would have is you are deploying a changes into the new fleet that you created, let's say green fleet, due to any reason it failed. so you like, before even switching the traffic it failed, you would know, because your machines still exist. you can debug on what exactly happened, right. this you can do at other deployment strategies also. but now comes the icing on the kick. you can even do this after you flip the traffic right. so let's say you did the deployment, you put it into the green, onto the green traffic, and then after some time things started crashing because your infrastructure is there. it is not deleted, it is not replaced, it is a parallel setup. you can very well, you will have the necessary files- to debug what happened and how to solve them. you would have all the necessary pieces of infrastructure for you to resolve, or first to debug and then to resolve the issue once and for all. right, major advantage: you get out of this. okay, now grass is not always green. let's check out the possible challenges, not really disadvantages, but basically some set of possible challenges that we would have to face when we adopt a blue green deployment. first and the biggest concern of all is our infrastructure cost would become 2x. we literally have to have two parallel setup of our infrastructure, a blue and a green, the old and the new. if the old setup has new has seven servers, new setup would also need seven servers. so you are literally doubling your infrastructure cost by doing this, at least, if not at least during your deployment time, right? so you first set up, validate, then you make a switch, then you wait for some time- at least for that duration you would be paying 2x of your infrastructure cost. you should be okay with that. if you are not, then blue green deployment is not for you, right then? the second challenge that comes in with blue green deployment is what if your application is stateful? which means that what if your api servers are basically caching something on their local storage and now, which means that if you are having a parallel setup, a green setup, and you are flipping it, your green setup would not have those cache files. it would have to rebuild those entire cache files depending on as and when it gets the traffic. so the statefulness of it is lost when you make the switch, and you should be okay with that. if you are okay, then go for blue green, otherwise you don't have to. the next one is database migrations. this is an interesting one because your database is common here. the first question is: in a blue green deployment, because we are having a separate production fleet, does this mean that we also clone the database and put it one copy in blue and one copy in green? that's an overkill because it would. because as you grow the size of the data would be huge the total cost that you would need to pay, because the database is one of the priciest components in your infrastructure. your infrastructure cost is going to short by a massive margin. plus, when a write comes in the old setup, how would like, for example, you have only been blue- one db in green. blue is blue is getting all the traffic. when the right happens onto the blue, how would the green get that? how would green get that particular right? until the deployment happens? you would have to maintain the sink or something to do that. so that's why you would find in most cases the. the database is common across blue and green, so that we don't run into this issue. but with this there is another issue. what if your the schema changes that you make are non-backward compatible or not, or they are not forward compatible- catastrophic. for example, you change the type of a column in and it is handled in the new. uh, like, for example, you, hypothetically, let's say, you change the type of a column from a string to an integer, right from a string to an integer, and when you did this, uh, the old setup or the old apis, our expected string, the new setup, expected integer. now when you do the deployment, your old setup would start to fail, like if you ever roll back on the new setup would have. like everything should happen as soon as possible, otherwise you are seeing downtime there, like, even though we say that blue green development does not have a downtime, but in this case, whenever you have a stateful database, that would become a problem. so we need to always ensure that the changes we make on to our database schema, they are always backward or forward compatible. if they are not, then you will find yourself in a fix. don't do that, don't do that, always, always, always, even if you don't do deployment, even if you don't do blue green deployment, ensure that your database migrations are always backward and forward compatible, both the next one, forward and backward compatibility of aps. we just spoke about forward and backward compatibility of database changes, which is shared across the setup, but even more than that, we would have to ensure that our api responses are forward and backward compatible. a simple example of that is, say, we add a new attribute in adjacent response. what we have to ensure is that our application, as in if i have a mobile app that is consuming this api, it works even if you have the field and even when you don't have that field. in both cases it should work right. so your changes have to be backward and forward compatible so that when, if you ever need to roll back your end application end user is not affected. the next one: handling shared services across blue green setup is a pain, so we need to be extra careful on how shared services would behave like, for example, authentication service across blue and green. you might see like different api tokens or, sorry, different user session tokens being created and like they are being considered as different users and what not. you need to be extra careful on how your shared services would behave across those two environments just to be sure that whenever we roll back, we are not or will not put our shared services at stake and our data consistency at stake. and final point, a micro point, is that it takes time and efforts to have a blue green setup. like it does with everything else. it takes times to- uh, it takes time to have a barrel setup for a blue green deployment. it's not that straight forward but it's still simple. but you just need to put an extra effort, like a little extra effort is required. so this point needs a mention. okay, so now i went to use blue green deployment. you should be using blue green deployment first of all when you wish to have no downtime deployments. second, you can tolerate a hundred percent instant switch to new infrared version. this is a critical point because what if, like when you, when you make a switch from blue to green, literally hundred percent of traffic will be coming to your green fleet. your green fleet- the servers in the green fluid- needs to be capable enough of handling that much of load. so you need to be able to tolerate a hundred percent instant switch. if that is not there, you cannot use blueprint deploy. third point is when you can bear the cost cost. real-world systems are always cost optimized. like you would always make decisions that you would that would make you pay less or that would make you bill less. so you should be able to bear the cost of running towards of infrastructure, at least during the time of the deployment, and then you can go for a blue grid setup. now, as part of conclusion, let's talk about few points to remember and something a little more cautious on when you're adopting a blue-green different. first of all, you need to have a very solid automation test suite, because you saw that when, like the way we were setting it up, you were setting it up a green fleet. we are going to deploy the new changes, we are going to validate them. we need to have a solid automation test suit so that we can very quickly test if the setup is correct or not, because otherwise the manual qa would require a lot of time for it to even validate and the and the testing might not be thorough. second, we have to ensure forward and backward compatibility of our code, of our database, anything and everything that is connected to the system. third, before we switch, we have to have to have to validate the setup, because otherwise, without validating the setup, if you are directly triggering the deployment from blue to green, you might see a downtime, because that's what we tried to reduce it in the first place. but so that's where validation now, this addition does not. it basically just does not mean the correctness of your code, but also correctness of your setup, security practices, uh, your database configuration. what not just check the correctness of the setup and then you would want to flip the switch? and finally, points to remember again reiterating the same thing: infra cost will shoot up, so, which means that you have to have to have to minimize the time for which you are running 2x of infrastructure. if you can minimize, like minimizer time would be few hours, or rather one hour before the actual deployment happens, to do setup and validation, and all during the deployment you make the switch. next one are: you would want to spend time looking at the production. hey, if everything is working fine, do i need a roll back or not? so try to minimize this time to as small window as possible so as to reduce the cost. so yeah, that's. those are the four points to remember whenever you are adopting a blue green deployment. and yeah, that's it for this video. so, yeah, if you guys like this video, give this video a thumbs up. if you guys like the channel, give this channel a sub. i post three in-depth engineering videos every week and i'll see in the next one. thanks, saturn.