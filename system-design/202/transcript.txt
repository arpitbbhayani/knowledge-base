so a classic challenge that comes while building Instagram or Google photos is about quickly and efficiently serving and rendering a large number of thumbnails in this video we take a look at an ultimate Hack That Dropbox used to very efficiently serve a large number of preview thumbnails by streaming the response from the servers using chunk transfer encoding but before we move forward I'd like to talk to you about a course on system design that I've been running for over a year and a half now the course is a code based course which means I won't be rambling a solution and it will not be a monologue at all instead a small focused group of 50 to 60 Engineers will be brainstorming the systems and designing it together this way we build a very solid system and learn from each other's experiences the course is enrolled by 800 plus Engineers spanning 12 codes and 12 countries ingenious from companies like Google Microsoft GitHub slack Facebook Tesla Yelp Flipkart dream11 and many many many more have taken this course and have some wonderful things to say the course is focused on Building Systems the way they are built in the real world they will be focusing heavily on building the right intuition so that you are ready to build any and every system out there we will be discussing the trade-offs of every single decision we make just like how you do in your team we cover topics ranging from Real Time text communication for slack to designing our own toilet balance side to cricbuzz's live text commentary to doing impressions counting at scale in all we would be covering roughly 28 systems and the detailed curriculum split week by week can be found in the course page linked in the description down below so if you are looking to learn system design from the first principles you will love this course I have two offerings for you the first one is the live cohort based course and the second one is the recorded offering the Live code base course happens once every two months and will go on for eight weeks while the recorded course contains the recordings from one of the past cohorts as is if you are in a hurry and want to learn and want to binge learn system design I would recommend going you for the recorded one otherwise the Live code is where you can participate and discuss the systems and its design life with me and the entire cohort the decision is totally up to you the course details prerequisites testimonials can be found on the course page arpitbani dot me slash masterclass I repeat ad with many dot me slash masterclass and I would highly recommend you to check that out I've also put the link of this course page in the description down below and I'm looking forward to see you in my next cohort so on Dropbox we can upload photos videos and other media objects right and when we open that corresponding folder what we see is we see series of photos over here so they what we typically see is we see thumbnails and when someone Taps on it we see the enlarged photo right so if you have hundreds of photos listed there you would want to fetch you need to fetch those explicit images from the back end right so how do you get that you cannot just send your entire photo there because it would be too slow your your photo might be 2mb 3MB 5 MB big but your thumbnail can be 1 KB or 2 KB big right so given that you would first want to show a large number of thumbnails and then when user Taps on it you see you show them high quality picture right so this is what is the very interesting challenge that comes in because now imagine this you are using this app you are using Google photos you're using Dropbox and you are constantly scrolling to go to the photo of that particular time that you are hunting and as you scroll you would want to see every single photo's thumbnail so that you can make a decision okay hey this is the photo that I want to open you are not scrolling slow you're scrolling very fast given that you would want this part to be as efficient as possible so how do you go about it okay before we jump into the solution before we see what Dropbox data how Dropbox solve this particular problem assumption the Assumption here we are we are making an assumption that this isn't like this is an old Hack That Dropbox applied but the solutioning is amazing right and it is happening over HTTP 1.1 the solutions that we discuss is specific to http 1.1 if you are already using HTTP 2 the approach to solve this problem is very different right because HTTP 2 by default supports what they try to build over HTTP 1.1 right and other systems apart from Dropbox what we can build through this is Google photos Instagram and Flickr wherever you see a lot of photos or videos that you need to scroll you can leverage this particular system out there or this particular hack out there before we do that why is this even a problem right the answer is pretty simple answer is request queuing so typically what happens is that any browser slash client that you are using that has a limit that has a limit on how many maximum concurrent TCP connection that it can create to a particular domain this is what browser imposes so that people don't abuse their system so the idea here is or the or the constraint here is if you are a client if you are a mobile app or a browser at Max the request that you can make concurrent request is six so what would happen is if you are making a lot of request all the requests would be initiated they would be queued six would be picked and then when any of one of them completes the next one would be picked from the queue then when someone else gets complete the next one gets picked up right but at Max that would be six now this number varies from 6 to 8 depending on Chrome Firefox Safari everyone has different number but there is some limit to that so for example let's say we have 60 photos of equal size and time to fetch one photo or any photo or any one photo is exactly the same so when your browser fires now let's say you are rendering that you got 60 image URLs right and you are loading it in IMG tag so what would happen is your browser would make 60 request one for each IMG tag to get the photo now when you are making 60 request add that exact same time What would happen six would be initiated other 54 would be waiting then when one of those six gets completed then one of those which are waiting gets picked up and gets executed right so if I assume that every uh the time to fetch every photo or every thumbnail is exactly the same it would happen first six would take place then second six would go in then third six would go in and so on and so forth and finally from 55 to 68 would be making the request and you'll be rendering the photo right why so here you see a lot of request just being waiting to be executed right that is where the problem is so can we solve this problem can we somehow find a way to solve this particular problem again just iterating back this is an HTTP 1.1 based solution in HTTP 2 a lot of things have changed and a lot of other approaches can be used to solve this exact same problem right okay so what's the solution the solution is batching but how do you batch how do you batch those things so key point to note that what we are dealing with is thumbnails thumbnails are small thumbnails are not 1mb thumbnails are few KB bits at bags right so what do you do is you expose an end point whose job is to do a thumbnail batch and in which it accepts paths which are comma separated path strings to those particular thumbnails so for example if you want to load thumbnail uh one two three and four you take those path and pass it through this HTTP 1.1 rest endpoint that you are requesting for thumbnails of this four photos right the idea here is pretty simple you made a bulk request so instead of so the idea is you might think hey but I'm adding it to IMG Tech no you are not in some API response you would get all image URLs this image URLs you would use and basically pass it through this particular end point from this end point the job of this endpoint is it would make a call to the server server would get this image Parts all of this image parts and server would send you the actual image data in the response right but how how does it do that so first of all thumbnails are small right so and when we are transmitting the image we can transmit the image in base64 encoded form so it's actually binary data but the encoding that you are using is base64 encoded which means it makes it safer for us to transmit it in HTTP response level use it as a string if you would want to right and the response looks something like this it's HTTP 1.1 200 okay content type is text plane transfer encoding is checked will look at this extremely important part transfer encoding chunk and then you have some image data now here if you look at this this is an image data of like here you can see a number 0 and then data colon image slash JPEG base64 and some bytes which is base64 encoded string so the idea here is that you requested four images image one image to image 3 image 4 right so here what you are returning back is you are returning back for each of that image you are returning the base 60 for encoded part of it so in this one HTTP response you are sending four Images data the actual image you are sending in a base 64 encoded form now this image can then be used by your client to render it at that particular place right so here you got a you got a batch request from your client around four paths your server is going to your storage be it S3 beat any place it goes to the storage gets that image data right gets it actual image converts it into base64 it encodes it into base64 and then sends it back in this response but now here you can very clearly see that if I request let's say 10 images in batch I get this then you your server got the request then you are making calls then you are making 10 calls or waiting you are making 10 parallel calls to S3 waiting for it to send you the response then you are encoding it putting it over here and then sending it back as a response it would be too slow and your response would be too big can you do something better this is where transfer encoding chunk it comes in it's an extremely beautiful piece of wow it's extremely beautiful piece of optimization supported natively by your browsers now now let's spend some time understanding what this is all about so transfer chunked encoding so if you are using HTTP 1.1 this is a this is a massive massive feature when you are transferring large files right so to have your client understand that you would be sending response in chunks you have to pass this response header called transfer hyphen encoding chunked and the idea is the core idea behind transfer encoding chunk is like for example your server doesn't know how big the response is right so what typically happens is you send a request server computes the response server sends the response while sending the response the server knows how many bytes it has to send it sends the content length header in the response itself so that your client also knows that these many bytes are coming my way but there are cases where your server doesn't even know how many bytes it would need to send a classic case with images that we were talking about that you requested 10 images your server doesn't know how much how many bytes would it require right so that is where you use something called as chunked transfer the idea here is that instead of sending just one response to the client you send response in chunks as and when you are getting something you are sending it back to the client right and because you have specified your transfer encoding as chunked it means that in every response that your server is sending so here it's not that your client is sending the request and server is sending the response it's simple your client sent one request this one request that contains all the path right and now your server would be sending multiple responses to the client will say how is it even possible remember HTTP connection is based on top of TCP right TCP connection is established if no one terminated the that connection server can send the response to the client over this correct which is where your client is not breaking the connection because your encoding is set to chugged your client would terminate the connection when it receives the termination chunk right so the idea here is your client send a get request with a lot of parts in it your server went to the storage to get as many images as it can and as and when it is getting image it is sending it is creating a chunked response out of it and sending it to the client right so for example in the first chunk response it got like it made let's say you requested for four image i1 I2 I3 I4 right and your server when it got this request it made fourth it created four threads and tried to fetch four images in parallel one of the thread responded which was i3 what server did is it created a chunked response and sent I3 to the client then server got I4 then Server create another chunked response and send it over that exact same TCP connection to your client and then server got i1 and I2 so it put both of them in that one response and send it back one server knows that hey it wanted to fetch four Images it sent four Images now its job is done so that's why your server would send a null response so it would send an HTTP response having the null byte in it marking that your chunk transfer is now done and now you can stop sending or now your client can terminate the connection right this is the idea this is how chunked encoding works now here you need support from your server so every single uh so basically every single language that you are using it supports partial streaming of responses to the server or twos or to the client right so in node.js you do res dot send you can invoke res dot send as many times as you want and your server would keep sending the response to the client similarly with golang similarly with python using core routine similarly with Java as well every single server supports every single programming language supports a way to send chunk responses right because at the end it is just a TCP connection you can invoke send as many times as you want but depending on the framework that you are using you need to see how to do partial streaming of responses right once these images are received on the client or these responses are received on the client side so how how is every single response looking like every single response has like every response has multiple lines each line contains an index for example if I send request for T1 T2 T3 T4 image one image to ms3 image Port I would send that hey for index 0 which is the first image this is the base64 encoded thing for index 2 this is the base 60 for encoded string right so when you get when your client receives a chunk when a client receives a partial HTTP response other client would do it would know that hey for this Index this is the one so it would go to that corresponding IMG tag in that SRC attribute of it it would literally replace it by the way in case you don't know in SRC tag in SRC attribute of your IMG tag you can pass in an HTTP URL or any URL you can pass in or you can literally pass in this base64 data as is this form a data caller image slash jpeg semicolon base64 comma your base64 encoded image and it would render that image as is hey this is this is how you would be building this part if you're using apps some minor things here there would change but if overall the essence would remain the same that you are sending requests in bulk your server is fetching multiple images in parallel as in when it is getting this image it is creating this chunked response and sending it back to the client once all the images are sent then your server sent General request or sorry it sends a null response your client then terminates the connection right now with this streaming that we just saw what's happening is we are preventing head offline blocking which means that even if I get request for 100 images my server is not waiting to get response from 100 images if it got response from 2 it would send two to the client it would got response from 4 it would send four to the client right this way what happens is you are not waiting for all of them to be fetched from your S3 or from your storage and then you compile one gigantic response and then send it back to the client that is the power of chunked responses with this chunking what is happening is even though your server doesn't know what's what's going to be the total size of it it does not have to buffer all the responses it can send whatever it has handy it is sending it as one HTTP responds to the client back to back back to back until all the things are done and then your server sends a nothing right amazing amazing amazing simple optimization that is all right using something that the specification says it has but not a lot of people are aware of it right so chunk transfer encoding is something that you can very easily try out on your local you don't need multiple servers to mimic this particle very easily build this and see this in action right and I would highly highly highly encourage you to implement this beat node.js beat golang pick your favorite language implement this you'll learn so much about your response the importance of response headers importance of request headers how to build this particular service extremely simple hardly take you two hours of your time to implement this but again urging you to implement this to get a much deeper and better understanding of this right so yeah that is it that is it for this one if you guys like this video give this video a thumbs up if you guys like the channel give this channel a sub I post two in-depth engineering videos every week and I'll see in the next one thanks [Music] thank you