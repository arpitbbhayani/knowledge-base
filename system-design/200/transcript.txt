so notifications are extremely crucial for fintech companies as it is a way to notify a user about an incoming transaction hence it becomes extremely important for companies like Razer pay to ensure that the notification is delivered to the user within a certain amount of time in this video we take a detailed look into how Razer pay scale the notification systems and look at their high level architecture and key design decisions they made along their way to ensure that they always meet their slas but before we move forward I'd like to talk to you about a course on system design that I've been running for over a year and a half now the course is a code based course which means I won't be rambling a solution and it will not be a monologue at all instead a small focused group of 50 to 60 Engineers will be brainstorming the systems and designing it together this way we build a very solid system and learn from each other's experiences the course is enrolled by 800 plus Engineers spanning 12 codes and 12 countries ingenious from companies like Google Microsoft GitHub slack Facebook Tesla Yelp Flipkart dream11 and many many many more have taken this course and have some wonderful things to say the course is focused on Building Systems the way they are built in the real world we will be focusing heavily on building the right intuition so that you are ready to build any and every system out there we will be discussing the trade-offs of every single decision we make just like how you do in your team we cover topics ranging from Real Time text communication for slack to designing our own toilet balance side to cricbuzz live text commentary to doing impressions counting at scale in all we would be covering roughly 28 systems and the detailed curriculum split week by week can be found in the course page linked in the description down below so if you are looking to learn system design from the first principles you will love this course I have two offerings for you the first one is the live cohort based course and the second one is the recorded offering the Live code base course happens once every two months and will go on for eight weeks while the recorded course contains the recordings from one of the past cohorts assets if you are in a hurry and want to learn and want to binge line system design I would recommend going you for the recorded one otherwise the Live code is where you can participate and discuss the systems and its design life with me and the entire cohort the decision is totally up to you the course details prerequisites testimonials can be found on the course page arpitbani dot me slash masterclass I repeat arpitbani dot me slash masterclass and I would highly recommend you to check that out I've also put the link of this course page in the description down below and I'm looking forward to see you in my next cohort so notification systems are primarily or outbound Communications for example smss emails push web books and whatnot now you'd see why a company like Razer pay a finance company or a fintech company would want notifications the address is pretty simple for example if there are two people A and B and a and uh a made a payment via razor pay and it has to reach the B so B is running a business B is using razor pay a is the customer a made the purchase now razor pay needs to send a the email about the about the invoice as the confirmation of the transaction and it wants to send a post notification to B it might also need to invoke these web hooks so that these external systems are integrated through it works just fine for example we want to send a slack notification via Web book a reserve we would need to call webbook of B to do that so this is where sending notifications become extremely critical for finance companies now think about it if you are receiving a payment but you have not received the notification you would be wondering hey where is that gone because that person is calling you that hey I may don't know I sent the payment you say I didn't receive it because I never received the notification so you'd have to open the Razorback console to see that hey you indeed received the uh the money right so this is what this is why it's extremely important to maintain an SLA now here let's see how this payment system is built at Razer pay right now or rather the existing flow and then how they made it better right so first thing that existing flow is pretty simple so what happens there is some once the transaction is done it comes to the API server API server pushes a message to sqs sqs is a message broker it gets that event now sqs from this a bunch of workers take up this event the workers are the consumers of sqs they take up this event then they send it to executor now these two can be same code base I'm just drawing it as two separate diagrams because that block showed us two separate diagram but this could very well be one same code base on one same machine running right so workout takes it to executor executor now this is where one very interesting design uh like one very interesting design decision comes in executor sends the outbound communication so if it's SMS it sends the SMS if it's email executor sends the email and whatnot but it makes an entry for that in the MySQL DB now you'll think hey why would a company need to store the messages that I sent to the user in a database the answer to this is very simple given that it is transactional information when a sent money to B and if a is not receiving a message or a B is not receiving a message that's a problem so because this is where the heart and soul of a good fintech company lies in that they give the best user experience now to do this to ensure that the message is definitely delivered to A and B they have to keep a track of it in a database so that in case there is a error in sending it a scheduler can pick that up and do the retry so that is where you would have a scheduler component whose job is to pick the message that needs to be retried and then reschedule it in sqs and so that it can be consumed again so this is the idea this is why this is the current architecture one very interesting design decision that we saw is about persisting the outbound Communication in a database so that because here uh guaranteeing or basically a guaranteed delivery is essential right so here what was the problem with this architecture the problem with this architecture was that their P99 drops from two second to four second for more than 1000 transactions per second so as soon as their systems hit the limit of 1000 transactions per second the response time of this the SLA drops from 2 second or the P99 latency is dropped from 2 second to four second which is not acceptable like for them it's not acceptable for most companies out there is good enough but for them it's not acceptable they're very high standards so this is where they thought of hey let's rebuild right so now what were the existing challenges with scaling challenge number one read load on the database during Peak because now here if you look at it in order to send the notification it would need a lot of information about the user the transaction the sender email SMS sorry email phone numbers Web book and whatnot it would need that plus the database the database in which they are storing this communication that needs to be scaled and what not so at Peak this is what starts to choke off and that's the problem so and this is not just the right level also the lead load because a lot of other systems are also relying on that right so reload would increase during the peak you'd say hey let me add a read replica but at scale even adding a read replica even doing a lot of vertical scaling might not be the best decision because it would not work right and the next thing is scaling the workers you would think that hey when I'm getting a lot of messages to send I'll just add more workers to that but if you think about it if you add more workers to that what happens to your database so database has limited i o operations which means that let's say your database can only handle 300 concurrent connections and if you have 500 workers this wouldn't work your workers would choke off and your database would be over by that problem so that is where when you think of horizontal scaling it's not that your database you can in one click scale that up and it would scale immediately it's not elastic because databases are not elastic that's where what you have to do is you'd have to ensure that your database is very well provisioned if you think about it that your database needs to be very well provisioned the problem with this comes in is that you would have to have a very heavily provisioned database so you are provisioning a database for the peak that is not happening anytime soon that happens once a while problem so you would be losing money you are not making a cost efficient architecture so that is problem with scaling second problem is scaling third problem with scaling is surge during special events for example during IPL matches during festive Seasons during some year-ending where a lot of people are making transactions a lot of transactions go through days I pay this is where they see searches happening in their system handling them becomes a pain so these are the three key challenges challenges that comes with searches now let's see how they re-architected their solution so their rear architecture happened as a very nice incremental changes now let's go through that Journey first prioritizing incoming load so in the first architecture that we saw it was straightforward we have to send a notification it comes to sqs worker picks up executor sends a notification and entries made in the database dead dead simple but if you think about it not all notifications are equal because transactional information much more important than marketing pushes because razor pay through their challenge like they can also like a business can also send notifications to their customers like maybe reminder for payment and whatnot right so some messages are much more important much more critical than some other type of messages then second is one type of notification should not affect other for example if I'm sending my transactional info let's say if I'm sending a big marketing push a big random that I'm sending here please like a let's say a happy New Year message to all the customers now when this is happening you're like imagine Razer by sending this to 20 million people but during that time let's a transactional message needs to be sent now with this queued up this 20 billion message queued up when would that one transitional message get its chance so that is where one type of event like making other Starve is not a good design so that is where the solution to this is queues so what Razorback it is they created separate cues with different priorities so p 0 q p one q p two Q so P0 is the ultimate priority P1 is a default qp2 is the marketing burst queue right so what you can do is your API server when it pushes the message instead of pushing it to one SQL like only one sqsq API server needs to decide hey this is the type of message now this type of message does it deserve a P0 a P1 or P2 apsr would know hey if it's a transactional let me send it to b0 if it's a burst marketing message let me send it to P2 the default priority stays at P1 right so that is how you would get that separation of concern you would always ensure that a transactional message is always picked up is very efficiently picked up as soon as possible and is sent right even though a big marketing push is happening you are not getting affected your transactional messages are still going but if you think about it you would also need a rate limiter because now what could happen is that each queue event and customer to ensure that you are giving consistent performance or rather consistent experience to all of your users all of your customers you need to ensure that even if one of the cons one of the customer is abusing it let's say a customer sent notification and that let's say that customer has a million customers hypothetical situation and if that customer sent large number of messages like a bulk happy New Year message now what would happen is that because of that one customer one because of that one notorious customer every other customer is getting impacted even though it sends to P2 all of them all the other messages sent by other customers are getting they they are basically getting start so that is where what there needs to be is there needs to be a rate limiter module this rate limiter module would have per customer per queue per event type rate limits and if it is within the limit it goes to the queue if it is not which means you are not directly dropping it you will be putting it into a separate rate limited events queue and then you would be slowly processing it so you are having three cues for three types of priority and a fourth queue for all the events that breached your rate limiting right this is a very important design decision and now the second thing is that your database we just spoke about in a couple of minutes back that how database is becoming a bottleneck so now this data is the main the mySQL database in which the executor was updating it the entry the scheduler was reading from it to see if any messages needs to be redried now this database becomes a bottleneck because this database cannot scale so why it was not able to scale because our rights were being synchronous if I add large number of workers let's say if I had 500 workers if my database only handles 300 iops like rather 300 concurrent connections what would happen is because it has limit of 300 I cannot scale my workouts more than 300. but I need to support that many so what do you do so what they did is they started writing to the database asynchronously and this is what their high level architecture looks like where you have your user you have your API server you have your rate emitter rate limiter all the notification events goes through rate limiter rate limiter knows hey where do I need to send it like it does the rate limiting check and then it pushes into either priority zero Priority One or priority 2q and if it is rate limited or which means that particular event user consumer breached it and everything goes into this rate limited events queue from where a secondary consumer might pick that up and then once it hits the worker it goes to executor now this is where the change is happening from the executor instead of executed directly writing to the MySQL DB executor pushes an update to Kinesis Kinesis is a message stream similar to Kafka it pushes a message to kindnesses and then it writes to mySQL this way your executor is not synchronously writing to the DB your DB can still remain and small your DB does not need to be humongous right because it does not need to handle large number of right load it can consume the events slowly and steadily from kindnesses and make the updates right and even your retries are not very fast like it's not very frequent sorry fasting very frequent retrace frequent your retrace could be once every two hours so in two hours your messages would definitely be consumed from kindnesses right and then your normal scheduler flow Remains the Same so whether scheduler picks up from the MySQL and sees what which messages needs to be retried and it pushes them back to the sqs and that's how this normal flow happens but so this is where that one bottleneck that one I O bottleneck of your database is solved by not writing to the database synchronously but rather asynchronously so executor writes to kinosis kinases rights to the database but one key important design fragment that we have to think about is observability like unless we knew that which component is the bottleneck how are we going to optimize on it right so that is where for a notification system having an end-to-end visibility is extremely important the first thing that comes is that you need to have ample amounts of dashboards like you may use graphene or any of your favorite visualization tool to see and constantly monitor what's happening then set up the right set of alerts so if any message breaches their SLA that should be an alert then look for anomalies see if a customer has just sent message to a million people or not if there are animals track them so that is where you need to have this exhaustive tracking happening in the system so that you can take those calls because your rate limiter also needs monitoring every single system needs monitoring you need to constantly check for you need to constantly monitor for the health checks of your worker executor scheduler so that you if you don't know if your executor is down then your message messages in your SKS would continue to pile up and that is an extremely poor user experience so you need to have exhaustive monitoring health checks everywhere then success ratio which means that out of 100 messages so just a sample out of 100 messages or rather let me be explicit how what percentage of messages were sent within one second within two second within three second within four seconds depending on what their SLA is right if I think if I say four second is the max that they can go to they need to see this distribution so this kind of success rate needs to be there and just to ensure the overall SLA are they meeting it or not they need to have a very clear visibility of it and these are the factors that goes in designing real systems where you think about cost at every single stage you just don't drop boxes you think about implementation you think about cost you think about observability you think about stability of the system and that is how razor paid designed a rather re-architected their notification system and this is what you would see at most companies out there just minor glitches or minor changes here or that but overall architecture would still remain the same and that is it that is it for this one I hope you found it amusing I did I thoroughly enjoyed it when I was reading through the rain through their engineering block so great if you guys like this video give this video a thumbs up if you guys like the channel give this channel a sub I post three in-depth engineering videos every week and I'll see in the next one thanks a ton [Music] [Music] foreign [Music]