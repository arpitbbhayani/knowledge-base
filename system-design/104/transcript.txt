[Music] so we all use whatsapp uh one really neat feature that uh actually whatsapp provide is an end-to-end encryption uh what does this imply is that any message you send over whatsapp to your friends can only be read by your intended friend and no one else can read that not even whatsapp servers right uh this is the notion of an of having an end-to-end encryption in this video we'll be understanding or rather implementing a really really really simple version of this into an encryption scheme this is nowhere close to how whatsapp facebook messenger or signal app actually does it but it would give you a fairly neat idea on if we were to implement it how we could do that right so uh what do we have we have two parties a and b uh trying to have a chat uh exchanging messages uh this is an unencrypted channel uh you can assume it's whatsapp or for the matter any communication channel since it's unencrypted it is susceptible to a very famous attack which is the men in the middle attack so anyone can sniff uh the channel and can extract the information out of it right or worse can actually alter and pretend to be someone else and then send a message so this is really bad for any messaging system right so as part of solution what needs to be done is we want to have some sort of complete privacy so how do we ensure that so a very basic criteria that we want to satisfy is that any message sent by a intended for b can only be read by b and vice versa so message sent by b intended for a can only be read by a this are the basic two criteria that we want to fly by the solution to this problem is a very simple yet effective cryptography method called as public key cryptography what it does is what it has is rather it has a combination of public and private key one really interesting of one really interesting property of this is that message encrypted with the public key can be decrypted by the private key okay a message encrypted with the public key it cannot be decrypted by the public key right but a message encrypted with a private key can be verified by public key okay which means that if i encrypt a message with my private with my uh so if i encrypt a message with someone else's public key only that party's private key uh someone having access to the corresponding private key can decrypt the message right so this forms the crux of this end-to-end encryption right so now what we have is the two parties that we have a and b they have each have a public key and a private key so the public key as the name suggests is publicly accessible to everyone while the private key stays locally secure it is not even uploaded to the server right so the private key is kept secure on your local so if you're using whatsapp this sort of private keys hold is is held in your mobile not even with the whatsapp server so this private key has to be kept like really private uh the flow is very very simple uh so a wants to send message to b a encrypts the message with b's public key because a does not have access to b's private key but a does have access to b's public key so a encrypts a message with b with b's public key now this message post encryption becomes really scrambled right so the plain text gets gets encrypted and now it's unreadable uh now this scrambled message uh which seem which looks like garbage is sent over to b and now what would we do we would use its own private key to decrypt the message right so b in order to extract the raw text out of it will have to use its own private key on the scrambled message and extract the original message from it really simple right so this sorts of solve the problem uh of having a raw text message being sent to another party and only uh so and the message can only be read by the intended party right this solves the problem but there is this one catch the catch is how does b be really sure that the message is really sent by a right anyone can masquerade as a and send message right how does b ensure that the message is really really being sent by a the answer is very simple add a digital signature right uh remember about the the public and private key concept what we did was uh what i said was that a message which is encrypted by a private key can be verified by a public key right so now what i can do it is if now the flow may we add one more step where the first a encrypts the message m with b's public key right and now what a would do it is a would create a very teeny tiny digital signature out of hash of the message and uh will sign it with its own private key right because now what would happen is ace public key is publicly available now this since this digital signature is signed with a private key and this digital signature is attached uh to the message so now if you see in this diagram uh what i've done it is i have the message m encryption we get the scrambled message and we had this this this teeny tiny blue colored signature which actually piggybacks along the message right so uh now the scrambled message along with this digital signature becomes your message that you send across and to create this digital signature you don't really need to use the entire message you can hash the message and create a really tiny signature because all you have to do is just verify we don't really care about anything else and now once this message is received by b b would first of all verify if the message is really sent by how it would do it it would use a's public key to verify we won't be able to decrypt the so b cannot decrypt the digital signature right we can just verify if the signature is indeed not meddled with right so someone in the middle has not altered the message uh or uh has not has not done anything funny with the message right in order to just do that what b would do it is we would verify the signature on the message and if the signature verification holds true and it is indeed sent by a b would then decrypt the message using its own private key so it would take up that scrambled message part out of uh your message plus signature and it would use it it would decrypt it and and obviously since b has its private key the original raw message was encrypted using these public key so now b's private key can decrypt it right so now b is not decrypting the message and can and will extract the raw text from it bingo so now we have also solved that other problem now that we have really established a total we have established total privacy let's see how it fits into the scheme of a chat application like whatsapp so uh what happens is without any privacy or without any encryption along the path the flow is you have a raw message m which a has and a wants to send it to b the message is sent over an unencrypted or an on or an insecure channel to api server api so the whatsapp api uh takes that message stores is in the stores it in the database and forwards it to b so if you see along this entire state the message is nowhere encrypted and even in the database you have the raw text stored right but most of the protocols or most of the servers now use ssl or basically https what it would what it provides us it provides us with the transport level security so now a raw message m with a when a makes an api call to whatsapp api server using https along those transport layer the things are encrypted okay so the message the m gets automatically encrypted because of the tls because of that https it is encrypted and sent to api server but api server the ssl certificate is uh ssh certificate is breaks at api server or privately at the load balancer level and but the road raw text is accessible by the server and on the database it still stores the raw http raw uh text message now what happens is now this message is forwarded to b now since the channel between api and b is also https the message would be encrypted with a very separate key as compared to uh what was used between uh a and api server so now the raw message is still stored at the server but an encrypted message is forwarded to b b decrypts the message and we receive the message so over here the encryption and decryption was taken care by https we did not do anything explicit there right but this is not an end-to-end encryption why because the raw text is still accessible by the apis or if you see the database here it has an entry of raw text messaging because the database because api server so your your https tls broke at the api server and there the entire raw request was accessible which is how it stored the raw text onto server which is why this exact this is not exactly an end-to-end encryption as a solution to this problem what we do it is the approach that we discussed where we encrypt using where a encrypts using b's public key and b can decrypt it its own private key what happens is a encrypts a message with b's public key adds the digital signature and this is transmitted over https goes to api server which stores this really this this encrypted message along with the digital signature into the database and this is then forwarded to b and then b first verifies the digital signature uh ensuring that it is intended by uh it is indeed sent by a and then it decrypts the message and gets the text back right so this is exactly how and by the way in the database you see over here what we are storing is we are storing an encrypted message now along this entire journey the raw text message is only either available to a because a has set it here or post decryption at b nowhere else in the path is the raw message accessible right so this is what an end-to-end encryption looks like now how will user get each other's public key right so private keys obviously everyone has it but how will they get access to public key so sharing a public key is okay because that's why they are public here you need them to encrypt right and uh when a new contact is added to the list you can uh along with the metadata information of a profile this public key can be attached to it or it or there can be a separate service that serves the public that holds the public key you can call it as a key distribution center having all the public key with it so typically in a json structure you can have name and a public key attached but do a and b get each other's private key hell no because it defeats the whole purpose so private key has to be kept private not even on the whatsapp server but locally on the phone right so public key made accessible really simple but private key has to be stored locally so where exactly is private key stored locally so just to read it and where where is public key stored it can be stored on whatsapp server whatsapp's database or a different service no problem there uh the solution that we discussed right now is a really really really simple version of how you can ensure an end-to-end encryption it's to be really honest this is not even one percent of what whatsapp signal or the facebook messenger actually does a protocol that they use is called as a signal protocol which is which which powers the which powers the signal messaging app it's really powerful uh it's unfortunately it's so big that it that we cannot that it cannot be covered in this in this particular video uh we'll be trying to cover it in some future one but to give you just what it does is it it literally encrypts every single message with a different key just imagine the complexity at which it's working it it is encrypting message all the method now let's say you have basically thousand of chat in one session every single chat every single message in the chat is encrypted with a different key and this key is derived from a double ratchet which means you have some sort of you can think of it like uh having like uh two cogs and upon sending every message it it it goes to the next one upon now when b sends any other message it it it then clicks next so it's like deriving one key from another and using it to encrypt it's really interesting thing uh it uses it uses something called as a triple diffie helmet key exchange and does four key exchange to create a master it's it's it's a really interesting one it's a little complicated but it's a fun read i'll try to cover it in some time in next or in future videos but uh it's really fun read uh just google about the signal protocol and you'll you'll land up with a lot of videos and especially its research paper so yeah basically that's it for this video uh i hope you uh i hope you found it amusing on how to implement a very simple version of an end-to-end encryption in any chat message yeah so that's it for it uh i hope you like this video if you do give this video thumbs up uh if you find this content interesting subscribe to the channel and i'll see you in the next one thanks