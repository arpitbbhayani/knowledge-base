so authorization plays a critical role in ensuring that the platform is not abused. for example, Instagram ensures that if an account is made private, only the people allowed can see the post from it. such granular, fine grained Access Control requires an extremely robust and flexible authorization system. in this video, we dive deep into how Airbnb achieves this through its in-house service named image, and explore its architecture and key design decisions. that ensures robustness, extensibility, availability and ability to scale to millions of users concurrently. but before we move forward, I'd like to talk to you about a question- system design- that I've been running for over a year and a half now. the course is a cohort based course, which means I won't be rambling a solution and it will not be a monologue at all. instead, a small, focused group of 50 to 60 Engineers will be brainstorming the systems and designing it together. this way, we build a very solid system and learn from each other's experiences. the course is enrolled by 800 plus engine, is spanning 12 codes and 12 countries. Engineers from companies like Google, Microsoft, GitHub, slack, Facebook, Tesla, Yelp, Flipkart, dream11 and many, many, many more have taken this course and have some wonderful things to say. the course is focused on Building Systems, the way they are built in their real world. they will be focusing heavily on building the right intuition so that you are ready to build any and every system out there. we will be discussing the trade-offs of every single decision we make, just like how you do in your team. we cover topics ranging from Real Time text communication for slack to designing our own toilet balancer, to cricbuzzes, live text commentary to doing impressions counting at scale. in all, we would be covering roughly 28 systems, and the detailed curriculum, split week by week, can be found in the course page linked in the description down below. so if you are looking to learn system design from the first principles, you will love this course. I have two offerings for you. the first one is the live cohort based course and the second one is the recorded offering. the Live code base course happens once every two months and will go on for 8 weeks, while the recorded course contains the recordings from one of the past cohorts, as is. if you are in a hurry and want to learn and want to binge on system design, I would recommend going you for the recorded one. otherwise, the Live code is where you can participate and discuss the systems and its design life with me and the entire cohort. the decision is totally up to you. the course details, prerequisites, testimonials can be found on the course page. arpitbani dot me slash masterclass. I repeat at with many dot me slash masterclass and I would highly recommend you to check that out. I've also put the link of this course page in the description down below and I'm looking forward to see you in my next cohort. so only checking for authentication is not enough when we need granular access control that defines who can do what on our platform. let me explain this to you with three simple examples. so let's say I do not want someone else to be able to edit my LinkedIn post, right? so I need an answer to this question: can user one edit post P1? if yes, then that user should be allowed to do that, otherwise no. second is: can user YouTube access the Wi-Fi information of a property P2? let's say you are Airbnb and you don't want people to access Wi-Fi information unless they have made a reservation on it, right? so that is a sensitive part. you want authorization, because authentication cannot solve this problem. right. on top of authentication, you did authorization that. am I authorized to access this information? third, a little more complex example: let's say we are in Google Drive and can user u3 read file present in a folder shared with group G3? now, that is much complex example, right? so if you are part of a certain group, then you, and if someone has shared the file with this group, you should be able to access that, something around that right now. given this, given such complex thing, how do we address this problem? right, we need a way to design it very robustly, very flexibly on low level side and on High level side. now let's go on a journey. let's say we first just have monolith. we do, don't go into microservices based right away. let's say we just have monolith. now this authorization part is very simple in monolith because it's part of everything, is part of the same one code base that you have. you may split, you may still have multiple modules, but this authorization part can be very basically, basically very nicely modeled either as a separate module or you can put this check at the beginning of every function, but it is just a simple function invocation for you to ensure authorization, right? but things become very interesting and slash complex when you hit the micro Services part. when you have a bunch of micro Services, then what you need is. you need a central authorization service so that that becomes the source of truth that every other service relies on. so if I want to check if user U1 can edit a particular post or not, it should be very easy for me. I would just make a call to this Central authorization service and it would give me true or false. as simple as that. now what we'll do is we'll go through the architecture and key design decisions of a centralized authorization authorization service at Airbnb named him Aji. this entire thing is taken from airbnbs engineering blog, which I've Linked In the description down below. highly recommend you to check that out. right, for this service, for himeji, an authorization is modeled as a tuple, a tuple that contains three items: first is the entity, second is the relation, third is the principle. so entity is something on which you are defining authorization on. so, for example, on a particular post with id123 on comment, this is an entity, right, relation could be right. so is someone able to write on post with id123 in the comment field of that post, right? and then principle is the actor of it, like who has that privilege. so, for example, U, colon one, two, three is a user whose ID is one, two, three. so let's say, user ID 123 has the right privileges on post with id123 on command. so user123 can write comment on a particular post. this is what this Tuple signifies, right? so this is how you are representing your data now, how it is actually written and represented, let's let's take a look at it. so in database, when you're studying. obviously, you can store it in any database that you want, but a simple way to visually see this sort of relation is something like this: entity hash relation at the rate principle. this is how you can denote it while you are explaining, writing and even storing in some cases. so this information is stored in database as a tuple: entity hash relation at direct principle. so, for example, if I would want to write it same information, I would write it something like this: post, colon one, two, three, colon, command hash, write at the rate user123, which means that user123 has write privileges on post with id123 on Commit. okay, now here you can very clearly see that entity that you have is not just one ID. instead, entity itself is a three-fold information which contains an entity type, which is post, entity ID, which is post ID, and an optional part of that entity. so on post, you might have title description comment like: share something around that, right, so you can Define that that is a part of that entity and this is optional. okay, now we have defined this part. this is how it is represented. you may store exactly as this in the database. you may split and store. implementation is up to you, right? okay, now Here Comes an expert. how do we Define rules on this? now, you can like, imagine you would. if you just write tuples like this in the database, the problem that would start to creep in is writing one Tuple for every single permission for every entity would make your data explode. and because if you're storing just this thing, like, there would be so much of tuples like this that you need to store, for example, here, if I am the author of a post, so I would be able to read the post, I would be able to edit the post, I would be able to read the comments, I would be able to edit the comments, I would be able to like the post, and now creating these many tuples for me is such a big pain, right? so instead of that, what we Leverage is: we leverage set theory, we leverage transitivity. so, for example, what do we typically say. we typically say that a user is able to or a user has right privileges on a particular post or on a particular entity- implies that a user can read or write to that right. so write itself means read or write and owner means read, write and owner privileges. so, similar to how write is read and write, owner is read, write and owner privileges. so this way we are defining transitivity in relations. now, for example, on a listing on Airbnb, let's say you have listed your property. so on that particular listing, what we want to Define is we want to Define this exact same thing: right for a particular listing, the right relation, right. so the right relation on a particular entity is a union. union implies either A or B, then it is true. so think of it like a, think of it like a Boolean or right. it's a union of right and owner. so anyone who has owner privileges or who has right privileges can write on a particular listing. make sense then for read. it is: anyone having read privileges or right privileges is or can read the particular listing now with because of this right, right itself is defined as Union of right and owner. so this goes transitively, which means that when we check for read. when we check for read relation on a listing, we check for Union of read and write. and write itself is a union of right and owner. so by transitivity, owner can also read, write and anyway has the owner privileges on it, right? so this way we can check this information. now let's see how it gets evaluated. now, so, say, user123, user123 is owner of listing one, the database will have one entry, which is listing colon 1 hash owner at direct123. that's it database only has one entry for this because user123 is the owner of listing one. now, given that, say, we want to check, can user123 read this particular post? now what do we do? we have rules defined, right. we can Define custom rules on all the entities that we have on listing. we have defined those particular set of rules. now let's see how that gets evaluated, because we are checking if user123 has read privileges on listing one or not. how this will get evaluated is we are evaluating listing colon 1 hash read, right. so on listing one, does user ID one, two, three, uh- has the read privileges or not? now listing colon or listing colon 1 hash read gets evaluated as a union, as a union of read and write. so what do we do is we check for read privileges on it and we check for right privileges on it. but right itself is a union of right and owner, so we check for write will be evaluated as Union of right and owner. now this would lead to evaluation of three queries on our database. first is listing colon 1 hash read at the rate user123. does this entry exist? because read is Union of read and write right. so the first query that would go is listing colon 1 hash read at the reducer one, two, three. this entry does not exist in the database. remember. on, the only entry that exists in the database is listing colon 1 hash owner at direct user123. only owner exists in the database. so now, this is the first step would be fired. the second that would be fired is listing colon 1 hash right at direct one, two, three. because the read is region of read and write. write is Union of right and owner, so listing colon 1 hash right at the red user123. this also does not exist, so this returns false. the third is listing colon 1 hash owner at direct user123. now, this exists. this is the only entry that exists in the database. this returns true. the union evaluates to True, which means the output of check would be true. now, because a database contains this entry, the check of listing one comma, read comma- user123- evaluates to true right. so this is a very straightforward implementation of this. now, here you can see how beautiful this, how beautiful this definition is, because now you can add to any custom roles, any custom relations that you would want, without having to hard code that information. everything is configuration driven. you can Define the, you can Define as big of a hierarchy as you want, and then it is just said theoretical or a set theory based evaluation engine that would evaluate this. and what you are doing is for the particular entity that you are checking, you just have to check for this entry. so, whatever the entity hash relation is append at the rate, the user in action or the entity in action or, sorry, the principle in action- you just check for existence of it in the DB. that's it. such a simple system to build. right now things get complex because now there are cases where your access to something depends on existence of some other entity. I'll give an example. for example, if you are Airbnb, you don't want people to access the location of the property until they have made the reservation. so once they have made the reservation, then only you wanted them to know the location of the property, for example. if you want to do that, right. so now, who can read the location of the property? people who are owner of that property can read it, or people who have reservations on it. now this, you can model it in a business logic and fetch the reservation and do that and see if it is hard or not. like that complex party. you can do otherwise. you can write a rule, something like this: now, this is very beautifully written rule. now let me walk you through that. so now, what do we know? read on a particular listing. so listing location. read is a union of owner relation and existence of this entry. now, what is this entry? so here, what we are defining is either user has owner privileges or this entity exists, or this entry exists in the database. what is this entry? this entry is listing colon dollar ID. now, this is a rule that they have written, through which whatever is in question over here, the ID gets replaced over here. so listing column, because we are checking for listing in one listing colon 1, the ID would become a listing colon one. so dollar ID would be replaced by one hash reservation. so you would have a relation on this listing. there is a reservation relation to a particular user, right, you would have something like that, but then instead of user ID you would have a reservation ID. so which is what you are doing? is you are checking for existence of reservation over there that does this like: is the reservation for this user exist or not? so what you are doing is you are using references over here. so listing dollar ID hash reservation at direct reference reservation, colon dollar rid hash guest. now, slightly complicated to understand, but not so much either, right? so what are we doing? so we are defining this Rule now, let's say: now we'll go through evaluation and see how this gets evaluated, you'll have a much better understanding of it. so now, let's say, in my database I have three entries. first entry is that listing colon 1 hash owner at direct user123, because user123 is the owner of listing one, which is what we have first entering the database. second entry in the database is listing colon 1 hash reservation at the rate reference reservation, colon 500. so let's say someone booked a reservation, let's say user 456 booked a reservation, so they would have a reservation ID. now this reservation ID is linked to a listing, so listing has an owner. listing has a reservation with some reservation ID. reservation ID is linked as a guest to a particular user. right, this is what the hierarchy is. now what do you want? we want to use our 456, who has guest relation with reservation. so reservation colon 500, guest at user colon 456.. now, reference: reservation confined is what you are storing in the DB, because it's a reference that you are storing for the reservation in the database itself. now, how do we evaluate this? now, let's say we want to check if user 456 can read listing listing colon 1, colon location. so listing colon one column location is: can user access location of listing with id1? now, here, user does not. this entry does not directly exist in the database. if it would have, it would have directly returned true, but it is not stored. so, which means that this needs a detailed evaluation. now, how this would get evaluated. first of all, this is the principle that we are checking things for. this is the entity, this is the relation. now, the first query that would be fired because we are doing a read on it. as per the rule, read is a union of owner and listing. so the first query that would go is listing colon 1 hash owner at direct user, colon 456, because that is a principle in action. we are checking for read privileges, uh, but we cannot check for read priorities. they are going through the rules that we have. we are first checking if it has owner privileges or not. that would return false, right, because that entry does not exist in the database, right, this one? your owner is with one, two, three and not four, five, six. so that does not exist. so that returns false. the second is this: now, look, now, look carefully exactly how that is written, which is what is checked in the database for existence. so listing colon dollar ID. now, dollar ID will be replaced with the entity in action. this is the like. basically, this is the nomenclature which evaluation during evaluation gets replaced. so listing colon one, because the listing ID 1 is in action here. so listing colon 1: Hash Hash reservation: hash reservation is what we are checking. and then we are checking: add direct reference of something. now. now let's see what this is all about. we are checking for reference of reservation colon dollar rid hash guest. now, if you look carefully, this requires another evaluation. now, this would be evaluated as: because the principle in action is user colon 456 because that has the reservation that we are checking for that particular user here. so what do we do? we check for reservation colon dollar rid hash guest at the rate user colon 456, which is what gets over here. we check for this: reservation colon 500 hash guest at direct user colon 456, and this entry exists, this 500, this 500 C. this entry is because user for ID. so user ID 456 has guest relation with this reservation ID. right now this gets replaced over here as a reference where over here. reservation at direct reference of reservation colon rid. now this is where it gets replaced, right. so now what do we do? we check for listing colon 1 hash reservation and then a reference of reservation colon 500, because that gets replaced after evaluation of this. so here what we are checking is reservation colon rid hash guest direct user colon 456. that would exist. so reservation colon ID, like rid, will be replaced with 500 and this is what we would be checking when we are evaluating it. so reference bracket: reservation colon 500 and this: that entry exists in the database. so this way this would return this entry exists. so this 500 replaced over here and it would check for that reference to exist, that entry exist. so because it's a union, any one of them exist. final thing exist and this is how that gets evaluated. this check evaluates to slightly complex. highly recommend you to go back, look through it. it's very simple to understand. it's extremely simple system, but just takes slight more detailed evaluation steps to understand how you write it right. but it makes it extremely robust and flexible, right? so again, just one quick line. repeat for that, this inner segment gets evaluated. first, reservation colon dollar, rid hash guest. it checks for any entry that matches this, right, it checks for that. so, reservation colon dollar, rid hash, guest at the rate 456.. this is what it would match, because you just cannot match only this part in the database. it needs completeness, right? so what you would check? because you are checking for NTT, for, sorry, you're checking for principle four, five, six. you would check for reservation colon dollar, rid hash, guest at direct user, direct user, colon 456. that entry would exist because that entry would exist. this dollar already would be replaced with reservation ID, which is what you have written. so it would be replaced with 500 goes over here, which is what we are checking: reference of reservation colon 500. and then that entry exists. because this exists, listing colon 1: hash reservation reference bracket: reservation, colon 500.. because this exists, this would result to true and a revaluation completes too. true, it's very simple to build. it's very simple to understand. just just take that step back and go through it step by step. right, okay, so this is the low level design part of it. but this makes your architecture so simple and so fast, because what happens is you are just doing a simple key lookups, nothing fancy, yeah, just key lookups. that's what. that is exactly how you can implement this and normal string match here and then string replace that you are doing over there, nothing more, nothing less. it's extremely simple, right, which is the beauty of it, because simple systems K, right, and this is how they have defined this schema, your rules, your language to query it and the evaluation part over here: extremely simple. so this is the entry and this is how the evaluation happens, step by step. right, okay, now let's jump into the high level architecture for this. now, high level architecture for this is again broken into three layers: the first is the orchestration layer, second is the caching layer and third is the data layer. so we'll start step by step. orchestration layer. so the orchestration layer is the one that receives request from the clients. now your client can either do or read and basically check for, uh, the existence, or check for the authorization, or it can do rights, where it is updating the system for new relations that are created. so whenever a user purchases something or, sorry, whenever user reserves a property, entry needs to be created. all of that. so there is a right flow and there is a read flow. the right flow is what directly writes to the database. the database would be a sharded database. you can use MySQL to store this particular information, right. so you store it in a sharded, normal relational database, because it's again just one column that you are storing and some extra information here and there. so you store this directly into this persistent layer, right. the read, however, does not directly go to the database. the read goes through a cache because you can very clearly see that once your relation is created, it's not going to frequently change. so you can very well cache this information in your cache, making your reads faster. so when your client makes a read, the read comes to your read, your read, your imagery read set of servers. it then contacts your Imaging cache and says if your entry exists. if it exists, well, in good, it returns it. otherwise it goes to the database, populates the cache and goes it like classic cache implementation, right, okay, so what orchestration layer does? now let's go step by step. what orchestration layer does? orchestration layer receives the request from the client. it forwards the request to the cache using consistent hashing. now this is where consistent hashing comes in. now, here your cache is. obviously you cannot just have one cache server. your data is huge. imagine the scale of Airbnb. your data is huge, so you would have a set of nodes that are acting as your cache. but now, when you have that, where should you forward your request? to which cache server should you forward your request to? which is where what they use these? they use consistent hashing because they have a ring, or rather they have a set of clusters and consists, and consistent hashing helps you determine data ownership. it does nothing else. consistent hashing helps you determine data ownership. so image reads uses consistent hashing to understand which of the cache server should it go to. it goes to that reads the data. if it has it, well and good. if not, it goes to the database as a fallback and then read the data populate in the cache and responds back to the user, right. so image lead need to know the consistent hashing so that it can forward a request to the corresponding cache node. so it does that. then it computes the response as per the config, like the evaluation that we just saw, and it responds back to the user right. second is the caching layer. now, caching layer of this has a 98 percent of hit rate, which is insanely high and amazing to see. so this caching layer is basically sharded and replicated. so what do they have is they have a bunch of cache nodes. they are trying to aim a very high cache trade so that their reads are much faster. because they are doing that, they have a sharded setup which is exclusive subset of data and they are replicated across nodes. so that's why they need consistent hashing to forward the request to node. in case one of the node goes down, some other node can takes it, can take its place or rather can serve the request, right. so they have that sort of consistent hashing based structure over here where you have a set of nodes to take care of the data, right. that is your cache layer. now comes the third layer, which is data layer. now data layer is your persistent, is your persistent layer, which is what would be your source of Truth. so, in case all of a cache server goes down, that your everything will be fall back to your Charlotte database. this is your classic data layer. you can Implement with any sharded database, mongodb, MySQL, pick your favorite to implement it. right, but a key part is- and obviously, your data, because your data is huge. you would have a sharded database here as well. right, you would have sharded but persistent database which acts as your source of Truth. now comes an interesting part, because the system is Cash heavy: 98 hit ratio. what if? what if user just changed or user just, let's say, user reserved a property and just canceled the reservation? now, immediately you would want to revoke all the Privileges of that user. for example, user was able to access the location of the property. now, user should not be able to do that, which means whenever the data is changed in the source of Truth, we need to invalidate this cache, not the entire cache, but just that entry. so what do we do when anything changes in this DB? a mutation is triggered and an event is sent to Kafka using CDC, standard CDC approach. using CDC, the event gets sent to Kafka. from there, your cache invalidation worker picks up and it invalidates the imagery cash that you have right. this way, with some lag- obviously it's not extremely real time, but with some lag- what you would do is you would have a very nice caching validation, which you would definitely need because once any relation changes, you would want to consume that an invalidated disk cache so that the next request comes in does not, because if, let's say, I canceled my reservation and still for one day I'm able to access, uh, all the critical details. that should not be allowed. so, which is where we need to invalidate the cache. and this is how the cache and validation flow happens. so from DB using a CDC event goes to Kafka. invalidation worker picks that up and invalidates the cache in the image that you have right. so next time the request comes in, cash would not have the data. the request would go to the database. it would get the latest data- a popular cache- and serve it back to the user. subsequent request will be served from the cache itself. again, 98 hit ratio is amazing, right, and yeah, this is. this is a brilliant architecture of a centralized authorization service. the low level design was fantastic on how they have defined the rules, on how they've made their system robust and extensible and flexible. again, highly, highly, highly highly recommend you to go through the evaluation step, the evolution of it, step by step. but think of it just like a normal key Value Store, a normal key based store, not even value, just normal keeper store- and check for the existence of this can see how that evaluation would have happened. right, it's literal string replacement and nothing more, nothing like so. string existence and string replacement is what you should be focusing on. extremely simple, right, okay. so yeah, that is it for this one. this entire thing, again, was taken from airbnbs engineering blog. I've linked it in the description down below. highly, highly, highly recommend you to check that out. and, yeah, that is it for this one. I'll see you in the next one. thanks. [Music]. [Music]. thank you. [Music].