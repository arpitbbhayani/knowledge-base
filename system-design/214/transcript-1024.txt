now, depending on whom we are inviting, we would want to trigger an internal onboarding floor and external onboarding floor, which could be as simple as just showing a different dialogue.
uh, uh, what if an organization wants to invite multiple folks, in which there are internal folks also, external folks also, you can't just do that right.
so this is where, from a product perspective, it is very essential for you to classify every single email into an internal or an external so that you can show them or take them through that, through that specific dialog boxes, through which you can make onboarding as smooth as possible.
now this is where we start looking into things and see that such a simple problem statement of inviting people leads us to think from a product perspective and see: oh my God, we didn't think of this case, oh my God, we didn't think of other case, right?
second is, an organization might also want to classify their- uh, their interns- they are basically contractual employees- their vendors- with different email domains so that they could restrict accesses on other set of their internal tools, private infrastructure and whatnot.
right now, given this, we would want to make this process as simple of an onboarding process as possible, which is why we would need an email classification service, right?
what you are trying to do is, given an email, let's say, person a wants to invite person B whenever an invitation is, whenever a person a types a person B's email address, or email classification service kicks in and it classifies it: open, internal and external.
so first is the settings context, because it is very possible that an employee that uh in a workspace the administrator has has configured that these are the domains that are internal, While others are external, or it they might have just basically uh, shut down, uh, basically external invites, right.
so, for example, if I would want to invite someone and if my domain is, let's say, a bar dot external, then and I'm inviting someone with bar dot external, so which means that we both have same domain, so whatever my classification is, same thing would apply to that person as well.
you cannot just mark them as external, mark them as internal, and you cannot also probe every time when you see a new email domain: hey, do you want to add it to this list or not?
okay, now comes the third case, where you cannot derive something out of simple configuration, like through settings or through inviter's context.
now, the solution to this is- you all might have guessed, and it's pretty straightforward, it's like literally peeking into our eye- is we keep track of all the domains that are part of my workspace and have an aggregated count against which, and we use that to classify, right?
you just keep on inviting people seamlessly, and that system would need to keep track of all the count, like, like the overall aggregation of the number of people against each email.
the table looks something like this: for a particular workspace or a theme, they specify or they keep a track of domains that they have, the count against them, the date at which they'll it was last updated and the role of that particular group.
so here the idea is pretty simple: given an email, you just see that for a particular like, you extract the domain out of that email and see where it holds right and when you see it you see what percentage of people and role combination are they have the same domain, right, if it is more than 10 percent you consider it as an internal, if it is less than that you consider it as an external.
so I can see that if I am want to classify for one directbarcom, it would be an internal classification because there are 68 people right with barcom, with bar dot in there are 30.
so this is a simple heuristic that they went with a simple high level architecture, for this would look something like this: a user never wants to invite someone named classification service is triggered.
so what you do is, whenever a user is created, your file, an observed statement like this: upset: count equal to count plus 1, where team might equal to 7 and domain equal to barcom and roll equal to member.
right now there are multiple such statements fired, but no matter how many queries are fired, because upset is taking a row level lock, it is ensuring that the system is eventually consistent, because you are not missing out on anything right, and this is very important.
there is a very interesting challenge that is coming out of this particular thing, and that challenge is a broker that we use, that is, consuming the events that would be consumed by the workers and updating the database.
now this becomes a problem because now, let's say, if a particular user got created, you updated the entry in the database, but your broker thought that a message was not consumed, or before the message was deleted, you re, or the message got recued again.
which is where what slack did is they had, or they built, a Healer service whose job is to periodically heal the numbers and bring it back and bring it back to a consistent state.
now, a naive approach that you may think to heal is that, hey, let's say, whenever A Healer runs, I would just recompute the count and update it in the DB.
so, which means that whenever my healer is running, I am simply going through all of the users that I have, I'm extracting their email domains and then I'm doing the count in memory and I'm updating it in the database, which means I'm replacing the domains DB for that particular team.
right now with this, what happens is up until this point, the time at which healer started, you knew what the state of your domain stable was.