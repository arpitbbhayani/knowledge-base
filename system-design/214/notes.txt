Email Classification at Slack

Email Classification of Slack On slack, we can invite people by email Email Twokinds of people we can invite too a bar.com 1. Internal -> part of the same org 2. External - part of different ong Internal External Onboarding Onboarding To give a smoother invitation experience Floy Floy slack classifies the email and than to that gives preference option Add to workspace Can they just not compare email domains? toolbar.com, foot bar.com. be foo egmail.com No! because email domains can diff not part of your ong one that assigns emails eg: there are per region eg: toolbar in foo2 @bar.us 3 food and food are employees eg: someong provide diff email to contractual employees, vendors and interns eg: 5003ebar. external too bar. temp

Email Classification Service workspace Email classification is Invite first attempted to be done 7 Email Classification through heuristics, example 3 context 1. Settings A 3 it only certain domains allowed then class: internal Slack connect on as per configuration 2. Inviter context if inviter's domain = invitee's domain then inviter's class applied 3. Team Context Above two are simple settings driven, but Team's context requires database logic to determine the query and some class. This is because slack workspace have million members a challenge can Team Domain Context Idea: keep track of all domains part of a workspace and use that aggregated count to classity.

Table 'domains' team id domain count date. Update role bar.com 2 admin A member A bar.com 68 A bar.in member 38 A gmail.com 3 member Total count of grouped by the domain. users role matching same indication that it is domains having 'abar.com' internal admin * is a bigger an Threshold: 10% Domain to be considered as internal if there are at least +% or more employees in organisation with given domain Hence, fool abar.com abat.in internal internal foot - - for @gmail.com -> external Architecture 1: domainstable M Email Classification (counts maintained with T Y 2 > eventual consistency ( A user created user updated i - user deleted

Implementation Details We call UPSERT instead of INSERT to do relative add"/subtract creation: UPSERT Count = count + 1 where eg: user tam-id = 1 and domain = bar.com and role-member; Why upsert: row-level lock, relative operations eg: user updation: UPSERT Count = count - 1 where tam-id = 1 and domain = bar.com and role-member; UPSERT Count = count + 1 where tam-id = 1 and domain = bar.com and role-admin; No matter how * many queries are fired, because upserts take roulevel lock we can be sure that the system will remain eventually consistent Challenge: Message can be processed twice numbers can drift and hence we need a healer'

The system will auto-real whenever it sees a drift 1 when an email address is added for the 1st time When their plan 2. user upgrades Periodically 3. update the table Naive Healing: recompute the count and What about the events/updates that happened while healer ran? Better approach: mark the datetime when healer starts, note the existing count, compute the actual count, trigger upert to correct drift (until that datetime) eg: +Hl-it (ensures no mutations are lost Architecture 2: domainstable M Email classification (counts maintained with T Y 2 > eventual consistency ( A user created user updated i - a user deleted x Healez