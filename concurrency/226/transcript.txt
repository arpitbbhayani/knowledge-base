so TCP is the most reliable way for two machines to talk to each other over the network the real question is how is one web server able to handle and serve multiple TCP Connections in this video Let's understand this by building our own server from scratch using raw sockets and while doing so we will understand system calls socket programming their limitations and then we tune our approaches to handle multiple requests at once so let's jump right into it so we all know TCP most reliable way for machines to communicate to each other and The Logical entity that wraps the entire thing around communication is called as a socket we typically see connections to be of two types TCP connections and UDP Connections in this one will focus more on TCP but UDP is very similar to it it's more about the guarantees that each one of them brings in TCP more on the reliability UDP is more about basically fire and folder you can read more about it on Google so let's start with the most fundamental question what exactly actually is a TCP server so to put it in a simple terms TCP server is a very simple process that runs in a machine that listens to a port which understands TCP right so for example I can start an Apache Tomcat server I can start a spring boot server I can start a flask development server I can start any server which listens to a particular Port anyone who wants to talk to this machine has to communicate over this port that's the semantic right okay so if we want to write a TCP server from scratch what exactly would we need we would have to start a process which is typically what we do go run something and then we have to listen to a particular Port so let's start with this right so here I'm starting from an absolute scratch I have no code written I'll start with creating a simple file main.go the entire demonstration will be go base but you can pick your favorite language to implement right so we'll start with the simple thing so we'll start with package Main and then Funk Main within which I'll write fmt Dot println and I'll write hello White this is a very this is a very simple hello world program in golang so I'll do go run main.gov and we can see Hello World getting printed on the console and it did right so our goal is very much set up so what do you want to do when our process starts basically what we are writing is we're writing our own TCP server so when this TCP server starts we want to listen to a particular Port so in golang there is a package that does that called net so when I can do what I can do is I can do net Dot listen and I can pass in that hey I want to listen for the TCP protocol on the port 1729 which is what I'll do right so when I write net Dot listen TCP and then the second argument I pass which Port I would want to listen to it means that I am like this process is now reserving a port 1729 right so now I can just run ghost run main.co and let's see what happens nothing actually program started and program finished by printing hello world so did it even do anything it did it actually when the process started it actually reserved this port for this process but because we did not do anything after that it just released it just it just killed right because it just successfully returned right okay so now what do we want to do let's see the return value of listen so listen returns an error and a listener right so what we'll do I'll just accept this I'll say l i s t e n e r and error and in case there is any error we'll just do a fader right now if error not equal to nil what I'll do is I'll do log dot fatal and I'll kill myself and that is fine right because anyway it's a simple thing that we're doing and I'll just do copy of listener and I'll just print listener over here that if I do again nothing would happen but I just got printed hello world it is what is expected over here okay so now listening is done but now what after listen what's the second step this is the first step so we have started reserving a port for us now what's the second step the Second Step here is that we want a client to connect that's really important right so what happens is there is a system called call accept the accept system call is a blocking system call so when you call accept your program would block at that stage and it would only move forward when some client connects to it so what I can do is the listener that we created that hey on this port whenever some client connects then do something right so this is a blocking call remember this so now what we'll do is we'll write this same part over here and just close this off okay so here what we are doing is we want we have the listener set up now we are waiting for the connection to happen so I'll do listener dot accept this is a blocking call now what's the return value of accept returns me a connection and an error so I'll accept it in the connection object and an error object I'll copy paste the error in case any error kill myself but then whatever I got is the connection I'm just printing the connection at the end because it's the connection that I got right now let's run this now let's run this and see what happens so I have a separate terminal set up for this exact same thing I'll do go run main.go and my server has now started now that my server has started what I have to do is I have to connect to it now because it's a TCP server I can literally fire a simple code request we have not handled HTTP yet but what I can do is I can fire a simple curl request because a simple code request into setting up an HTTP connection internal it is also TCP connection so curl HTTP colon slash localhost colon1729 will actually establish a TCP connection with this server and then I should see it moving forward so you saw that here I have Goran main.gov it did not kill because it is waiting it is waiting for that connection to be accepted right a client to connect now let's see what happens when some client connects so I'll just hit call on this and we saw that it printed in the print I passed connection it printed something and then it exited which clearly sees or which clearly shows that our server is running it is bind it is reserving the port 1729 it is listening on it it is waiting for any client to connect on it whenever a client connects at that point in time what we are doing is we are printing that and exiting right so we just built a very simple TCP server that listens to a particular Port it waits for a client to connect to it once the client connects they are printing that connection and we are exiting right so this is a very simple TCP server that we wrote now what's the third step the third step over here is that once the connection is established in the code request what we get we'd get HTTP request so what we have to do is when a client connects to my server I would have to read the request I would have to do some processing and then I would have to write the response and then close the connection so that's exactly what we'll do so again let's jump to our code and we'll start making the simple changes so whenever I'm getting a particular connection let me write a simple function called do and I'll pass the connection object over here and in the do function I will be passing net dot connection net dot connection I'll accept my connection object and what it would do is add one connection to read something I want connection to write which is I'll write the response I'll accept the request I'll write the response and then I'll close the connection right okay now let's see each of the methods parameter so what is read accepting readex accepting a byte diary so obviously you want like when you are doing read you want to read the request and store it somewhere which is what we are doing so I'll create a byte object simple I'll create a buffer of byte and I can pass in a bit I'll have to do this buffer of Y is equal to make now passing of byte let's say one zero two four the maximum request or the maximum length of the request that someone can send me is let's say one zero two four characters or other one zero two four bytes right so what I'll do is I'll pass buffer over here right so this is where what I'm making is I am now listening so when the connection is established I am making this read call now what is this read call this read call is also system call which means it is a blocking call so when this function is invoked my process would not move forward over here it will stop like until until client sends me the request so once the connection is established I'm making a read call so I am I'm waiting until my client sends me the request once the client sent me the request let's see what it gives me it gives me n and error n is basically the number of bytes that I read and error so I have skipped the number of bytes that I read but if I see any error like always I'll just do log dot fatal of n this is just more about because it is demonstration I'm just basically killing my process every time I'm seeing anything wrong right okay but in production you might do something different so now that we have read now what do you want to do we got the request and then we have to do some processing let's say we do some processing and for us the processing is more about sleeping time dot sleep one into time dot second so what I'm doing is I'm mimicking a long running process today it takes me one second to do something right so I'll wait for one second and then I'll write what do I have to write what I have to write is the right accepts a bytes likes to be written now what is this byte slice now I can respond with anything literally anything I can pass in of byte and say I want to pass in hello world easy Quest we would want to send in HTTP response so that your girl understands that it got HTTP response I can send this as well but what we'll do is we'll just format it in a beautiful way so that your curl actually renders hello world beautifully so I'll just send HTTP 1.1 space 200 okay which is 200 Response Code slash r slash n and then I'll do slash r slash n here this is the protocol that we are following and yeah we are writing this and then we are closing the connection so if all goes well where we should be seeing is when we start the server and we fire the request we should see Hello World in the response let's see if we see Hello World in the response or not be fired we got the request boom hello world and if you see it took some time to do it because we added that sleep of one second otherwise it would have responded immediately so what we just did is we send the HTTP request our server sent the response so now you can very easy see that the changes that we did over here is we you can see that whatever request we are getting we are capturing it in buffer you could you could extract the HTTP URL and then you can write your own fancy stuff that hey this is the method this is what I would want to call which is exactly how your what your web browser does like your spring Boot and your flasks and all they do exactly this so whatever you get on the socket they extract that information and see what method needs to be invoked okay but will not go into writing that but you see how we read we processed and we responded and then we close the connection right okay so what's the next step we did all of this but few things to note that the read call is a blocking call the right call is a blocking call so when you invoke the read unless there is something from the client to send to you you would not be moving forward so it's very essential that you exactly you know when to call the read function you want to be exactly sure when you're calling the right function because if a client is not able if your client is not reading why you are writing then your process is blocked right so you have to be very very very very very careful okay now let's see what happens now the next step is we want to do this over and over again now if you look carefully what has just happened is when I ex when I was executing this I started my HTTP server or rather I started my web server let's see it once again and then when I fired the curl request what happened is I got the response and my server exited it exited successfully there was no error you could not see any error over here your server actually perfectly exited but is that what our web server does no our web server is continuously running continuously accepting the request doing the processing writing the response so what we'll do is it will change our code we'll change our code to do exactly this so what we have to do is we have to put this in and infinite for Loop simple I just put everything in an infinite formula so now what would happen when I fire a request the request would go like a part of the curve requested to come to the server server do that processing and then it would wait it would again come back to listener dot Excel when it comes to listener.accept it would start Pros it would wait for a client to connect and then do the processing all over again right so let's see a quick demo and see how it pans out so I'll do go run main.go on the second I'll pass curl HTTP colon slash localhost 1729 we got the response but now you see our server is still running without any problem I can fire another request in one second I'll get another response I fire another request I get another response the reason it is happening is because we put accept inside the for Loop so what is happening the control flow of our code is looking something like this the code entered over here it is waiting for a client to connect once the client connected it do do Connection in which we side we processed and we output it right which is exactly what we did and once we responded the connection was closed it again came back in the for Loop and we did this it again waited and then again and again all over again so if I would have exited this for Loop my program would have exceeded because there is nothing more to execute which is why typically web servers are typically implemented as infinitely running for Loops right now you see how web servers are implemented now the next step we are doing this all over again but then what's the challenge let's run let's hit multiple requests at the same time and then let's see what happens so before we do that let me falsefully just add this response to let's say eight seconds so what I'll do is the processing that I'm doing let that processing happen for 8 seconds so that we can see the demo of like how things react so what I'll do is I'll start my server again go run main.go in the first client that I have top right I'll invoke the curl request I'll just quickly invoke the call request I got the end I find another color request now if you look carefully the server is doing something we don't know what we are doing we haven't added lock statement but my client one got hello world but now it has been very long my client who has not got any hello now it got hello world hey what's happening I thought we would get response at nearly the same time because we called curl from both the places in one shot but it did not happen let's add some logging statements to understand what is happening so whenever I am accepting so let me write this uh fmt or other log dot println waiting for a client to connect and then when the client is connected I'll write till I'm connected and on right so we're waiting for the client we say client connected and we do processing it does the processing and does not so I'll just add one more lock statement over here I'll write processing the request it would give us enough visibility on what's happening let's run this let's run this and see what happens I'll just start the server again Ctrl C oh sorry I've decided the server I started the server and now we got the first statement it is waiting for a client to connect which is exactly what we wanted and now I'll fire this client processing the request and when I fire the curl from here we did not see anything getting printed there we saw waiting for the client to connect it then it returned hello world there then it waited for client to connect and now we would see Hello World over here you see the execution is sequential because we waited for 8 seconds the total execution actually happened for roughly 16 seconds right this is what why why is it happening because the for Loop that we wrote is happening one after another so unless so what this shows us is let me run it one more time so that it just becomes crystal clear that I hit curl over here I hit call over here you see one process getting required like one request getting processed that got responded and then another process happening now after eight seconds this would get Hello World in response so the execution is actually sequential hey this is what is happening so if I take you through the source code which is exactly what we wrote and we can't expect anything else to be done what we are doing is we are waiting for a client to connect once the client is connected we are doing something while we are doing something in which we are reading the request processing it sending the response and once that is done then we are waiting for the client to connect so the server that we wrote is cannot handle concurrent request coming in the server that we wrote can only handle one request at a time which is what it shows because this is precisely what we wrote as a code this precisely what a single threaded server is that on that's one server that you have you are not able to accept multiple requests because that's what our code is or we have an infinite for Loop we are accepting a client or we are accepting a connection then we are doing some processing and then we are returning we are closing the connection and then the circle continues so unless and until we come back to this line very quickly like we want to reach here as fast as possible but until this function execution completes we cannot come back over here that's the thing that's the thing that we would want to address so what do we do this is precisely precisely where multi-threaded server comes in parallel processing so what we can do is while we are accepting the connection and then we are processing it our do function what if we do that do part in a thread what would happen so when I am accepting the connection and I'm doing that processing what if that doing of or handling the request happens in a separate thread once that is spawned into a separate thread my main thread can go back to the top of the for loop again very quickly and make the accept system call waiting for it to accept the client or waiting for it or sorry waiting for the client to make a connection won't that work that's precisely what multi-threaded server does so the only change that I'll do over here is in golang I can create a simple go routine like this I can just prefix my statement with go it would run it as a separate go routine now what would happen now if I run this exact same thing as my code now let's see if we can handle multiple request at once I'll start at the server id.com I came back here I did occur and you see immediately is this getting printed and I'm processing the request and you see the First Response getting hello world and immediately two seconds later we see second request getting hello world we did not have to wait for 8 seconds per second second thing to come out so here we see that how multiple requests now our server can handle multiple requests at once the magic was that we wanted to invoke except as soon as possible we did not wait for the processing of the first request to complete before we could go to accept which is why what we did we spawned it into a separate thread which is precisely what multi-threaded server does right so let me once again show you the demo so that it becomes crystal clear I am invoking curl you see the message getting printed I'll invoke curl over here you see message getting printed both the requests are being handled concurrently by my server in two separate threads first request responded and now the second request to it respond that's the beauty of this implementation this is precisely what multi-threaded server does and this is how beat any programming language be it any framework that you see like Gene framework or flask or gionicon or any web server that you write which can handle multiple requests which are multi-threaded web servers or multi-threaded TCP servers this is precisely what they do this is precisely what they do is when they are waiting so their main thread is constantly just in this for Loop waiting for a client to connect right whenever a client connects they spin out or they spin of a thread to handle that request independently and then it waits again they for not another threat and then it waits again and so on and so forth this way any multi-threaded server handles the mult handles multiple incoming requests concurrently right okay there is another class of TCP servers which are single threaded but they can still handle multiple requests I have covered it in my radius internal course in case you are interested you can check out the link is in the description so but here our Focus was to understand multi-threaded servers so again just to reiterate there is also a category of single threaded servers which handles multiple concurrent TCP connections the way they do it is little internals it's part of my Reddit scores so I won't put it out in this video but now you see what happens like how you can build your own multi-threaded web server right this is precisely what happens behind the scenes and this is how you build multi-threaded web server so just understand like here the baby went for it was that we understood what each system called it like except read write we knew they were blocking which is why what we did is as soon as we knew that our server would not be able to accept the request unless we invoke the accept system call so we waited so what we did we did it in the main thread while as soon as a client connected we fogged out a thread specifically for that request to be handled which is exactly what is happening so for every client that is connected we are forking out this request into a separate thread and then it does its own read and process and like e-read processing write and out and closing right this is the idea this is what every single web server does so now here you start seeing some problems problem number one what if a large number of client connects to This Server when a large number of clients connect to the server what would happen if whenever a client is getting connected they are immediately invoking a new thread to handle that particular request so when a large number of client connects to This Server what would happen for every request a new thread is spun up thread overload or rather there would be huge number of threads on my machine that's not good which is where there are a bunch of optimizations that needs to be done which all multi-threaded server does first of all you typically don't spin up a new thread a new thread for every request you have to limit the maximum number of threads which your server would be spinning up because a server is not just accepting the request and handling it the handling part itself would require multiple threads because there is this Hardware limit of the amount of memory in the CPU and the resources that you have you cannot just spin up infinitely large number of threads over there so which is where you would have to limit the maximum number of threads that you can invoke so that's what it does now for you to do that there is something called as a thread pool what would you do is you would spin up a thread pool that contains let's say thousand threads and whenever you need a thread you go to the thread pool read the thread do the processing and then put the thread back to thread pull this way you limit the number of threads that your process would ever have then you would have you would need connection timeout what if a client is connected you are waiting for something what if that client never sends you the request you cannot just infinitely wait because you are just hogging up a TCP connection so what you need you need a connection timeout so whenever a new thread is perked out there is a timeout associated with it that if my thread does not respond or if my client does not respond in that much of time I would kill that connection right so that's what happens with connection timeout and the final one there's something called as a TCP backlog queue which is an operating system level setting that that determines how many connections you would want to keep in your back right just Google about it it's quite an interesting field to explore so yeah that's how you create a multi-thread web server I hope I was able to spark some interest on the internal side of things the idea being that you just apply a basic first principles while building anything and you can literally build anything around it right so yeah now you understood what system calls are why are they blocking how multi-threaded web servers are even conceptualized and what other factors you need to consider to improve the performance of your web of any multi-threaded web server now be beat any web server Tomcat you pick spring boots or whatever they are using G unicorn nginx all of them any server that is multi-threaded you can literally open that source code and you can see something very similar to this really very similar to this and this is what the beauty of first principle thinking is all about so yeah that's all what I wanted to cover in this one I hope you found it interesting hope you found it amazing that's it for this one I'll see in the next one thanks thank you [Music] thank you