so one of the most common data structures that we all use every single day is hash table every language has its own implementation and nomenclature for it for example python calls it a dictionary when java calls it a hashmap but the core idea remains the same it holds pairs of keys and values and supports constant time insertion updation and deletion but how are they implemented what is its internal structure in this video we talk about what are hash tables how are they structured internally and we would lay a solid foundation to understand that constant time implementation but before we move forward i'd like to talk to you about a course on system design that i have been running for over a year now the course is a cohort discourse which means i won't be rambling a solution and it will not be a monologue instead a small focused group of 50 60 engineers every cohort will be brainstorming systems and designing it together this way we build a solid system and learn from each other's experiences the course to date is enrolled by 600 plus engineers spanning nine cohorts and 10 countries engineers from companies like google microsoft github slack facebook tesla yelp flipkart dream 11 and many many many more have taken this course and have some wonderful things to say the coolest part about the course is the depth we go into and the breath we cover we cover topics raging from real-time text communication for slack to designing our own toy load balancer to quick buzzes live text commentary to doing impressions counting at scale for any advertisement business in all we would cover roughly 28 questions and the detailed curriculum uh split week by week can be found on the course page which is linked in the description down below so if you're looking to learn system design from the first principles you will love this course i have two offerings for you the first one is the live cohort discourse which you see on the left side and the second one is the recorded course which you can see on the right side the live code base course happens every two months and it will go on for eight weeks while the recorded course contains the recordings from one of the past cohorts as is if you are in a hurry and want to binge learn system design i would highly recommend you going for the recorded one otherwise the live code is where you can participate and discuss things live with me and the entire cohort and amplify your learnings the decision is totally up to you the course details prerequisites testimonials can be found on the course page at binary dot me slash master class and i would highly recommend you to check that out i put the link of the course in the description down below so if you are interested to learn system design go for it check out the link in the description down below and i hope to see you in my next cohort thanks so hash tables are indeed one of the most widely used data structures and literally every single language has its own implementation and its own nomenclature for it but really is it just there to power our business use case no a really interesting fact about hashtable is that it is also used as a building block for your language runtime for example you define a class a class as members and some functions right so when you do let's say a class box box dot uh put if you're doing something like this someone like your language runtime needs to know this is the object this is the method that it is being invoked and execute this function for that and this mapping is also so in most languages classes are also implemented as hash tables right it's so widely used now imagine how many times are you using classes every single day it's that common of an implementation second example for that is variable lookups when you declare int a equal to 10 and then you are using let's say printing a your language runtime needs to know that hey a is needs to be print which points to this location so this is called as a symbol table which is used basic like in through which people do variable lookups and that is also a hash table implementation and this this is the penetration of hash table it is so so so widely used across not just your business risk is but also to power the language runtime and that and basically that is what makes hashtable one of the most important data structures out there right so what are hash tables famous for hash tables are famous to store key value pairs right you insert a key and then you insert hey this is the key this is the value and then when you would want that value you would give it the key and you would get the value right this is a simple simple use case of a hash table but what it brilliantly does is it gives you constant time insertion deletion and lookups and this is what makes hash table super efficient or it makes hash table special because imagine if it does not if it could not provide your constant time insertion deletion and look up your fundamentals of your runtime which is classes and symbol tables they would be slow which makes your entire language slow that's why having a constant time implementation of near constant implementation of hash table is super important so how how are they how are they constructed so any hash table is constructed on top of or with these two basic foundational ideas first of all application key like the first idea is where you map application key to a hash key right so the here the idea is the key that you are putting in a hash table a language cannot restrict you on what key can you put in right it would want to support as many type of keys as possible for example in this example we say that apple is the key and value is 5 so apple is a string while value 5 is an integer right so we need to store string as a key and some integer as a value our language or a hash table should be able to support that but how would we store a string and then like and the value against it right a language and so basically that is where the concept of hashing comes in so what you do is you need to somehow map an incoming key of any type to a wide range of integers right for example in the range of 0 to n it could be an entire integer in let's say in 32 like 2 raised to power 32 is what you can go for but somehow use a hash function use your favorite hash function to map your string to an integer and then a second uh and then the second idea for constructing a hash table is to take this hash key and map it to a smaller range it's like a we are doing string to end and again mapping into it we will come back on why the second step is really is more important is it's really the crux of hashtable implementation in some time right let's dive deep into the first step where we say that application keys are mapped to hash keys like what and why so pick any language pick any language you would see that you are not allowed to put anything in the hash table like you can give string tuples integers like some specific types are there that you are allowed to put as a key in a hash table for example in python you cannot put list into your hash table as in in the key of the hash table right you can put it in the value but you cannot do it on the key so they are very specific about what could be a key for a hash table so how do you so but obviously language would not want to uh a language would not want to prevent you from inserting anything so it needs a way to support it that is for most languages what it does is it gives an ability to implement hash function and now this hash function like java might have get code or hash or basically function called a hash code and by then it is underscore underscore hash underscore underscore what it does it it expects you so you can insert custom data types let's say you created a class and the object of it is you want to place it as a key in a hash table your class needs to implement a function called underscore underscore hash underscore underscore which returns an integer right and which would become your hash key this is what you are supposed to write right and this is the whole idea of mapping your application keys into a hash key so from any type that you have into a type or into integer which then becomes an input for our second step right and this typically the function hash that i was talking about that typically expects you to return an integer which means in a range of 0 to 2 raised to power 32 right so this is what you would write for some for some native data types like string integers you don't need to implement it like the language has its own implementation but internally there has to be something that is converting your application level key through a hash function and converting into a hash key which is then acting as the input for our second step right so this is the first step that we are doing from application domain to mapping it to a wide integer domain through a hash function right that is first step then if we already have this what could be a very naive implementation of a hash table if you are already have a way to map an application key into an integer our very basic implementation of hashtable could be through an array let's say we take a gigantic array right we take an array where given a key we pass it through the hash function from this hash function we get an integer we use that integer as an index of our array and store the value at that location for example my key k gets indexed or when i pass my key k through the hash function i get value i right and ah the value i is the index at which i would be storing the value in this array right if i do this what i get is i get constant time insertion because for a hash key sorry for an application key i'm computing the hash going to that location putting the value constant one insert constant one upgrade constituent lookup because everything is in memory little constant to an axis is what you are getting right this sounds amazing right why are we not implementing it then the reason we are not doing like this approach would work but only when n is small when you are when the range of the hash keys is small then only you can do that otherwise what would happen imagine your range of hash keys is entire integer range which is 2 raised to power 32 0 to 2 raised to power 32 which means that from application key one of the values from 0 to 2 raised to power 32 would come out right so let's see how much of space would we require if n is equal to 10 which means your arrays length is equal to 10 or the number of possible hash keys is 10 the amount of storage would require is 4 into 10 is equal to 40 bytes because each slot of an array would be an integer where you are storing the reference reference of the value or something like that so it would require you to store it would require you 40 bytes if it is 100 you would require 400 bytes if it is 1 million keys that you would want to support like that big of a range is what you are supporting then that would be 4 mb but imagine if you are expecting in 32 size right so from application key you are converting it into a pure integer of range 2 raised to power 32 then what you are doing 2 raised to power 32 is rough is more than 4 billion and when you do it 4 into 4 billion is equal to 16 gb imagine you would require 16 gb just to hold this array in memory right and given whatever it is hashing it to you are going to that location and putting it it seems definitely order one insert update and look up but the amount of storage required is huge so when any small this approach is fine but when n is your entire integer range it's it's not good two key challenges that come over here first of all finding this big chunk of contiguous memory is tough right because most like because when you allocate an array it has to be a contiguous set of bytes that are allocated and finding this much this big of a memory chunk is always difficult right so that is problem number one second is even if we get that much of allocation let's say you have you are mapping your application key to a hash key in the range of 0 to 232 and you are only inserting 5 keys then you are wasting so much of space right so this is not space efficient you are pre-allocating a massive space which is heavily underutilized so that is where there has to be a better way to construct a hash table which is where the second step comes in which is really important of mapping of hash key to a smaller range so hear me out if we are planning to store k keys in the hash table so the total number of keys that we are planning to store in our hash table is k it could be 5 10 15 20 something then we how big our array should be right because if we are only planning to store k keys our array should not be 2 raised to power 32 it's not practically possible so that is where our array should be small so let's say if that size is m right how big our holding array would be that is m so m should be in order of order of k like it should be just big enough to hold k keys it should not be it should not be extraneously large but it shouldn't be small either it should be somewhere that efficiently helps us put all the keys that we want in this holding array and this is the crux of provisioning of finding out the sweet spot of how big our array should be and which is what varies almost all hashtable implementations right so what we'll do is in the second step we take the hash key which is in the range of integer 0 to 2 raised to power 32 and map it into a smaller range of 0 to m where m is the length of the array and length of the array should be a function of the number of keys that you are holding right so this is the second step and which is what now makes our hash table very efficient right so now let's say we are planning to store four keys in the hash table so we can have a bin so the second the holding array is called as a bin uh and this bin could be of length eight so instead of having two raise to 32 as the holding array we can have just eight because we are planning to store only four keys and what we'll do is for every key we would every application key let's say apple it first passed through the hash function we get a hash key let's say for apple we get one two seven six two one seven nine some big number right we take this hash key and map it to a smaller range of let's say zero to eight right because our error length is eight let's say we got zero so where does apple sit apple go and sit in the holding array at index 0. similarly let's say we have banana banana when i pass through the hash function in the first step i get value 51962 again a random number it gets indexed and then when and this is the hash key when i pass it through my second step and map it to a smaller range of zero to it let's say i get five so this is another hash function that we are passing right so now we have two hash functions over here first hash function converts application keys into hash can second hash function converts hash key into a smaller range right so 0 5 and let's say cat hash key to 72 smaller range mapped to 3 so your cat goes and sits at index 3 while dog when i hash it the first time it gets 1 9 6 2 7 1 9 as my hash key when i pass it to my second function i get 7 so my dog sits at index 7. this would make our life so simple because now we are not needing to allocate a massive array we are still getting constant time implementation right because each element is almost uniformly distributed across this array the array is just eight uh it's just having eight slots so four eggs are 32 bytes big so it's not extraneously large it's big enough to hold all of my keys provide me a constant time lookup while ensuring that i am being efficient all the time right and this is why we need two step process or any hash table implementation request two step process first from application domain key to hash key and second from hash key to a smaller range now you would say hey but what if now i don't want to store four keys now let's say i want to store 12 keys my language doesn't wait my language is constantly accepting the keys that i am writing how is my language doing that so that is where when you are trying to add more keys what your language internal or your hashtable implementation internally does is it grows your bin it grows this array it changes m and changes it to m equal to 2 into m so it makes this array double every time and that is one of the implementation you don't always have to make it 2x of what it holds right but that is one of the implementation and when that happens you are reallocating a big chunk of array right so let's say you had eight and now let's say you exhausted the limit and now you would want to add more to this array so obviously this has to be an array so what you do is you try to reallocate and then re and then re-index all the keys into this new array and that would require you to take a pause in accepting the rights that are coming in and then you would then once you allocate a big chunk you move all the existing keys and then you start accepting other puts onto this hash table and and this is what happens internally right and this is okay because you are not doing very frequent allocation only when you are exceeding the number of keys that your existing bin can store then only you are doubling the size or increase not the doubling but increasing the size right and this is what you have to answer this is what internals of hash table implementations are okay so then why are we even hashing from the application domain key to integer we saw we get two very solid benefits of doing this right because of the first step what we are doing is we are simplifying our problem statement given that for any type we are converting it into an integer of range 2 raised to power 32 now our problem becomes very simple because this could be something that your end user provides or your business logic provides with hash functions and what not right and for us the internals of hash table our input is this integer that we are getting and how we would want to map these big integer range into a smaller range is our efficiency coefficient of our hash table implementation like how well we do it how well we distribute it how will we provision it and all of that is then on us to implement as part of hash table implementation and this is why first step is very important and that's why we are hashing the first set of application keys into a big integer range and from this big integer into a small integer range right the second step is also like it also enables us to keep our hash table agnostic of what type we are storing because at the end given that any you can support literally any object and get an integer value out of it that becomes a hash key as their own implementation so you created a custom class let's say you created a custom class let's say car you want to store car as a key in your hash table so an object of a car as a key the hashable all you need to do is just implement the underscore underscore hash underscore underscore function which returns you an integer right your user doesn't have to write multiple uh hash functions per se all it does it just returns an integer and once you get this it's up to you you have abstracted out now your hash table implementation is working on only this integer range so from 2 raised to 32 it needs to map to a smaller range of 0 to m and this is what makes it super special so you have abstracted out the complexities of supporting multiple types right all your end user has to do is just provide you the hash function that spits out an integer for a given object done now for you as an hashtable implementer you have the key you have the integer you map it to whatever range you want the way you are storing it onto the disk right and if your m resizes or your if your bin array resizes your end user doesn't it the end user is not getting affected at all your end user continues like your you never have to change the business logic of your code what you do is from this integer range you just change the hash function and how you are distributing another kind of stuff over here this is what we would be looking at into this series of hash table implementation this is first video in this series where we are talking about hash tables because this is such a fascinating data structure in this series i'm planning to go deeper into a lot of implementation details of hash table and planning it to implement in raw c language using arrays and a lot of super interesting insights around it right so yeah that's it that's it for this video i hope you found it amusing i definitely did when i uh first stumbled it a few years back on needing of two levels of hash functions that was a brilliant uh way of abstracting it out why ensuring while ensuring efficiency so i love that particular part and i wanted to share it with you so in this series we would go deeper into hashtable implementation and we would have fun doing it nice so yeah that's it that's it for this video if you guys like this video give this video a massive thumbs up if you guys like the channel give this channel a sub i post three in-depth engineering videos every week and i'll see in the next one thanks [Music] you