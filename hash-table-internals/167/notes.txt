Open Addressing in Hash Tables

Resolve conflicts using Open Addressing Conflicts are inevitable ! key , f h , key , f hi - Multiple keys can produce same hash key upon hashing so , how can we store multiple slot ? Care Idea : keys in the same The two classical ways of achieving this Instead of using some data structure 1. Chaining auxiliary , * 2 . Open addressing Use the empty slots . Open addressing when keys collide , find a way to hunt for available slot in the an array - - - deterministically ^ ^ ^

Probing Finding the next available ^ ^ ^ slot is called probing . be probing strategy can defined as j-plk.it that spits out the new index where key k can be placed in attempt i j c- 10 , m ) i E 10 , m ) m size of the hash table Hence , first insert j = plk , 01 , if that is occupied me try j-plk.LI , if that is occupied me try j = plk , 2) , if that is occupied me try : j =p ( Kim 1) - , if that is occupied me try Good probing function the probing function should generate the permutation of numbers 10 , m - L ] so as to cover the entire space eventually .

Implementing probing function It is a simple mathematical or algorithmic function that deterministically tells us our next slot for a particular key key attempt plk , , 0 ) 5 1 attempt probing function gave 5 plk , , 1) 7 2nd attempt probing function gave 7 p ( ki , 2) 2 3 attempt probing function gave 2 0 2 3 4 5 6 7 I So , while looking for key K, , we first look at plk , , 0 ) = 5 , 7 if cannot find p Iki 1) = we , , , if we cannot find , plkz , 2) = 2 : ' :

Hash Table Operations : Adding a key Until find free L - we a slot , keep probing and checking o i 2 3 4 5 6 7 at the first free slot . put the key Hash Table Operations : lookup lookup is similar to adding . L ] Using probing function me 0 2 3 4 5 6 7 I try to find key in slots Iteration stops when we find the key slot or we stumble upon an empty the slots or we exhaust iterating over all Hash Table Operations : Deleting a key the deletion is a soft delete . We lookup the key using probing function and upon discovering , we mark the slot is deleted . But delete ? why soft

Ki , Ka , Kz hashead at index 5 > we 143 Ki K2 With open addressing say, 0 I rz 3 4 5 6 ? 8 got them placed at 5, 7 and 2 [ probing function ] Hard say been delete , key kz and now we are looking for Kz > DELETE K2 143 KI GET 1<3 0 3 4 5 6 ? 8 I p2 all hash to index 5 then how would you ? if you delete K2 , ever reach kz empty slot = = stop iteration so , you will never be able to reach 143 during lookup Hence , we need to differentiate b/w Free and Deleted soft deletion is the to way go limitation of Open addressing Max number of keys = # slots in array