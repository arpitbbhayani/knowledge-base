although chaining is a popular way of handling hashtable collisions there is a very interesting way of achieving the same and it is called open addressing the key highlight of open addressing is that it does not require any additional data structure to hold the collided keys making them super space efficient in this video we'll look at open addressing the core idea behind it lay a super solid foundations for probing functions and understand how the implementation of our core hash table functions changes with this scheme in place but before we move forward i'd like to talk to you about a course on system design that i have been running for over a year now the course is a cohort based course which means i won't be rambling a solution and it will not be a monologue instead a small focused group of 50 60 engineers every cohort will be brainstorming systems and designing it together this way we build a solid system and learn from each other's experiences the course to date is enrolled by 600 plus engineers spanning 9 cohorts and 10 countries engineers from companies like google microsoft github slack facebook tesla yelp flipkart dream 11 and many many many more have taken this course and have some wonderful things to say the coolest part about the course is the depth we go into and the breath we cover we cover topics ranging from real-time text communication for slack to designing our own toy load balancer to quick buzzes live text commentary to doing impressions counting at scale for any advertisement business in all we would cover roughly 28 questions and the detailed curriculum uh split week by week can be found on the course page which is linked in the description down below so if you're looking to learn system design from the first principles you will love this course i have two offerings for you the first one is the live cohort discourse which you see on the left side and the second one is the recorded course which you can see on the right side the live cover based course happens every two months and it will go on for eight weeks while the recorded course contains the recordings from one of the past cohorts as is if you are in a hurry and want to binge learn system design i would highly recommend you going for the recorded one otherwise the live code is where you can participate and discuss things live with me and the entire cohort and amplify your learnings the decision is totally up to you the course details prerequisites testimonials can be found on the course page at binary dot me slash master class and i would highly recommend you to check that out i put the link of uh the course in the description down below so if you are interested to learn system design go for it check out the link in the description down below and i hope to see you in my next cohort thanks so conflicts are inevitable in hash tables as we are trying to map a large set of application keys into a smaller range of your hash table right so when you pass different keys through the same hash function you might end up with the same hash key right which is what causes the collision in the previous video we looked at chaining as a way to handling collisions in this one we look at open addressing chaining required an auxiliary data structure open addressing does not so what exactly is open addressing the core idea of open addressing is that why to have an why to use an auxiliary data structure if your hash table itself has empty slots let's try to reuse them somehow which means that when there is a collision when let's say two application keys hash to the same location one gets placed but we have to find the slot for the second key and that secondly key the way we would be finding the slot it needs to be very deterministic in nature right so that we do not just we cannot just pick random slot which is available to place the key because then it would be a linear lookup always right or it would be very very incoherent uh way to look up your keys upon collision that is where you need to know if your particular index you you got a particular hash key you are trying to place your key into that slot but if that slot is filled you have to find a different slot deterministically on where should i put my key next right and this is where the idea of probing comes in this is the heart and soul of open addressing right so probing is a function that would help us find the next available slot right and the strategy is obviously called as proving strategy and how it and how we could define it as probing strategy is a function of a given key and an attempt right so for example for a given key i would want to make an attempt 0 to find where my key should be placed if your slot is occupied then you would make attempt 1 to find where your key could be placed next then attempt 2 to find the next slot if that is also filled then attempt 3 and so on and so forth up until m where m is the size of your hash table so for example if you have hash table of size eight you would you can make eight attempts to place your key if all of these eight slots are filled then you would say hey i cannot accept any more rights or you may either want to replace one of those key right but the probing strategy is the one that would help you find the next available plot and this is what the theoretical definition of a probing function is so we would always start with open addressing we would always start with the probing function a good probing function and we would start to make attempt zero if the slot is filled uh if the slot is empty we put it there if it is filled then we would make attempt one so we would invoke the probing function with the key and attempt one so one and then we would fire the thing which would spit out another index we would say if that is occupied or not we will do this until we find an empty slot and then we place our key there so obviously we can write as simple of a probing function as it can be like which returns a static index which could make it super complex the baby would want but what does a good proving function look like a good probing function should generate a permutation of numbers in the range of 0 to m minus 1 both included so as to cover the entire space eventually why because obviously like for example if your hash table has a size of eight which means that you may have to make an attempt eight times and it should cover all the indexes in your array so that you know that eventually you are you will cover the entire hash table so that if there is any slot available anywhere in the hash table you will be able to find it in any of the attempts that you are trying to make so which is where the way you would be writing your probing function it has to cover all the indexes of your array from 0 to m minus 1 both included it may be in different order but it has to be deterministic and it has to be complete so that eventually you would cover the entire hash space right so how do you implement it right so implementation could be twofold it could be pure mathematical implementation or it could be algorithmic implementation right so the idea would be to find to pass in that attempt with the key that spits out an index and we'll try that so let me take few very simple examples to understand it so if i would if i'm trying to insert a particular key k my in and this is my first attempt my hash table is empty what i would do is i would trigger this hash i would trigger this probing function p of k comma 0 it spits out 5 i would see if the slot 5 is empty if it is empty i would fit it there if it is not empty i would invoke probing function with k comma 1 because it's my first attempt because 0th attempt is gone i'll just start with my first attempt my first attempt it would give me 7 and then next it might give me 2. so it could be any order but it has to be deterministic for a particular key so for a particular key i have to get it in a particular order only so that it is deterministic for me how am i traversing it might be different order for different keys that is not a problem but it has to be deterministic for a key so that you exactly know from if i cannot find it on index a i would go to index b if it's not in b i'll go to c if it's not in c i'll go to d it might be somewhere in the hash table right but it has to be very deterministic so that you can able to find it so given this as a probing function how does our hash table operations change so how does adding a new key look like so what do we do we find off we find the freeze plow or we try to find a free slot if we are able to find it great if we are not able to find it we would keep probing the function so that we when we would do this until we find the first freeze plot first free slot and then we put the key there for example let's say i'm trying to insert a key k1 when i pass it through my probing function attempt 0 it would give me 5 i would try to place my key at location at index 5. is the index free let's say no then i would make another call it gives me 7. is my key is the slot available uh is the slot number seven available no now i would make another call it would give me two is the two available yes so i'll put my i'll paste place my key two place my key k at index two right and this is what we would cut and the probing function would be generating the entire permutation in some deterministic order right then how does your second operation look up look like so lookup is very similar to adding what we would do is we would start with in let's say we are trying to find a key k in my hash table what i would do is i would invoke a probing function with attempt 0 and then it would spit out some j which is the first index will go to that index and see if the key is there or not if it is there great we would return if it is not there we would invoke the probing function again that would give out that would give us another index if it is there good enough if it is not there we would go to the next one and then the next one and then the next one until we find the key what is the worst case the worst case here is we all the slots are filled and our key is not there so then we would have to linearly go like we are literally accessing all these slots one after another to eventually find out that the key does not exist so when does the iteration stop the iteration stops in three states in three cases first case is that we are trying to find the key which we find so first attempt we could not find we make second attempt then third attempt and then for them let's say somehow we find the key that's when your iteration stops right second is your iteration stops when you stumble upon an empty slot for example because you are because the probing function would generate a permutation of numbers you would always go from one to next to next to next and if during this iteration if you find any empty slot you have to stop because once you find an empty slot after that you would not have anything in that cycle right because if that slot is empty you have to stop the iteration otherwise if there were any keys after that this slot would not have been empty because this is the deterministic order that a probing function is following right so your iteration would stop when you stumble upon an empty slot and if you still haven't find your key which means that your key doesn't exist in the hash table right and the third case when an iteration would stop is when you have exhausted iterating over all the slots which means that attempt 0 attempt 1 attempt 2 and so on and so forth to meditate attempt n minus 1 and you have exhausted now because there could be m slots you have triggered your proving function m times which is you have literally accessed if m different indexes in your hash table you could not find the key and that's okay so which means your hash table is filled and you have exhausted all of your iterations right so this is how your lookups would look like right very similar to add but just being cautious about when to stop iteration now deleting is interesting how do you do deletion the deletion when you are using open addressing and hash function is a soft delete which means that you are when you say i would want to delete a key you are not emptying the slot there has to be two different notion first if the slot is empty and second if the slot is deleted why so because of how probing functions work or how our discovery mechanism works right so let me take an example let's say the keys k1 k2 k3 all the three hashed at index 5 when key k1 k2 k3 are passed through the same hash function it spits out 5 right so now obviously we cannot place 3 keys in the same array slot that we have 5 right so that is where we invoke the probing function let's say probing function spits out for attempt 0 it spits out 5 and then 7 and then 2. so my k1 is slotted at 5 k2 is slotted at 7 and then k3 is slotted at 2 right now save a would want to delete k2 and let's say we do a hard delete right we do a heart delete of k2 which means now my k2 which was present at index 7 is gone and my slot is empty right and now let's say we fire a get of kt of a get of key k3 now when this lookup happens what would happen is i would invoke my probing function with attempt 0 on k3 what i will get 5 right because it is index 5 but index 5 is hold with k1 so it is not the one which is intended right then we would invoke probing function with attempt to one let's say it spits out and it spits out 7 we go to seven we see the slot is empty as soon as the slot is empty our lookup function will stop iterating and saying that the key k3 does not exist but key k3 was there key k3 was at attempt 2 because earlier k2 got slot 7 because of attempt 1 on the probing function and then hence k3 got at slot 2. so which is where because now you have had deleted your k2 you have emptied the slot 7 so your lookup iteration would need to stop otherwise you can continue always your lookup will always be linear going through all the slots so that is very inefficient right so that is where as soon as you stumble upon an empty slot you would stop your iteration and which is where you would never be able to reach k3 in this case which is why we need a way that differentiates free and delete so if the slot is empty or a slot is deleted right so that we do not stop iteration there right we stop the iteration only when we discover an empty uh only when we discover an empty slot right but a deleted slot it's okay right so that's why your deletion when you're using open addressing has to be a soft deletion and what is the limitation and obviously grass is not always green there has to be a limitation of open addressing the limitation as you can very clearly see is that the number of keys that you can put in your hash table is equal to the number of slots that you have otherwise because your probing function is trying to find an empty slot in the array if your array is completely filled then what happens then either you replace an existing field or existing slot most probably the last slot or you would discard your input or your discard that hey i'll not uh you would discard the put that you got on your hash table right two ways of handling it but in general the limitation of open addressing is the number of keys that you can hold in your hash table is equal to the slots that you have in the array right so as soon as your array is about to get filled you would have to resize and do rebalance and what which we'll touch upon in the coming videos but this is the core limitation of open addressing with chaining because it required us an auxiliary data screen you can put in as much of data you want in that auxiliary data structure for example a link list right and that would not have been a problem but here it is a problem and this is a limitation of open addressing it's still fast enough if you are able to resize your uh hashtable array it's really solid method to achieve that which we'll touch upon in the future videos so yeah this is all about open addressing this is all about the foundations of probing functions in the coming videos we'll look at detailed implementation of various probing strategies to understand how they function and what are the strengths and weaknesses of this right nice so yeah that's it that's it for this video i hope you understand open addressing in depth and you understood how add delete and lookup functions would alter in case of open addressing along with looking at the limitations of it so yeah that's it for this video if you guys like this video give this video a thumbs up if you guys like the channel give this channel a sup i post three in-depth engineering videos every week and i'll see you in the next one thanks [Music] you