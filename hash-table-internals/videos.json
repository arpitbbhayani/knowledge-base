[
  {
    "id": 167,
    "topic": {
      "id": 0,
      "uid": "hash-table-internals",
      "name": "Hash Table Internals",
      "one_liner": null,
      "youtube_playlist_id": "PLsdq-3Z1EPT2UnueESBLReaVSLIo_BuAc",
      "bgcolor": "#FBE0E0",
      "themecolor": "#FF4B42"
    },
    "yt_video_id": "6_yFb7icd_c",
    "title": "Conflict Resolution in Hash Tables with Open Addressing",
    "description": "Although chaining is a popular way of handling Hash Table Collisions, there is a very interesting way of achieving the same and it is called Open Addressing. The key highlight of Open Addressing is that it does not require any additional data structure to hold the collided keys, making them space efficient.\n\nIn this video, we look at Open Addressing, the core idea behind it, lay the foundation for probing functions and understand how the implementation of our core Hash Table functions changes with this scheme in place.\n\nOutline:\n\n00:00 Agenda\n02:35 Introduction\n03:06 Open Addressing\n04:15 Probing Functions\n08:45 Hash Table Operations",
    "img": "https://i.ytimg.com/vi/6_yFb7icd_c/mqdefault.jpg",
    "gif": "https://media.giphy.com/media/Q2gnin2fe9c2uLIA5L/giphy.gif",
    "duration": "18:6",
    "view_count": 204,
    "like_count": 12,
    "comment_count": 5,
    "released_at": "2022-07-15",
    "gist": "Open Addressing is a common yet interesting way of handling collisions in Hash Tables and instead of using an auxiliary data structure, it leverages empty slots of the hash table to store the collided keys, making the entire approach space efficient.\n\nWhile inserting a key in the hash table, we pass it through the hash function to get the slot, and if the slot is already occupied, we find the next available slot through probing.\n\n## Probing\n\nProbing is the process through which we deterministically find the next available slot in the hash table. The approach and algorithm could vary but formally it is a function of the key to be placed and the attempt, that spits out a slot.\n\n```\nj = p(k, i)\n```\n\nThe probing function uses the key `k` and an attempt `i` to spit out an index `j`. The attempt `i` and the index `j` are in the range `[0, m-1]`, where `m` is the size of the hash table.\n\n### Good probing function\n\nA good probing function would generate a deterministic permutation of numbers `[0, m - 1]` specific to the key `k`, so that we eventually check and cover the entire hash table for an available slot.\n\nFor example: for some key `k1`, on a hash table of size 8, the probing function might generate a sequence: 5, 7, 2, 1, 0, 6, 4, and 3. This means we first try to put the key in index `5`, if that is occupied we check `7`, then `2`, and so on.\n\n## Hash Table Operations\n\n### Adding a key\n\nUntil we find a free slot in the hash table we keep invoking the probing function with attempts `0`, `1`, `2,`, etc. Once we find an empty slot, we stop and place the key in that slot.\n\n### Key Lookups\n\nFor looking up a key, we invoke the probing function with attempt `0` and check the slot. If the slot holds the key we need, we stop and return the value. If not, we continue to probe with attempts `1`, `2`, etc, and continue to hunt.\n\nWe stop the iteration when\n\n- we find the key,\n- we stumble upon an empty slot during iteration\n- we have checked the complete hash table\n\n### Deleting a key\n\nWith open addressing, deleting a key from the table has to be a soft delete, because we need a way to differentiate between an empty slot and a deleted key.\n\nIf during deletion we empty the slot, then we would be unable to look and reach for a key that had a collision and was placed after the key we deleted.\n\n## Limitation of Open addressing\n\nSince we are not having any auxiliary data structure, a major limitation of Open Addressing is that the maximum number of keys we can hold are same as the number of slots in the hash table.",
    "notes_gd": "https://drive.google.com/file/d/1bvdtGMKVou-bfuOHzX3izdx2FHfQTpYS/view?usp=sharing",
    "slug": "conflict-resolution-in-hash-tables-with-open-addressing"
  },
  {
    "id": 166,
    "topic": {
      "id": 0,
      "uid": "hash-table-internals",
      "name": "Hash Table Internals",
      "one_liner": null,
      "youtube_playlist_id": "PLsdq-3Z1EPT2UnueESBLReaVSLIo_BuAc",
      "bgcolor": "#FBE0E0",
      "themecolor": "#FF4B42"
    },
    "yt_video_id": "9rb8oILi4lU",
    "title": "Conflict Resolution in Hash Tables with Chaining",
    "description": "Collisions happen in Hash Tables as we are trying to map a huge space of application keys in a small array. But there are ways to solve it and one of the most common ways is called Chaining.\n\nIn this video, we go in-depth about collisions in Hash Tables, resolve them through chaining, explore some really granular details that would help us squeeze the best performance out of our implementation, and most importantly look at a different data structure to implement it.\n\nOutline:\n\n00:00 Agenda\n02:29 Introduction\n03:42 Chaining\n04:58 Chaining with Linked List\n08:03 Adding a key in the Hash Table\n14:04 Deleting a key from the Hash Table\n15:47 Lookup a key in the Hash Table\n17:15 Chaining with Binary Search Trees",
    "img": "https://i.ytimg.com/vi/9rb8oILi4lU/mqdefault.jpg",
    "gif": "https://media.giphy.com/media/vciXulg7fZGvo9p01m/giphy.gif",
    "duration": "20:55",
    "view_count": 358,
    "like_count": 26,
    "comment_count": 4,
    "released_at": "2022-07-13",
    "gist": "Collisions are inevitable in Hash Tables, and a common way of handling them is through Chaining using Linked List. But can we use some other data structure?\n\nCollisions are inevitable in Hash Tables as we are mapping a large range of application keys on a smaller range of array slots. So, there are chances that the hash function spits out the same value for two different application keys.\n\nBecause Hash Tables cannot be lossy, we need a way to handle these collisions and allow storing of multiple keys that are hashed to the same slot. A way to achieve this is Chaining and it is very commonly implemented through a Linked List.\n\n## Data Structures\n\nTo accommodate this, the Hash Tables are now implemented as an array of Linked List where all the keys that collide are placed.\n\n### Adding a Key\n\nWhile adding a key to the hash table, we first pass it through the hash function and get the slot index. We then create a node holding the key and add it to the linked list.\n\nWe can add the new node at one of the 3 places\n\n- always at the head of the list - O(1)\n- always at the tail of the list - O(1)\n- in the middle of the list while maintaining a sort order - O(p)\n\n### Deleting a Key\n\nTo delete a key, we first pass it through the hash function and get the slot index. We then iterate through the linked list present at the slot, element by element, and locate our key of interest.\n\nWhile iterating, we keep track of the pointer to the previous node so that once we reach the node to be deleted, we adjust the pointers and free up the node.\n\n### Key Lookup\n\nKey lookups are similar to delete operations. We first pass the key through the hash function to get the slot index. We then iterate through the list present at the slot and locate our key. The operation requires us to iterate the list iteratively.\n\n## Other Data structures for chaining\n\nLinked List is not the only data structure that we have to use to chain the collided keys. Depending on the use case, access pattern, and constraint we can pick a data structure that suits us.\n\nFor example, if our array is small and we cannot resize it then we may end up having a large number of collisions. If we are trying to read, then iterating over this list will reduce the throughput as it is a linear scan.\n\nTo optimally perform a key lookup, when the collisions are high, we can use a self-balancing search tree, like BST or Red-Black. This way, we get an optimal lookup performance on keys hashed to the same slot.",
    "notes_gd": "https://drive.google.com/file/d/1so447uSDzZZuJXAyMB_jGqHCM0RX3hbL/view?usp=sharing",
    "slug": "conflict-resolution-in-hash-tables-with-chaining"
  },
  {
    "id": 165,
    "topic": {
      "id": 0,
      "uid": "hash-table-internals",
      "name": "Hash Table Internals",
      "one_liner": null,
      "youtube_playlist_id": "PLsdq-3Z1EPT2UnueESBLReaVSLIo_BuAc",
      "bgcolor": "#FBE0E0",
      "themecolor": "#FF4B42"
    },
    "yt_video_id": "jjW8w8ED3Ns",
    "title": "Internal Structure of a Hash Table",
    "description": "One of the most common data structures that we all use every single day is Hash Table. Every language has its own implementation and nomenclature for it. Python calls it dictionary, while Java calls it Hash Map. But the core idea remains the same: it holds pairs of keys and values and supports insertions, updation, and lookups in constant time.\n\nBut how are they implemented? What is its internal structure? In this video, we talk about what are hash tables, how are they structured internally, and lay a foundation to understand their constant-time implementation.\n\nOutline:\n\n00:00 Agenda\n02:38 Introduction and Applications of Hash Tables\n05:12 Core ideas to construct Hash Tables\n07:07 Step 1: Application keys to Integer Hash Keys\n09:38 Naive Implementation of Hash Table using Array\n13:38 Step 2: Integer Hash Keys to a smaller range\n17:43 Adding more keys on the fly\n19:07 Do we really need the Keys to Hash Key step?",
    "img": "https://i.ytimg.com/vi/jjW8w8ED3Ns/mqdefault.jpg",
    "gif": "https://media.giphy.com/media/8OYw2Tm8gnrGw/giphy.gif",
    "duration": "23:12",
    "view_count": 2712,
    "like_count": 97,
    "comment_count": 10,
    "released_at": "2022-07-11",
    "gist": "Hash Tables are implemented through simple arrays, but how?\n\nHash Tables are so powerful, that OOP based languages internally uses it to power Classes and sites members. Symbol tables that holds the variables mapped to memory location are also powered though hash tables.\n\nThey are designed to provide constant-time key-based insertion, updation, and lookups while being space efficient at all times.\n\n## Core Ideas to construct Hash Tables\n\n- convert application keys to wide-ranged (`INT32`) hash keys\n- onovert hash keys to a smaller range\n\n## Application Keys to Hash Keys\n\nHash Tables should support storing any object as key and to power that the keys are first hashed to a big integer range (provided by user) typically `INT32`. This hash key is then further used to decide how and where the KV pair would be stored in the data structure.\n\n## Naive Implementation\n\nA naive implementation of Hash Table would be to create an array of length INT32. To store the KV in it, we pass the key through the hash function spitting out an integer. We use this key and store the KV pair at this index in the array.\n\nAlthough this would give us constant time insertion, updation, and lookups, but it is highly space in-efficient, as we would need to allocate at least `4` * `INT32` = `16GB` of ram to just hold this array, with most of the slots left empty.\n\n### Hash Keys to Smaller Range\n\nThis step is designed and introduced to make our Hash Table space efficient. Instead of having a huge array of length `INT32`, we keep it proportional the the number of keys inserted. For example, if we inserted 4 keys then our holding array could be around 8 slots big.\n\nTo achieve this, we map the hash key into a small range (same as the length of the array) and place our key at that very index. This allows us to remain space-efficient while sporting fast and efficient insertions, updations, and lookups.\n\n## Adding more keys\n\nThe small limited sized array will not be able to hold large number of keys and hence after a certain stage we would need a larger array to hold the data. This is done by resizing the holding array and is typically made 2x every time it is full enough.\n\nThus, this two step implementation allows to power near constant time insertions, updations, and lookups while remaining space efficient.",
    "notes_gd": "https://drive.google.com/file/d/1IKYDzO-mZEHDQYEsyoksFkF3DVyTCy6l/view?usp=sharing",
    "slug": "internal-structure-of-a-hash-table"
  }
]