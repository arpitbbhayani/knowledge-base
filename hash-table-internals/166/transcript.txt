so collisions happen in hash tables as we are trying to map a huge space of application keys in a small array but there are ways to solve it and one of the most common ways is called chaining in this video we go in depth about collisions and hash tables resolve them through chaining explore some really granular details that would help us squeeze the best performance out of our implementation and most importantly look at a different data structure to implement it but before we move forward i'd like to talk to you about a course on system design that i have been running for over a year now the course is a cohort based course which means i won't be rambling a solution and it will not be a monologue instead a small focused group of 50 60 engineers every cohort will be brainstorming systems and designing it together this way we build a solid system and learn from each other's experiences the course to date is enrolled by 600 plus engineers spanning nine cohorts and ten countries engineers from companies like google microsoft github slack facebook tesla yelp flipkart dream 11 and many many many more have taken this course and have some wonderful things to say the coolest part about the course is the depth we go into and the breadth we cover we cover topics ranging from real-time text communication for slack to designing our own toy load balancer to greek buses live text commentary to doing impressions counting at scale for any advertisement business in all we would cover roughly 28 questions and the detailed curriculum uh split week by week can be found on the course page which is linked in the description down below so if you're looking to learn system design from the first principles you will love this course i have two offerings for you the first one is the live cohort discourse which you see on the left side and the second one is the recorded course which you can see on the right side the live cover based course happens every two months and it will go on for eight weeks while the recorded course contains the recordings from one of the past cohorts as is if you are in a hurry and want to binge learn system design i would highly recommend you going for the recorded one otherwise the live code is where you can participate and discuss things live with me and the entire cohort and amplify your learnings the decision is totally up to you the course details prerequisites testimonials can be found on the course page at pitt binary dot me slash master class and i would highly recommend you to check that out i put the link of the course in the description down below so if you are interested to learn system design go for it check out the link in the description down below and i hope to see you in my next cohort thanks so conflicts are inevitable as we are trying to map a huge space of application keys onto a small array of limited size so why does this happen this happens because we are passing our key through a hash function which spits out a hash value right and there are chances that multiple keys that pass through that hash function would spit out the exact same hash key which means that both of them are hashed to the same location which means they have to occupy that same slot so now because there is a collision now what could happen is if we are not handling collisions the second value that is put in the in your array would replace the first one which is bad because which makes your database or which makes your hash table lossy which means if you inserted a particular key then you are reinserting it if both of them has to the same location the first one would be overwritten right and you don't want that to happen because your user trusted you with its data and you don't want it to be deleted so how do we solve it there are two classical ways of achieving it the first one is called chaining the second one is called open addressing in this video we'll be focusing on sharing what is the core idea the core idea of chaining is that we put the colliding keys in a data structure and hold them well for example if two keys are slaughtered in the same slot of an array instead of one overwriting the other we would use an auxiliary data structure in which we can accommodate both the keys hashed to the same slot right and one of the most common implementation of this is with linked list right and which is why it got its name called chaining because it it resembles a chain right so a small just a quick uh gist of the idea is we would form a chain of keys that are hashed to the same slot right for example in index one if i have two keys which are hashed your index one in the array would hold a linked list and in that linked list you would keep on adding as many keys as it gets hashed to that same index right similarly it would happen at every other index so in case there is a collision you are always adding the key to this linked list right and this is how chaining like the idea of chaining is right now we'll dive into smaller details of it to understand things uh that we would need to take care during implementation and get the best performance out of it right so what we'll first discuss we'll first discuss chaining with linked list right so when we talk about when we want to chain and we are using linked list for it there are three very important operations that we would need to uh that we would need to support first of all adding a new key to this linked list second of all check if the key is present in the linked list and third of all remove a key from the link list right because these are the three exact operations that happen on the hash table so upon collision you would need to add this thing to the link list you would need to check if the key is present in the hash table and for that key if it is going and basically hashing to a same slot which is hold by english you need to check in the link list if the key is present or not and remove a list when hash table operation comes in to remove a key which means you also have to remove it from the link list right so these are the operations these three key operations we need to support on linked list right so given that the simplest implementation is what sinclair link is you don't need to complicate it with doubly linked list or circular link list it does not make any sense we'll go with the simplest approach single linked list right so now the array that we have right the array that we have that array is nothing but an array of linked list right where each slot of the array holds a head pointer to the linked list right so that whenever a key is hashed to that location it is added to the to this particular linked list right and that is the entire role of this array right it is now earlier it used to hold keys we don't need that now it would hold the actual linked list to when because we have to support collisions right okay and each slot and each uh and each slot of the array contains the head to the point of the link list which looks like the the standard definition of a struct so what it would have is your area of a linked list sorry your your array of links that you have every slot is nothing but a structure called slot with struct node star head pointing to the head element of the linked list right and each node of the list right of the link list that you have it contains two things it contains an actual key that it would store and the pointer to the next node right now why would we need to store actual key so that we can do that comparison we can do that comparison because let's say if apple and and hash to the same location we need to and if someone says hey delete apple you need to traverse to the link list and identify apple and then delete it right so you would need to keep the void pointer key and a struct node next so that you can form your linked list there right so now let's see with this concept in place how hash table operations pan out so let's say we start with the basic operations adding a key so adding a key to the linked list let's say we have three keys k1 k2 k3 and what do we have we have an array of size 4 right and because with the arrays in area of linked list each head pointer of the linked list it points it's it's it's basically set to null which means there is nothing in it right so now what would we do let's say put k1 comma v1 came in and let's say k1 hashed to index 2 so it would go to the index 2 and it would then your node then your head pointer at index 2 of the array would start pointing to this new node right let's say then kkk then we got a put for k2 v2 which means insert key k2 with value v2 let's say it got hashed at index 0 so it would go and sit at index 0 at the head of the link list right and let's say we got the third put for k3 comma v3 when i got k3 comma v3 it got hashed at index 2. it would come to index to input 5 hey on index 2 the head that is already set so k so key k 3 comma v 3 would go and sit at the tail of the linked list after key k 1 comma v 1 this way what would happen we would form a very solid chain we would form a very solid chain of the nodes whenever the collision happens right so the basic flow would be given a key and a value to be added we pass the key through the hash function and get an index i we create a new linked list node with k comma v we add it to the chain present at index i in the array right this is a basic add operation that would happen right but obviously that should not be just one way to implement it there are multiple ways of implementation now for example given that you want to add a value to or given that you want to add a key to this linked list because there was a collision if you want to add it to this link list where you can add it right so to make your insertions lightning fast what you can do is you can always insert it at the head of the link list right so whenever you got a key to be added to the hash table you would hash it to a particular slot in that when you are adding it to the link list you are directly adding it to the head so just head pointer manipulation which is lightning fast order one operation so you will get very high right performance on your hash table right second place is where you can do is you can always add your node to the tail of the linked list now you would say but adding to the tail of the linked list every time might require me to go through the array or through the link list right once you got the slot you have to go through the link list go to the end of it and then add the node no that is one naive way to do it but what you can also do is in your array you can keep track of your tail pointer if you can keep a track of which node is the last your ad insertion at the tail can also happen at order one right so it is also fast so it's up to you if you want to add it to the head go for it if you want to add it to the head tail go for it right but there is a third approach third implementation that you can do is say you would want to maintain an inherent order for example you are storing strings as a key right and let's say you have created 26 slots a to z so a slot of the array would contain linked list of all the keys that starts with a right now let's say because strings are comparable comparable you might want to have a lexicographical order if you want to have a lexicographical order so then let's say you inserted and so it went and sit at the first place in the linked list then you added atom but when you are trying to add atom after and you would see atom would come after end so you would have to traverse and then add atom at the end of the linked list because it comes after end and then let's say now it comes apple so apple is after a nt but before 80 right so given that is the case you would have to i trade through the linked list find the place that would be appropriate for this key to be slotted in the link list and that's where you would add it so if you would want to maintain some sort order whenever the collision happens your insertion would need to would need to be according to that right so three possible implementations of inserting in the linked list always add it to the head or always add it to the tail or depending on uh depending on the order you would be adding it to the link list one caveat is if you are by default adding it to the head one small problem would come in you might get duplicate keys in your collision for example if i added apple with value v1 and then added apple with value v2 if you are blindly adding it to the head of the linked list then what would happen is you would have two apples in the linked list so it's up to your implementation on how you would want to do it but depending on the kind of requirements you have you can decide how do you want to slot it but the worst case that you can definitely do is for a given key when you reach to the slot see if the key is already present if it is not present then you add it to the list otherwise whatever is present you replace it to that node right so there are multiple ways to implement this but it is up to you as an engineer or which approach do you want to pick right okay now let's look at second operation deleting a key now how adding a key was straightforward it was just about inserting it into the linkage deleting is also very straightforward so let's say we delete it in a particular order let's say we first delete k2 then we delete k1 then we delete k3 just to uh just to set the context array is of size 4 so 0 1 2 3 on slot 0 i have k2 v2 on slot 2 i have k1 v1 and k3 v3 in this order right so now how would we do delete delete operations is pretty simple we reach the slot in order one time because given a key we would pass it to the hash function we would get the index once we got the index we know which linked list are we targeting then we start iterating through the list node by node to find where node arrow key equal to equal to k1 which means we'll identify the node where keep with my key is present once while we are iterating we would have to keep track of a previous node right once we reach the node that we intend to delete we would have to adjust the pointer so previous node would point to the next node and we would delete the intended node right so one key thing to note over here when you are implementing it with linked list ensure that your pointers are handled and adjusted well because this is a very common uh uh reason why segmentation faults or some error happens like because it's very bug prone right so ensure that you are doing it very well but deletes are also straightforward you just need to keep track of a previous node while you are deleting it right third is looking up a key now this is very similar to delete operation so here what we do is let's say we would want to get a particular key from the hash table so what we do given a key we pass it to the hash function get an index go to that particular slot in the array start traversing through the linked list node by node until we find the node that holds our key right so now this means that order one we would reach the slot but then it would be linear scan on the link list to find the node that interests us right so if you have a very high collision rate where let's say if one of the linked list grown out to be really big let's say 100 elements 200 elements you have to linearly iterate through it to spot your key so if your collisions are less this approach works best but prepare for the worst case where your linked list might grow to be very big so it's almost like a linear scan right so always be very of the fact then when you grow or when there is a very high coalition on one of the index it's the time when you would want to resize your array which means from four you would go to eight right so just keep that in mind whenever you are implementing it and which is what we would be definitely covering in the upcoming videos on how do we resize this array how do we decide when to do it and and a lot of details are on that right but all the link list is the most common ways of implementation what you can clearly see is if you have a very large collision rate right where one of the links is going out to be very big it would affect our lookup times and date and hash tables are meant to be efficient at lookups so you order when you reach to the slot but after that you are doing this linear scan can you make it better right so that is where instead of using linked list you can use other data structure for example you can use a tree a self-balancing binary tree instead of a linked list so now your array is an array of self balancing binary trees and when you are inserting you would insert in this tree when you are deleting you would delete from this tree when you are looking up you'll look up into this tree and this would give you a good performance like not with respect to inserts inserts are costly right inserts would be login your deletes would be login but your lookups your lookups will would also be log n and your n is the depth of the t so typically it's order h right so where if h is the average height of a cell balancing binary tree across your array this would give you the complexity of that so now where would you use this where would you use tree for chaining instead of using linked list you would use it where your you are having very high collision rates number one and you cannot resize your array uh to a bigger number which means that let's say i have four elements in my array and due to some implementation result i cannot expand it to it and i want to keep my hash table array to be a very small length when i want to do that which means that if i'm inserting a large number of keys a lot of them would collide to the same slot right and it might be possible that i might have thousands of keys given that i have four slots let's say i'm adding 4000 keys so each slot on an average would have thousand keys right and now when i'm doing a get imagine every time doing a get if i was implementing it with a linked list i would have to do a linear traversal of it but what with trees what i can get is i can go to that slot and do a login search in that way because it is self balancing binary tree i can do a login search and return the value right so my lookups will be much faster so we can use any self-balancing binary search tree or not really binary but any search tree when we are expecting a large number of collisions then and large as in hundreds if not thousands at least and then you can go for this kind of approach so linkedlist is not the only way of implementing chaining you can also use something like a self-balancing binary tree but understand the limitations of it right your insertions would be a little costly your deletions would be a little costly but your lookups would be faster but you would only do that when your number of slots are very limited and you are not allowed to expand further that's when you might want to go for a self-balancing binary tree instead of a linked list and this is all about chaining this is all about chaining its implementation with linked list its implementation with trees and that's all what i wanted to cover this one right so great okay that's it for this one if you guys like this video give this video a thumbs up if you guys like the channel give this channel a sub i post three in-depth engineering videos every week and i'll see in the next one thanks again [Music] you