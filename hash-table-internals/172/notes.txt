Resizing a Hash Table

Resizing a Hash Table load Factor = #ke_ys # slots Performance of hash table degrades as load factor increases and hence at , a certain threshold , to maintain the hash table performance of our we have to resize . When should we resize ? takes time " Resize when factor high Resizing " load is too * and it depends the structure on underlying and algorithm we cannot be too too lineant aggressive , nor . t, would waste too much we performance time doing resizing will degrade A common decision , resize when = 0.5 array is half filled But we can make this logic as complex as possible

How to resize ? I. create new ten mnew array - = Mold 2- Copy elements from old to the new array mnew 3. delete old array takes time * allocating new array and moving keys If implementing ' it in language ' are C you . real / c the most common to do this is way Note : Time taken to resize is t keys A typical strategy to resize is to always double the array insert if trigger during we resize allocate 2x and rehash keys me re - a new array of size ' ' * we not be able to realtor call may use , would need to rehash per the ( mod ) keys as new size m as we kg K, K} K2 hlk) % Mold hlk ) % M new > < d > kz Ka ki 1<3

double ? Why do we always It is a common practice that whenever we need to resize a hash table , we > always double growing by a constant factor 1. Say , we always increase by 1 Operation allocate insert a a array and insert a , allocate size 2 b array of a insert b a b copy 1 element , insert insert a b allocate size 3 c array of 3 2 elements insert c Copy , ' : insert 2 a b c d f h Y 2 e g c- - . . ' ' array of - reallocate size n ' ' n operations - copy all In 1) elements - from old to new - insert nM element Total 1-12-1 + n nln -11 01h21 ops = = = . . . . . 2-

2. Say , we double every time nlz assume , we resize when array is completely filled n * upon filling the last spot 2n when we insert n /2 elements in array of size n /2 3 33 insert 3 3 99 resize y y y y n /2 One n /z n let's go from n 2h To to the need to add 42 elements get next resize , we First takes 0111 the final element Mz -1 , - 011) to insert 3399 3 9 } 3 - 012M for resize Olm for copying elements - Total operations 01M 2n 712 = - I + I + + n = =

2 ? Why always a power of The underlying array of the hash table Ki has the length = power of 2 ^ Because it but how ? is efficient , Hash table works on hash function key K, f i i % in index MOD operation is super - important as it bounds the integer output from hash function to a range that fits in array But , MOD is really expensive internally it does division , and captures the remainder ? can we do it faster Say , M = 4 hash key mod 1m ) index I % 4 I 2 % 4 2 3 44 3 4 44 0 5 I. 4 1 6 14 2 7 % 4 3

let's use bitwise AND to get the same output 22 22 say , m = 4 = , what if we AND it with - I =3 1%4 = 1 1 43 2%4 = 2 2 43 O O O L O O 10 O O I I 0 0 11 O O O L O O 10 3%4 = 3 3 43 4%4=0 443 O O I I 0 L O O O O I I 0 0 1 L O O I L O O O O " 5%4 5 & 3 = MOD M = AND ( m - 1) , m = 2 O L O 1 AND operation is significantly faster O O I L than division and hence 0 0 01 ! performance gain " - 2 -1 has lower bits I and higher 0 AND acts as a filter - zeros will keep result bounded with set bits ones percolate

Hash Table Shrinking a If keys are deleted from the hash table . then q q it does not make sense to keep them bloated 42 grow when we Hence , we shrink the table * if table has n slots it would have 42 elements Imax ) , n = 16 , e = 7 3 33 3 2 33 if we shrink . it would have nlz slots immediate resize n = 8 . e. = 7 3 33 Z z z z Poor performance . load as factor =L hence , it can have at Max Ma elements n = 8 , e =3 z z z consistent performance But , One more insertion will cause a resize Hence We need to shrink when # elements are such , that insertions after shrink not cause resize few would a n = 16 , e = 2 33 hence we would shrink when there are 48 elements

Summary resizing is important to maintain performance - - resizing is costly hash table doubled is always - hash table has 2h slots for faster compute - - grow when 42 - shrink when ' /8