in the previous video, we looked at linear probing as a way to handle hash table collisions, but is that the only way, or can we do something better?
in this video, we take a look at quadratic probing as an alternative to linear probing.
we spend some time understanding what quadratic probing is and how it is better than the linear counterpart.
so, like always, conflicts are inevitable as we are trying to fit in a large application key space into a smaller hash table.
right, we are talking about open addressing as a technique to do so, which is very space efficient as we do not required auxiliary data structure to do it.
right, to handle hash table collisions.
so, but how do we find the next available slot in the hash table so that we can place our key at that particular slot in case there is a collision?
right, in the previous video, we looked at linear probing to do it, where we literally found a primary slot and, if that is occupied, we went linearly moving forward in the right direction until we find an empty slot.
right now in this video, we'll talk about quadratic probing.
quadratic probing is an alternative to linear probing and what it basically does is, instead of using a linear function, it uses a quadratic function.
we'll just talk about it in two minutes, right?
so first, just to recap, what is a probing function?
probing function takes is is a function of the key that you would want to place in the hash table and an attempt right.
so with zeroth attempt it should give you the primary slot.
if that is occupied, you change i, which is your attempt number.
it goes from 0, 1, 2, 3, 4 till m minus 1, where m is the size of the hash table.
this way you would be, you would be deterministically getting the next slots where you may place your key right.
so this is the importance of probing function.
now let's recap about the challenges with linear probing.
so what we know about linear probing: it first finds the primary slot.
if that is occupied, it would go to the right, which is basically finding the next available slot by moving to the right.
once it hits the array, at the end it starts from the index zero right.
a big challenge with linear probing is that it suffers from.
it suffers from basically cascading collisions, or you may also cut, you may also call it clustered collision.
so here what would happen is when a key is placed in a particular location, let's say k1 is placed at index 2 and let's say k2 also came in, which also got hash to index 2 right, and because k1 is already occupied, the slot 2, your k2, would have to be placed at slot 3 because slot 3 is empty.
but now if we talk about k3, let's say k3 came in and k3 got indexed at slot 3, but slot 3 is occupied by k2, so k3 would have to move forward.
so you see a good cluster of collisions happening in a small area.
right, and this typically happens because of a poor hash function.
right, so we know that with a poor hash function, linear probing would suffer, and that is the biggest challenge with it.
so then, as an alternative way to do it, what about a way through which we can reduce clustered collisions?
right, so we don't want a lot of collisions happening in one place, because it's literally, with linear probing, it's literally one slot getting collided by multiple keys and they just move a step to the right.
right, this way you're forming small clusters, of course, so any key that goes there, they will be collided.
so a poor hash function would typically lead to this.
now let's see how quadratic problem solves it.
so let's take a look at what quadratic probing is.
so, instead of, instead of putting the key in the next available slot immediately to the right, by moving one step at a time, what we do is we find the successive value through a arbitrary quadratic function.
buzzwords simple enough way, so linear, probing.
what we did is p of k comma i, which is a probing function.
k comma i, where i is the attempt number, is equal to h of k plus i, where h of k is the hash of the key.
that gives you the primary slot and i gives you the offset.
so offset will start from 0, 1, 2, 3, 4, 5, 6, which means you're literally traversing through the array one after another, one slot at a time, until you find an available slot.
this led to clustered collisions, because everyone is just collided to this one place, right.
so as an alternative, what you can do is, instead of going one step at a time, take a quadratic function, for example: p of k comma i is equal to h of k, which is a primary slot, plus c 1 of i plus c 2 of i square.
so when you do this, what happens is, instead of going one step at a time, you are taking a quadratic leap.
this way your clusters will not be formed because they would be spaced very well.
square, so zeroth attempt would give you the primary slot.
so this would help you minimize the clustered collisions that you would get in case of linear probe, right sample sequence.
if i talk about it so obviously, because it's a quadratic function, your, your c1 cannot be zero because you want ice, sorry.
your c2 cannot be zero where p of k i is equal to h of k plus c, 1 of i plus c 2 of i square.
we don't want i square to be ever 0, otherwise it would transform into a linear probing.
that's where it becomes a quadratic right.
let's quickly take a look at how it is better than linear probing.
it basically reduces the problem of clustered collisions and cascaded collisions, because the next slot, the next available order tries to hunt deterministically is is basically quadratic leap ahead, right.
so with linear rubbing you are not getting equally spaced or near random spaced uh keys or uh or near random space where you can place your collisions right.
with quadratic probing what you are getting is you are taking bigger leaps in order to place your successive collided keys.
this way you get this advantage that, hey, even though my hash function is not good, but with collisions i'm trying to reduce clustered collisions by placing them a little far away from each other.
right, this way it is a little better than linear probing only with respect to handling clustered collisions.
right now let's take quick.
let's take a look at two properties of quadratic probing.
right, obviously graph is not always green.
first property we all discussed: it reduces the cluster collisions by distributing it quadratically.
right, it is obviously not immune to clustered collisions, because you can clearly see that if you are getting large number of keys for the same slot, they would all be collided, but other keys going to those other slots, they would still be almost equally, just not really equally, but.
but good enough, sparse distribution of keys would be there, right, so it reduces, but it is not eradicating it, right?
second point: now this is what also was an advantage of linear probing- is that quadratic probing has a good locality of reference, but it is not as great as linear probing.
we know that how linear probing leverages cpu cache in order to make iterations faster.
so when you are accessing this from main memory, this page, this memory page would be brought into cpu cache and from there it would be accessed.
right, let's see if there is a collision in af2.
and obviously when you are talking about the page that it brings in, it is not just bringing a of 2, it is bringing neighboring elements as well, because the number of elements of an array or the segment of an array that could be brought into the memory would be brought into the memory, uh, into the cpu cache.
and when that happens- let's say you found collision f at a of 2 and then you are iterating- the a of 2 is not available.
when accessing after, it would already find a 3 and cpu cache so it would not have to do a memory lookup much faster.
so linear probing is the best way to leverage your cpu cache and it's really fast, right.
it also does a fair job to it, because what you're seeing is, if your hash function is good enough that it does not cause a lot of collisions, then you're here.
also, you are leveraging a good cpu cache, right.
because if you think about quadratic probing, so your, your, uh, your next available slots would be, let's say, you are accessing a of 2, and if a of 2 is collided, you are taking a quadratic leap, right.
then you will go to a of 3, as in plus 1, and then a of 6, which is plus 4, right?
so if you talk about a small memory page of 5 slots, you are bringing a of 2, a of 3, a of 4, a of 5, a of 6..
so you are already bringing in three slots that you might find your key in, right.
so this way, at least for some iterations, because if you are not having a lot of collision, then attacks, two to three or four average collisions, if happens, all of those can be found in your uh cpu cache, because you are fetching that contiguous memory uh segment into your cpu cache, right.
it gives you a good uh leverage of cpu cache, but not as excellent as linear problem, while solving the problem of clustered collision.
a little little better than linear probing in some case.
but if your hash functions are poor, where a lot of keys are hashed to the same location, that ruins everything, because then you would have a big, a large number of collisions.
then you would have to iterate through seven square, eight square, maybe even hundred square, right, and that is where the problem would started, right.
so that is where you have to be very aware on the advantage that you'll get when you use clustered uh, when you use, basically, quadratic probing.
it minimizes your problem or your issue with clustered collisions.
it gives you decent enough cpu.
it gives you decent enough leverage of your cpu cache.
it is still just reducing it, not me not eradicating it completely, right.
a little better than linear probing, uh, when you have fewer collisions on a particular set of key, right.
so with a good, decent hash function, quadratic probing triumphs over linear problem, right?
that's it about quadratic probing.
that's it about quadratic probing.
that's it about quadratic probing.
i hope, uh, i went into enough details for you to understand and make those decisions if you're ever building a hashtable- on which one to go for linear or quadratic and how to implement it.
it's all about just tuning your probing function right.
okay, so as part of this, uh probing strategies for hash table- next video will be the final one that will be covering uh, double hashing as a technique and then we'll go into advanced part of it, like load factors and whatnot.
i post three in-depth engineering videos every week and this video is part of hash table internal series and i'll see you in the next one.