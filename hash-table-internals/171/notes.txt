Understanding performance of a Hash Table

Performance of a Hash Table Hash Table gives constant time performance when there are Zero collisions But thats impossible - . . " " So , how how full the table is ? can we quantify This is called the load Factor load Factor n n load factor = n elements I slots in the hash table >m There is a good correlation b/w and time load Factor with resolution strategies different 1. with chaining , we can never fill the table add node to list we can always a new 2. with open addressing . We would eventually run out of space and writes would fail In both cases perf would go down much before operations start to degrade

Chained Hashing load factor average number of elements = stored per linked list = @ + 01-2-10 -10+4+0+2) / 8 = 1 Time to resolve collision = 011th ) * Upper bound . we can adding traversing it node definitely optimize the list Open Addressing Doing analysis with open addressing is challenging !! as . . . Collisions Interfere K, K2 1<3 Collisions on one slot will interfere ^ , k k with probe beginning on other } infinite loop in key lookups up ^ # probes ^ #probes otherwise 01m ) pH 1 2 2 > Hit Misses

Which the best then ? is strategy the the cost Depending on probing strategy , and it matters of each probe changes , . 1. Probing is costly with chained hashing linear traversal linked list of random memory accesses Not cache friendly to evaluate 2 2. Double hashing requires us hash functions Cpu intensive and time consuming random jump in array Not cache friendly * Optimal strategy depends on the use - case . tune and evaluate !! Hence , How to compare and benchmark ? Hash Tables it is If we are re - implementing , important to know how good we did and hence . analyze and benchmark .

lookup time as a function of load lookup time how lookup ^ your strategy identity For time changes as a function of load factor against all strategies hash table size 1024 I. create a of y to 900 2. insert n elements varying 32 3. lookup 1000 random keys ( high miss ratio ) we should see : 1. performance for open addressing degrades as I 2. chained approach degrades gracefully 3. linear probing would be slower than double hashing be shorter 4. Probes of Double Hashing will Note : we cannot conclude , chained hashing >> open addressing because chained hashing is not very cache friendly * when tables are short we do not see impact of caching

Bettering cache performance in chained hashing To leverage cache in chained hashing , we can allocate pool for each slot that the nodes list close to so of are each other in common memory allocation * linked list of arrays Chained Hashing Outperforms Open Addressing when tables are smaller . Open addressing outperforms chained hashing when tables are large enough critical for your application If Hash Table performance matters a lot , experiment with different strategies . parameters , and algorithms