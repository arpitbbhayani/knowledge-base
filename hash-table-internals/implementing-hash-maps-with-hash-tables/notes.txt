Implementing Hash Maps

Implementing Hash Maps A common use of Hash Tables is to build a > apple Hash maps data structure that , a powerful b > ball c > cat allows to store us key value pairs and d > dog retrieve them by key when needed _ * There is no lookup or deletion by Value Keys and values both have application context Hence We need to store Hash Table , the apple application keys in the Hash Table a - : the hash keys along with the key - - b : ball - d: dog avoid computing tnlkl h = - c :[at struct Pair { void * key : < hold key of any type int hash hash stored to avoid computation key ; < re - - } void * value ; s holds value of any type

Implementation detail : if we support generic key livid * ) how Kelo such ? would we compare keys hence , we would need a custom comparator for the type Implementation detail : when we delete a key from the hash table to clean them up it may be our responsibility [ manual memory management ] Hence , as part of robust implementation we would need comparator function and destructor function f. f. for key for key for value With Hash Map , We never care about the value all accesses are key - based insert , update , delete , lookup Implementation Detail Putting the same hey again, should not raise an error , instead it should be same as update

Implementing Hash Map With Hash Table With Chaining Hash Map overall struct node { will have L int 32 hash _ key ; 1. array void * key ; 2. # size void * value ; 3. # keys struct node * next ; 4- comparator function } 5- destructor tune / key ) application key 6. destructor hash of the key funclvaluel to avoid re - computation We will need to invoke value to be stored the against key the destructor function lit provided ) when key / value is deleted

Implementation Detail lookup function would return the value for the provided key and Null if , it does not exist Implementation Detail check and insert To avoid duplicate keys , we always Approach L : if they present , do not insert at all Approach if key present 2 : , delete old key and re - insert advantage at the head the list : it would bring the key of Approach 3 : if key present , insert the key without deleting multiple instances of the same key space injticient t, lookup would delete becomes expensive fast inserts return the [ we have to delete all instance of the same key ] first match

Implementing Hash Map With Hash Table With Open Addressing struct slot { slot is Marks if boot is empty ; empty Hash Map overall _ have deleted will boot is _ ; marks if key is 1. int 32 hash key ; soft deleted array - 2.tt size void * key ; 3 . # used slots void * value ; 4. # active keys } application 5. comparator function value application key 6. destructor tune they ) hash of the key 7. destructor fun ( value ) to avoid re - computation Implementation Detail and delete matching hash key During insert . lookup when we find the to we need explicitly compare the keys to check its existence . Implementation Detail and value for both key should be invoked Destructions only when cue are hard deleting the key