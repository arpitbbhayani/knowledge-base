[Music]. hey guys, about this side, it's time for yet another c python internal deep dive, and in this one we'll be talking about strings in python, more specifically, how python optimizes strings in general. uh, like always, will be exploring c python code base and finding out how it actually does that. so, uh, in this one i am using the latest pull from master branch of c python, which is right now working with version 3.10. so if you are following along, ensure that you are working on version 3.10 and have a similar code base there. there won't be a very major changes, but it's better to have a like to like version. so, since we're talking about python, let me create a new string called the honest python- a shameless plug, i've added, but that's okay. uh, i create a equal to the honest python. i'll create b equal to the honest python again. now, when we do a double equal to b, what it would do? it is, if this is implemented using strcmp, like very basic functionality. it would go through character by character and find out if strings are equal or not. but python does something much more beautiful. so in python there is this function called id. what it does is: it returns an identity of the object. if it is c python, it uses objects memory address, so you can treat the written value of id of a as the memory address where a resides, so memory address where a actually points to, so basically where the string resides. so it's four, three, four, four, three, four, three, two, four, four, nine seven, one, two. now when i do id of b, you'd find that they are exactly same. it's also four, three, four, uh, it's also four, three, four, two, three, uh, three, two, four, nine, seven, one, two, right. so id of a is exactly same as id of b. what does this imply? this implies that my variables a and b both are pointing to the same memory address, right? this is very interesting because now, even though we specifically initialized a as the honest python, b as honest python python, instead of allocating a separate memory space for the honest python as my second, well, honest python- it reused what a already pointed to, so it somehow identified that this string already exist and it needs to use the same reference. yeah, right, and that's, and this sort of optimization is called string interning. it's more like it's, it's you, uh, you can think of it like we are actually caching strings, right? where is this helpful? now, when you do a double equal to b python, instead of going through the strings one by one or uh, sorry, instead of going through characters one by one, it can first of all like immediately check if a and b point to the same address or not. if they do, then strings are definitely equal. if not, as part of fallback, it can obviously go through and it should actually go through character by character. but this is very interesting. it makes lookups really faster, right. it makes it makes your, it makes your equal comparison really fast, right? so since this optimization is called string and turning uh in python, uh under cis module, you can explicitly ask python to intern any string, and it's present is part of this model. there is this function called intern, sys, dot, intern and int, e, r, n, and when i do, when i call help on that, you get the help string help text of that. what it says is: intern function enters the string in the global table of intern strings, more like cache, where you are dumping in all the strings and you're using it to pull that. if the string exists, i'll use the same reference. otherwise i'll create a new string in that space like, whose purpose is to speed up dictionary lookups. so in dictionary lookups, uh having text key is the most common use case and optimizing key lookups since the uh. since dictionaries are so heavily used in python, optimizing key lookups would actually make the overall language like really fast. so that's where string and turning plays a very major role. so, given this thing, let's find out what it does internally. so we know that it's part of this module as intern function. let me open code of cis module. i open this around line number nine zero three. you'll find a function called sis intern impl. going by the name it really looks like it's an implementation of cis dot enter right. so uh, this is one of the main reason why i love c python code, because it was so intuitive to just go through and understand things. it's fun. so says intern impul. let's see what it does. it checks if my object, if my string object, is actually a string or not, it it? if it is not, it raises an error which says: can't intern because you can't in turn, because you can't in turn non-string objects, so you can only intend string objects. so there is this check. if pi only got exact, check exact for pi unicode, which means if s is unicode, then it would go within. it does some increment reference, more like garbage collection. so now more things are pointed to it, something like that. and then it invokes pi unicode intern in place. this is the main function, uh, that is responsible for interning the strings, like: because in this, this thing, there is nothing else than this. right other thing is just checks and all. so pi unicode in turn in place is the one that performs all the string and turning uh, let's check its implementation. so now over here it accepts pointed to a pointer, not a single pointer to something x, but a pointer to the uh, a pointer to the pointer to python object. and then what we create is we create s out of it by dereferencing it once, and why it's taken a pointer to pointer. will will get that reasoning down below. so now it has taken s, what it's doing is some routine checks, ensuring that it is obviously unicode. and here what it is doing is it is checking if my pi unicode is actually interned or not. if it is already in turn, then i don't really need to return it again. right, i can like directly return. so it saves us bunch of computation. it checks for readiness of unicode. it would be something. i don't know the internals, but that's okay. this is something so basic. this is where the the fun things begin. so what it does is it get unicode state. let's see what it does. uh, i'll open the get unicode state function and you'll see what it does. what it does is it gets pi interpreter state- looks like global interpreter state something- and within that it returns memory address of arrow unicode, more like unicode specific interpreter state. it has written. so this seems this is like that global table that we, that that help text, was talking about, where it's dumping all the intern string. it looks like they're closing on that so that global state is obviously unique, specific because string interning. and what we do over here is what we see is that state arrow intern. so in interpreted state error unicode arrow intern is pi dick new. so it's creating a new dictionary type and allocating it to interned. so this is the global table that the help text was talking about and in this one, if this is not initialized, if this is set to null matlab, but if it is not initialized when initializing it with a brand new dictionary, with this brand new dictionary, what does this mean? that the global table is implemented as a dictionary right, fine. uh, if state error intend is more like error condition- that even after invoking this, if we were unable to get a new dictionary due to out of memory issues and all, it would not do anything, not throw any error, because you would not want your program to crash. uh, now comes the very the most interesting part of it, on how it actually implements. so what it does is. it does pi direct underscore set default. so python dictionary has this function called set default. that function, what it does, is it so? given a key and the value, it checks if the key is present in the dictionary or not. if it is present, then it would return the value that is already set in the dictionary, okay. but if the key is not present in the dictionary, then it would take in the value that you have passed in as the argument to set default and set it in the dictionary, right, and obviously it would return the value that was set. so if the value is already set, it would return the already set value. if the key is not set in the dictionary, it would set the value in the dictionary and it would return the same value again. this is something that string and turning exploits beautifully. so now here, what we have, what it is doing, is it's so in pi dict set default, it is setting key as s and value as s. so key and value, both are passed as same s object. you'd think that this is very expensive because you are storing strings, but in reality you are not actually storing strings. what you are actually storing is rent is actually is actually a pointer reference. so you are just using this four bytes of key and value space and not like storing entire string in the dictionary. so you are doing straight arrow intent. so you are calling set default on state arrow intern, as in your global table, with key ss and value as s. let's see what's happening over here. so, uh, let's say, if s does not exist, okay, if s is not existing, what your set default function would do is your set default will set. so over here. while doing this set default, what it would have is: oh, while doing this, what it would have is it would use the first s as the key and the second s is more like value. it's more like the default value that you have to pass in. so if key does not exist and it would use the default, it would use the default value that would be set in the dictionary, so it ex. so it beautifully exploits this particular thing. so what it would do it is: if set, if s does not exist, if s as key does not exist in the dictionary, then the set default will set what s colon s, where the first s is the key and the value is again s, because here we have passed in as s, and it would return s, which is the value, right. what's really interesting about this is, since it, so it's basically returning the object that is set in the dictionary, right. so it was trying to set s. if the s does not exist, then it is setting s colon s in the global table and it is returning s. okay, this s is nothing but the first instance of the string that we have seen. so if i was playing around with the string the honest python, then in the dictionary, what it stored is the first instance of string the honest python right now. what have would happen if s already exist? now, if s, which is key, already exist in the dictionary? now, according to the set default function's logic, what it would do it is it would, instead of setting, it would return the already set value. so now, with this, what it would return? since the key already exist, then the value against it is the first instance of that string. so then it would return already set value, which is the first instance of the honest python right. so the logic here is really interesting. so the it? it is playing around with the return value of set default. so if the return value of my set default function, if the return value of my set default function is stored in a python object t, and now if, what would happen if my this object t is same as s, is same as this s, my default object that was passing. so if, if t double equal to s, right. so now, what does now or what would this imply? this would imply that key did not exist. the default object that was passed to it was set and returned. so if t double equal to s, it implies string did not exist, as in, string was not in turn and we have to internet right else, as in if key, if t is not, if t is not equal to s, it implies string already interned. so do nothing, right, because if? because string was already in turn, right. so if string is already in turn, then what i would have to do it is i would want to basically reuse the returned instance, because return instance is the first instance, right? a return instance is the first instance of the string, correct? this is a gold logic. so now this is something which is exactly translated in the code. so if t is not equal to s, as in this particular else logic. so what it does is it increases reference, because now it understands that more users are pointing to it, so it would increment the reference to that particular object. so over here it's using p. t is what t is the first instance, first instance of the string, right? so it is increasing its reference and this is the most critical statement- it does a pi set reference and it sets star p to be equal to t. it means. so this is why the function accepts pointer to a pointer, not just accepts pointer to just in turn that particular string, but it accepts pointer to the pointer because it wants to make a change in where it is in the, in the variable that was passed in, because what we saw was, when we did id of b, it gave us the same address, right? basically it was. it is manipulating the variable which is passed, and this is exactly what needs to be done. so what it does is it increases the reference of my first instance of the string and it sets- and it sets star p to be equal to t. so it's making the change in the variable itself. that now it would point to what? to the first instance of my string. this is where that magic happens. this is where the honest python string for b, for the second statement that we have given it, identifies that it, that t is not equal to s, and over here it would do a set reference. so let me just add a printf statement over here. what we saw was this: t not equal to s would happen when string is already. string is- let me put it shorter- already in turn and i put a percentage s. let me just print out string and i'll do a pi unicode as utf and i'll pass in s. okay, no, sorry, t is already this thing now, so let me pass in t. okay, so what it does is already in turn. we are printing already in turn pi unicode as this and if this is not the case, as in my code, went over here and and obviously, while, uh, when it is already entered. it has to do nothing, it just sets the reference. so it says start equal to t and it returns off. so if my flow comes over here, it implies my t is equal to equal to s. when t is equal to equal to s, it implies string did not exist. so string did not exist means it needs interning. so it would have set the first instance in the map, in the global table, and then it would have written so, which means in that same state s or sorry, in the same uh string object s, it needs to set in turn to be true. so it sets intern to be equal to estate intern immortal. so more like some state of 0, 1, 2 would be there that it does something. so if i put a printf over here, we'll look into what estate intern mortal is. but let's first ensure that we are, that our hypothesis is true. so what we want to do is we want to interning a string s and i'll put, i'll use the same flow over here and i'll print s. so if this hypothesis is true, for the first thing it would have to say in turning the string s, and if it was on for the second one it should say already in turn, right. so now if i call make, i build this code, i call make and what i'll get is: let me just let it just build the entire object and the binary see it already started printing already in turn internal intent. but we'll see this in detailed action now. now what i'll do it is: i have my see so many interning calls happen when my with start. now that we have added printer, we can see how many times it gets involved. so i'll just copy paste this string and let me do this. i'll set a equal to the honest python what it should do. it should say interning that particular string. it said in turning, the honest python it said already in turn for other strings, which is stdr, flush, flash and std out, that's okay. uh, so for that thing it came to this particular place. but for the string that we are interested in, which is the honest python, it came out over here. but now, when i do be equal to the honest python, it says already in turn. basically, it's it went into this flow. it says already in turn it changed the reference and that printed this particular thing and it returned: got it. this is how string interning actually happens, and this is where the magic happens. this is where it is doing star p equal to t and changing the reference and reusing the, the first instance of the string. now, one thing that we missed on is dot intern. now what is this dot intern? it says pi unicode state s. so something like changing the state of something of, of the my pi unicode object, which is s of dot intern to something. let's just hit on, uh, dot intern. what do we get? so if i click on dot intern would get to something: yeah, we came over here. so this is some. so this is part of a struct, something of ascii type, so it works only for ascii something. or it might just be the name. it has: pi object head. pi is size t, length hash. it has another struct. struct has name state, which is where it's doing so, pi unicode state. it would be referring to this and within that is referring to intern right and turn is taking just two bits of space. so within that state, uh, within that struct, it is doing bit slicing and what it's doing is it is sitting, it is using two bits of space to store if this string is already in, turned or not. right, and the value of this interned. is what state not interned? uh, so there are three possible values: zero implies it is not intern. one implies it is interned but mortal. two implies it is interned but immortal. looks like immortal implies it cannot be deleted. and model implies it would be deleted, and something like that. so, given this- interned and not intern, now we understand how it is where exactly this information is stored. so, given this, now what would our stuff be? so, though, remember we encountered this particular function, where it checked in turn. this function should act. what should it? what it should be doing is it should be going into the state and should be checking if state dot interned is non-zero or not, right? so if i click this and i check, it's doing exactly that. it's. it's. it's converting op into pi ascii object and using state dot intern to find out if it is interned or not. right, and this is how string interning is happening, right? this is really cool, right? uh, now what? now what? now, what? there is, uh, something much more fun uh than this. uh, what we'll do it is: uh, let's see what's. let's see what happens. if i try to turn another string, i'll say: uh, our pits the honest. or uh, let me change this thing to the space on a space python. okay, now i'll do b equal to the space on a space python. now, if i do id of a equal equal to id of b, it gave out false. what does this mean? this means that this string is not interned. i said, by the way, before, before this, before this, let's have some fun. before this, let's have some fun. uh, what if i would want to print if a string is interned or not. like, for example, if i have string a and when i do a enter, it should also print if my string is interned or not. okay, let's do this fun thing so that it would help you guys understand on how to like think about making changes. so what happens when we do a and enter? it basically prints out the representation, the repr, of the particular type. okay, so what is so? obviously this type is unicode. so in unicode dot c you need to have that rdpr function, right? so let's just do a control f of repr and since it's a function, should end like something like this: does it have unicode repr, rep, pi object repo? so something similar should be there for unicode. let me check for unicode repr function. yeah, here it is unicode, rdpr, yup. so when you do a enter or any string variable, enter or what it would initial internally invoking is the repr of it. so this repr is for any unicode object and over here what we would do it is: this is where it do. it does all the uh, it actually converts it into string format and passes it to be printed. so at the end of this function, what i would do it is i would do a printf, i would do a printf of is enter and i'll put a percentage d, slash n, and i'll do uh, what i'll do? i'll do pi check. now, what was that? it was something: check in turn, right, check, pi unicode, check intent. so i'll invoke that same thing on object: what's that object that it got? let's check for the argument: what it got, argument, argument, argument, argument. it got uni unicorn is the name of the argument. let's put this. i'm not sure if this is going to work, but let's check out. i have put in unicode pioneer, check in turn. and let me run make again a semicolon. i'll run the make again and see what happens. so pi unicode check. intern was doing was giving you one zero, two, something, and it would check if it is interned or not, it would return zero. if it is not internet, it would return one if it is entered. right, so let it print. okay, now i'll open the shell and shallow, i'll do: equal to the honest python, enter. and now if i do a enter is in turn, spinning is wrong. i n t e r n e d is in turn. uh, it said: is in turn zero. uh, because the honest python is not entered. okay, so now that we have done this, uh, i think it's. uh, okay, we have put this is interned over here and pi unicode check intern is over here where we pass in unicode and it returns one zero, or basically zero, one, two. uh, it returns that thing and uh, we just print it. so now, when any string is in turn, let me try it with the old one, the honest python. and it says, in turning the honest python, if i say a enter, it says: isn't turned 1, right? so this is how we have printed, like: isn't turned 1 or not, right? so it's, it's that simple. so now comes to the next part: uh, what's the stretch of interning, right? so let's answer that. uh, what we saw was: uh, it did not automatically in turn the string the honest python with spaces. right it, it did not. it did not intern the string the honest python with spaces. why there should be some logic that allows the honest python without space to be interned and honest python with space to not enter. so how would we identify what we'll do? it is we'll look for. we know that the crux function is what in turn in place. i'll use this same function to grep in and let's see. we'll only look in for star c, comma, star dot, h files. mostly it should be in c file because that's where the logic is. we'll look into only in c files and see what we find. so i'll start from the top. this is more like interning: dot count something, pi unicode, tuple item. it's okay, setting in tuple something interesting. uh, this is fiona. god, check exact something with pickle. pickle has nothing to do with that interning. oh, this is interesting. in code object file we got this. so it says all name characters. so it takes some v, some v, and what it is doing is it is checking. if all name cares looks like. if everything is character or something, then only do pi code or, sorry, pi unicode in turn in place. right. so now let me check out this and let's see what all namecads does. if i open all name cares, what it does is it checks if pi unicode is ascii. if it is not ascii, rather, if it is not ascii, then written zero, then you don't have to. uh, so then all namecads is false. if it is one by data, then it it iterates through the string and it checks if everything is is lm or having an underscore. so what it is allowing is every character can be, or rather every character should be, alpha numeric, and only non-alpha numeric character that is allowed is underscored. given this, if all namcas would return true, if every character is ascii, or basically if every character is alpha numeric. more specifically, if every character is alpha numeric, with exception being an underscore, then it would return 1, otherwise it would return 0, which means, if this is, if this is how it's working, then my, the honest python with underscore should be interned. let's check that out. i've never tried. this isn't turned on right. so that's the logic of how python is trying to do string interning right. and obviously now, if we were to change it like we would want it to, in turn every single thing, what we would do, we would just get rid of that check. we would just get rid of all the things that we have found where uh is interning is being used, and we'll be modifying that right, it's that fun. so, yeah, that is it what i wanted to cover around this and, uh, i hope you guys learned something fun, learn something new. uh, i had written a very, uh, i'd written a very interesting article about string attending about five to six months back and, uh, while writing that, i was more into on where exactly it's string and turning been used. so i would recommend you to take this as an assignment sort of stuff where you would want to find out what all strings does python, because when we ran this particular- so basically when we started this pythonexe, we saw it was interning in a lot of stuff, right? so what i would want you guys to do it is explore the c python code base and find out what all strings are being interned, right. so all you have to do it is just look out for pi unicode underscore intern in place into c python code base and see and just try to make sense out of it it. it is a very fun exercise and, uh, you can anyway refer to my article, which i'll link in the comment below, in the description box below. you can go through that and see if it matches yours and although i was not that exhaustive, but it's really a fun exercise to do so, so i hope you guys had fun, uh, in this particular video. it might be a little long, but it was definitely fun for me. i spent more than three, three and a half hours just to understand how it's working and then i was able to compile it into this particular thing. so, yeah, basically that's it from me. if you guys like this video, give this video a big thumbs up. if you like the content, please give a big sub to this channel and i'll see in the next one. [Music]. thanks. [Music] you.