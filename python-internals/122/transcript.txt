[Music] so in version 3.8 python introduced something called as a walrus operator that facilitates assignment expressions assignment expressions are very similar to assignment statements which is like a equal to 10 where 10 gets assigned to value to variable a but as part of assignment expressions what happens is the value 10 not only gets assigned to a but gets also returned as a written value of this expression so that we can reuse it at different places if we would want to so these assignment expressions they come in really handy while writing code it makes code really intuitive to read and build one really weird thing about assignment expression is a very simple looking assignment expression gives the syntax error and in this video we'll be changing the pi so we'll be uh we'll be diving into python grammar and identifying why that happens uh and in the process we would be altering the grammar in order to just get rid of that syntax error right sounds fun right let's let's let's jump into it so uh uh before we like go into python grammar let's understand where exactly uh the walrus operator fits into the picture by the way the borders operator looks like a colon equal to uh so and equal to prevented by colon uh so what we'll do in order to uh understand where does this actually fit into the scheme uh let's write uh let's write uh our own shell in python so what i'll do it is uh i'll create a file called shell.py by the way since this was uh introduced in version 3.8 what i've done it is i've create uh i have changed my branch to 3.8 so that i run 3.8 that uh shell of python and not run on python 3.10 so you can do this by running a git fetch and basically using this very branch so i would recommend you to do this and not use the python 3.10 the entire code base that we are skimming through is for the version 3.0 so we'll jump on to writing a shell let's write a very let's write a very trivial shell uh what it should do it is uh it would uh it should continuously take in commands and fire that commands onto local shell and this should continue until we see an exit statement right so what we would do it is we would take in a command as an input and we render a nice looking prompt what we do it is until we get uh until we get an exit command we would continue our loop and in the loop what we would do it is we would want to run that very command onto my shell so i would do os dot system and i would pass in that command so that this command gets executed onto my local shell and the output gets rendered uh once this is done i would also like to take in the next command that i would need to run and this is pretty much a very basic working shell in python all right so this works really nicely let's see this in action so if i do python shell dot pi it opens up a very nice looking prompt and now what i can do it is i can do ls so it did print every content that i had in my current directory i can do a pwd to get my present working directory and when i type exit it gracefully exits the loop right and this is exactly what we want now uh let's be a little greedy and uh the core logic of this shell is just four lines of code what if i would i want to reduce it right so one very peculiar thing is our code is getting repeated so we are taking input twice once outside the loop and once within the loop uh we have to take an input outside the loop so that our terminating condition looks similar uh looks uh looks intuitive rather than using a while true and using an f within it this seems much more intuitive so now what i would want to do it is i would want to i would want to get rid of this redundant piece of line where we do command equal to input right so uh pi so uh as part of intuition what you would want to do it is you would want to initialize the variable and take input in the as part of uh as part of while condition right so something like this right but uh so this makes our code intuitive and you are you want to define the variable and take input as part of condition itself and let this evaluate and use this particular thing uh as part of and and use the value which is being input in command and uh and put it against and basically compare it against the exit string but when you run this it would give you a syntax error right because this is not a valid syntax and this is exactly where your uh walrus operator kicks in where your assignment expression kicks in uh uh recall that assignment expression not only assigns the value but it also returns the value so now what here what would happen is since we are using colon equal to which is which makes this uh as an assignment expression and not just a simple assignment statement it would take an input assign it to the variable command and now this variable gets defined in the scope and i can use it within the while loop and since assignment expression returns it so the anything that is being assigned to command gets also returned so which takes which takes a seat here right so now my my inputted command will be checked against exit if it is not exit it would continue if it is exit then it would break right so if i run this what i get my bash opens well and now i can do ls it gets me all the file i do pwd and i do exit it grace it gracefully exited my shell right so this is exactly where uh so this is exactly where your walrus operator assignment expression fits in really nicely so it makes your code look really intuitive but what's the problem uh the problem is very interesting so i'll just open up a shell which i built using the very code that's there on my machine it's running python 3.8 this is very important the code that we are browsing is our version 3.8 uh the grammar has been changed in version 3.9 onwards uh so that's why the version 3.8 is very important for you to follow through uh so now what we do it is we have seen that a normal assignment looks like a equal to 10 and a gets value 10. now instead of using assignment let's try using wordpress operator this gives the syntax error this is very weird right so you would expect this to work as a normal assignment statement but it doesn't it instead gives us an invalid syntax but if you thought this is weird or this is non non-intuitive wait if i just wrap this very statement with with parentheses it works it works seamlessly and my value 10 gets assigned to a if i do it with b colon equal to 10 and you'd see that b gets defined and b end the value 10 it's written as well so this behavior is actually very weird right so what we'll be doing today is will be understanding why this happens and in the process change the grammar to get rid of this very syntax error and when someone does a colon equal to 10 it should do a normal assignment right and it should basically define variable and do a normal simple assignment that we want to do so let's jump into it uh let me just remake the build in binary and get everything set up and now what i'll do it is uh anytime we get syntax error it mostly has to do with grammar of the language right so the grammar of the python language is found in the file grammar which is present in folder grammar again version 3.8 is important the file has been changed for version 3.99 and onwards so the grammar is here the this how the the grammar of python language is defined this is where the python grammar is defined so now we know that we have to do something with a colon equal to operator let's look for colon equal to and we find it at two places this is something called named expression test another one is argument this looks like uh the assignment expressions uh basically walrus operator is called as named expression in the source code this usually happens where the terminology that goes for the outside world is very different from what's being used within the code base so in the code base this is used something called this is called as named expression and now let's find out what named expression rules defines are so named expression rule is find a test list com something it's find an if statement and while statement oh this is interesting so if i just move out while here so if i named expression test over here this is exactly how we used it right we used while then followed by our assign followed by our assignment expression where we did command equal to input and then this gets it a block so suit is basically the new line and block that we do uh with an indication with an indentation is called suit in the code base so this is what is allowing us to use named expression in the while statement with this logic what it seems like named expression we can also use it with if statement let's look for named expression again we can use it with alif as well while and some simple named expression test looks like x colon equal to so basically test colon equal to y which is what named expression is how uh it's defined and named expression test is also defined with test list comp look something to do with list comprehension not really sure but let's look for test list comp what where exactly it is defined oh it's just above oh yeah here it is see what happens is test list comp is a named expression test or a star expression let's focus on named expression test for a while and now this named expression test so now this test list comp has to be either wrapped by parenthesis or square brackets right so this is where uh the grammar is allowing a test list comp in turn named expression test to be wrapped around a parenthesis or a square bracket so this looks like the place or rather this is the place where that particular rule is defined where a colon equal to 10 surrounded by bracket works is where uh is actually coming from this very statement and now if you see this very thing is something called as atom looks like an atomic statement uh the it has round bracket square bracket which looks like list comprehension normal dictionary or set maker having a name number string none true false oh yeah so this looks like an simple atomic statement that would be treated which could be a yield expression or a test list comp test list comp or a dictionary set maker uh with surrounded by brackets so this is the very rule that puts in that allows parenthesis uh that that allows a colon equal to 10 within parentheses to work just fine okay now let's find out why a colon equal to 10 without any parentheses doesn't work right so uh if you see we could not find any rule that shows us that it is allowed to have a normal statement like that right so what python does is python explicitly has set in an exception where assignment statements have been allowed like a equal to 10 is allowed is an explicit exception so in order to find where that is defined let's look out for uh quote equal to code well basically single quote equal to single word in order to find where this is used oh this looks ugly we'll skip all the ugly things and find out simple ones because i even i don't know what this is let's dive deep into some other time whenever i understand it it has something to do with ll parser sounds familiar with our compiler course uh ugly ugly ugly let's skip it skip it skip it wherever you wear our list variable argument list something similar uh this is this looks neat huh so this single quote sorry this single quote equal to single quote is part of an expression statement this expression statement is part of a small statement small statement is part of simple statement and simple statement is a statement so if you if it trace back it states that any statement is either a simple statement or a compound statement simple statement is small statement and a sequence of small statements separated by semicolon this is exactly why we can write multiple smaller statements followed by colon and this rule is the one that is actually allowing us to do that a small statement can be expression delete pass flow global non-local assert right so this looks very familiar and expression statement is testless star expression something to do with tesla star expression uh then an assign and assign is basically annotation assignment statement where you can have a type definition so for example a variable called a specified with type end and equal to one so a colon int equal to one should be allowed so this is where it's part of annotation assignment or this august sign is basically augmented assignment where you do plus equal to so a plus equal to 10 would be is is allowed by this and we have seen an explicit or and then we have an entire equal to part and then we have an equal to statement and then there is yield expression or testless star expression and then followed by a type commit so this is the place where assignment statements are explicitly allowed by the grammar right so now if we would want to allow uh let's say colon equal to right so we would be making change because where a equal to 10 is allowed we can obviously make a change and allow a colon equal to 10 so let's copy paste this entire thing and make a change to this grammar and let's say we allow just space and we put colon equal to here right so if we have this thing so with this thing what we have done it is we have not only allowed equal to like a equal to 10 but we have also stated allow a colon equal to 10 squared right so when we change any so this looks like something that would help us get rid of syntax error but let's find out uh when we change any grammar what we have to do do it is make uh we have to run a command called regen grammar make space region hyphen grammar it would regenerate the parser files for this grammar and and would and basically this grammar would actually take an effect uh it actually changes the parser file which is auto generated and then you would have to run normal make which would build your binary right so now we have compiled this code into uh so we have basically break this new grammar into our binary and see what happens so i'll run python.exe and first let's see that everything else is working fine a equal to 10 does this work it works we had a colon equal to 10 part of a parenthesis it should work it is working and now comes the part where we would want a colon equal to 10 to work let's run this it did not give any syntax error let's see if a is 10 it has let me change this value to 20 and see what happens a gets 20. so we got rid of a syntax error and we allowed a colon equal to 10 or equal and equal to 22 work just fine just as normal assignment expression right so this this this so we have successfully changed the grammar and got rid of a syntax error and something that look that should have been intuitive to do we have made it like we have made it work right so we got rid of the syntax error and we achieved what we wanted but but how come by by even by putting a colon equal to how how did you understand that we had to do an assignment this should be the critical question that one should be asking as in as in where exactly is that code that is treating this very thing as an equal to because we did not change anything in part of c we did not change any any file whatsoever the thing so this shell.file is something that we created grammar is what we change this is the grammar parser file that was auto generated but we did not explicitly handle a colon equal to to be treated as an assignment so where exactly is this coming from in order to do this let's look out for where expression statement is used let me just find expression statement in dot c files so when we look for it we get an ast.c which is an abstract syntax tree file for c and let's open this and what we get is we get and sorry yeah so we what so we get something called as an ast for expression statement which is how to which is how to parse and analyze expression statements so what we see is we it does so this is so this should be the one that is handling expression statement and which is the rule in which we made the change so anything that had to do with colon equal to should have been done over here uh it would have gone over here so now what we see is key it does nch what nch is nch gives n kind of n children which gives the count of number of children seems fair so it gets the number of children that it has so what it would have it is when i'll have a colon equal to 10 it would give me number of children to be 3 because it's like a colon equal to and 10 so 3 children of my this very statement if i do a equal to 10 again 3 here it checks for if num equal to equal to one which means if it has just one child as in if i just type a and then i hit enter then what i mean is i want to get the value of a and print it there right so this is what it would be doing so yeah so when number of child is one it is doing something it is doing for test list and returning null or if no error then it is returning an expression which is with basically treating this statement as a normal expression and evaluate it then it is doing if if this is and obviously in our case a colon equal to 10 is is is not falling over here then it comes over here it says the type of child first child of n so first child of n would be the operator which is like a colon equal to 10 by colon equal to would be the one if it is auger sign no it is not augmented assignment uh it is an augmentation assignment basically it's not plus equal to into equal to minus equal to it's it's school and equal to right so it's not an augmented assignment so this is going to be false so then what then it has is it an annotation assignment no it is not it does not fall into this either then let's move to the thing so it wouldn't go into this elsif as also and then there is this massive else it should be doing something interesting it checks for first cell to be equal to a normal assignment statement and hashtag does this type has type command something it's okay to not it's okay to not understand a few things at first even i don't understand this but it would help us understand it so we are just getting a gist of things so if we scroll down we see at the end it is returning a sign this is what is is treating a colon equal to as an assignment so since it was not an annotation assignment it was not an augmentation assignment or an augmented assignment it fall into this final else block where as part of return it is actually doing it is actually returning an assign node which treats my entire expression as an assignment statement and it does the needful right so now we know why without handling so without explicitly handling colon equal to we were able to we were able to uh basically uh implement a normal assignment flow while using a colon equator right so this is fun right how how uh how basically without even changing the c part of it without explicitly handling a colon equal to we were able to basically mimic the behavior that we wanted to uh so that is it for this video i hope you guys had fun i've written a very detailed article about it titled the weird walrus and have put the link in the description below uh go ahead and check that out uh you saw how easy it was for us to change grammar and implement uh implement an interesting functionality uh uh without really understanding the internals of c python uh i hope this paves way for you to explore the c python internals uh basically that is it from me uh if you guys like this video give this video a thumbs up if you like what i do with c python give this channel a sub uh i'll see you in the next one thanks a ton