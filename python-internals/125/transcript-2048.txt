so in this video, we'll be going through a really interesting integer optimization of python.
uh, as per official c documentation of python, it suggests that the current implementation keeps an array of integer objects for all integers between minus 5 and 56.
when you create an int in that range, as in the range minus 5 to 256, you just get back a reference to the existing object.
this means that python is creating singleton instances of minor of all the integers in the range minus 5 to 256, right, really interesting.
so instead of creating new objects every time, python is preallocating all the integers in the range minus 5 to 256, and whenever we need an integer in that range, instead of creating a new instance, it would give us an existing pre-allocated instance, right?
uh, and in this one, what we'll be doing is we'll be going through c python source code, like always, and find out exactly how python does it, but before we do it, let's first ensure that what we see is actually right.
uh, what i'll do is i'll create- i'll take a variable- 256, a equal to 56, be equal to 256, and i do: a is b, and it gives me true.
so this is indeed true, that uh, the value 256, a and b.
so when i do a is b, it just checks that if both the variables point to the same object or not.
and for two, for the value 256, a is b is true, while for 257, a is b is actually false.
this implies that python indeed is uh, is somehow actually caching this integers.
i'll do a pylon from long so that we understand how it is actually doing.
the function is defined in long object dot h.
yeah, here it is right, line number 173.
so here, when we start going through this function, we immediately encounter this line.
it says that a small end.
so this function is basically trying to create a pylon object from a long variable.
so from i well, which is of type long, it is trying to create a pylon object.
so it checks, if my eye well, is actually a small end.
it invokes a function called get smallent and immediately returns.
it is basically allocating the new long object, right.
so, which means the magic is happening right here.
so, because this is where it is checking if it is a small hint or not, if it is smaller, then just do a get smallent.
then it invokes get small, and it must be doing some lookup or something, and it simply returns from here.
so let's first see what a small int is.
so when i open this small end, the macro definition, what we get is a small end.
it checks for minus n small negan's less than equal to i well, and, and i well, less than n small percents.
so let's see what n small negatives is.
yeah, so n small negan's is 5, while n small poisons is 257.
so n small negan's instead of it.
it's not minus 5, but it's 5, while n small poisons is 257, and this is really well implemented.
so what it has done is a small int, the macro definition.
so instead of setting n small negan's to be equal to minus, my test set it as 5.
uh, why the python code developers have actually chosen to do so.
and here it checks for minus n small negative, basically minus 5 less than equal to i.
it means that it is doing a minus 5.
so minus 5 to 256 is where a small int macro would would.
so if is small, lint is true.
so if i am asking for an integer in the range minus 5 to 256, both inclusive, it would invoke this function get smallent.
and, uh, it first asserts that it is small and that's okay, and then it invokes a function called pi long underscore, get small into underscore internal.
uh gets pi object and increases the reference and it returns it.
so the magic would be happening in pylon underscore: get small and internal.
then it computes the index and then it uh fetches the object from this small lens array at this, at this, at this very index, and then it returns the object.
so the small ends in the in the uh, uh, so the small ends array inside, enter p or basically the entropy as the global interpreter state, uh, in which it is holding all the objects, all the pi objects, within this array.
and what this function is doing is it is computing the index, uh, given the value, it is computing index to be equal to my uh, to be equal to pi small negan's plus value.
so the uh recall that pi small negan's was stored as was defined as 5 and not minus 5.
because of that, what we can directly do is to compute the index at which the value would be stored.
we can directly do, uh, we can directly do pi, small, so basically pi and small negan's plus value.
instead of doing minus 5 and then multiplying it by minus 1 to make it positive and then doing plus something, which is obviously much more computationally intensive, what we are actually, or what a python chord have actually done, is they have taken uh, pi, small negan's to be positive and just by and just, while comparing, they are prepending a negative sign.
so minus x, right?
so basically minus 5 is what you need during comparison and for every other computation out there.
so now that we have the index, uh, it just goes through this small end array and it gets the object and it returns.
so let's see how the small end array is defined.
so yeah, indeed, small end is an area of pylon objects of length, pi and small negatives plus pi and small position.
so basically, 5 plus 257 is how it has actually computed this thing.
so pi plus 257 is equal to 262..
so the array is of size 262, within which it would store the the pylon objects from -5 to 256, both inclusive.
so now let's see how small it is actually populated, because, uh, there has to be a place where it is actually initializing this thing.
and this we already went through in long object dot c.
this is command, that's okay and yeah, so this is an interesting function.
what it does is it says that the function name is pylon end, sorry, pi long init.
so this looks like an initialization function of long module, and what it is doing is it is going through all values from 0 to n small negan's plus n small causes, basically all possible values that needs to be cached.
uh, now, what it is doing is it is then, uh, it is then actually finding out the value that needs to be saved.
so a kind of like 0, 2, 2 or 0 to 262 will be mapped to -5 to 250, uh, 256, right, and this is where that happens.
so the i, well, would have values from -5 to 256, but my i is from 0 to 262, right?
so now, given this i1, what it is doing is it is actually storing here.
so in the enter p arrow, small lines of i, i is the index, so index is from 0 to 262 and within which it is storing v.
v is the pi long object which is being created.
so, uh, during this initialization it is indeed creating, uh, uh, it is indeed creating long objects for the range minus 5 to 256 and holding these objects for in the array from index 0 to 262, right?
so, uh, basically, this is where, uh, our cash is being initialized, right?
so next time when someone asks for it, it just computes the index, goes to that particular location, fetches the object and returns it, right?
uh, where is it exactly storing the value in the pylon object?
these are internals of how pylon object is implemented.
i have written a detailed article about implementation of pylon.
you'll learn a lot about internals and how python actually implements long integers.
but, uh, now, basically, this is the gist of the entire thing, right?
basically, this is where our cache is being initialized, with all values from -5 to 262..
what we do is we have looked for all- no, we haven't looked for all- instances of small end.
the next instance is this: what it does is it does it is there in the function called pylon dot.
pylon underscore fini looks like something to finish about, uh, more like a destructor sort of thing.
well, it is iterating for all the elements in the array small ends and just doing a pi clear, basically, d allocating everything that it is allocated.
now, coming back to the place where we started, and what we do is, by long, just waiting for it to come, yeah, here.
so we started from pylon underscore from long and we saw how it did this.
let's look for get small intensity where all uh it is using this.
so get small end is using uh is being used for pi long from u wind.
basically, unsigned integer makes sense anytime we are.
we are trying to create a pylon object from an unsigned integer.
we are checking this thing: pi long from long, long.
so, uh, from the value long, long end, if you are trying to create a pylon object, at that time it is doing the small in check and then returning smalling.
so primarily, every time we are trying to create a pylon object, we would be seeing this sort of check from pylon underscore, from size st, make sense.
so any time we are creating a pylon object from anything, we are adding this check where we are checking if it is a small end.
if it is a small end, then just return a get smaller, right, so use the existing reference instead of creating a new thing out of it.
so yeah, basically.
and now we know how python actually optimizes integers, how python caches it, and we have seen the internals of it.
i hope you are now much more comfortable browsing through the code base and understanding how python implements login.
i would heavily recommend go through the article which i'll be putting in the description to understand the internal workings of pylon.
it's really fascinating and it's really amazing on how python has optimized the storage of long end, because typically python does not bind or it or it does not have any limitation on how big an integer can be.
it is i'll also uh put article for this topic, uh about, uh, integer caching in python, in the description below.
i've also done a really interesting benchmark- not really a benchmark, but more of a visualization- on how many object references are there for values from the range minus 5 to 256, so that we understand that, yeah, indeed, these objects are being used those many times and they require to be cached.
so one main reason why python did caching of small integers: because we, because co-developers- actually observed that smaller indexes or smaller integer values are used quite a lot as compared to larger values, because they are used in indexing, they are used in some basic computations and what not.
so smaller integers are used at much more places.
so it made sense to not allocate those objects again and again, but rather reuse it.
uh, if you guys like this video found this thing helpful, give this video a big thumbs up.