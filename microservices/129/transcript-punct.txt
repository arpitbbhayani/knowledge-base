so micro services are extremely tempting. you will always feel like writing a new service to solve every single problem at hand. you can go to a very fine granular level to write a microservice for every single micro requirement you have, versus you can keep a lot of them together and and solve a bigger problem right. but which one of these approaches the best approach? how can we decide whether we need a micro? we need a separate microservice to solve this, to solve this specific problem? in the previous video, we talked about the advantages of having a microservices based architecture, and in this one, we talk about ways to model a robust and flexible architecture using just two concepts: low coupling and high cohesion. but before we move forward, i'd want to talk to you about a code based course on system design that i have been running since march 2021. right, if you're looking to learn system design from the first principles, this course is for you. yeah, because this is a cohort based course. it will not just be me rambling a semi-optimized solution, thinking it's the most amazing solution out there. instead, it will be a collaborative environment where every single person who is part of the cohort will can pitch in his or her ideas and we will evolve our system around that right. every single problem statement comes with a brainstorming session where we all together brainstorm and evolve our system. that's why everyone understands the kind of trade-offs we made while making that decision. instead of just saying, hey, we'll use a particular queue, will have the justification why we use only that queue, why we use that particular database, why sequel? why not no sql right? how are we leveraging throughput? how are we ensuring that our system scales? that's the highlight of this course. this course is taken by more than 500 engineers to date, spanning nine countries and seven cohorts right? people from all top companies have taken this course and the outline is very intriguing. it's very exciting. so we start with week one around. we start with the core foundation of the course where we design online offline indicator. then we try to design our own medium. then we go into database, where we go in depth of database logging and take and see few very amazing examples of data log or database logging in in action and how do we ensure that our system scales through that. then the third week is all about going distributed, where we design our load balancer. i'll walk you through the actual code of of a toy load balancer and understand how tcp connections are managed and how simple it is to build load balancer. then week four is about all about social networks. week five is all about building your own storage engines. like we'll build that intuition on: if you were to ever design your storage agent, how would you do that? right? then week six is about building high throughput system. seven is about building uh ir systems, basically information retrieval systems, and adult designs where we design our own message brokers, like sqs, where we design distributed task scheduler. and we conclude the course with week eight where we talk about the super clever algorithms that has powered or that has made those systems possible. right, i have also attached a video, verbatim as is, from my first code where we designed and scaled instagram notifications. i will highly encourage you to check this video out. right? and now back to the video. so it is always exciting to create a new micro service. there are so many things to look forward to like, so many new things like, for example, you get to work on a fresh code base, which means that you can- you can- bury down all of your legacy not so optimized, not so well written code base in the past and start afresh. that that gives you this new perspective where you can use a lot of good practices, design patterns and what not to build the best possible solution to solve that particular problem. you can pick your own tech stack, and that is much more exciting than anything else because you get to learn new things, you get to explore new uh databases, libraries, frameworks and whatnot you can. you can build your own fresh ci cd setup versus using that same legacy thing, like writing a script or something. you can start afresh. so you are, you can very well bury down all of your past mistakes and start afresh to solve this problem, and that is always more exciting than anything, than anything else. but is that the best way? so that is where we need to think upon: hey, what happens if we do not create a microservice? what happens if we do not fence it? well, what? what do i mean when i say fancy 12.? so when we are fencing something, we need to define a very rigid boundary on what exactly would a particular service would solve, right? so now what could happen is you can have a very big boundary or you can have a very small one. so if you have a very big boundary, you are putting in a lot of components, which means you have too few of your micro services. when you have too few of the micro services, what happens is there are lot of teams who would be collaborating on the same code base or on the same service. with this, what happens is a breaking. change in one component would take down the entire service. deployment would be slower because changing in one component, deciding to deploy that service, would require you to take approval from that other team, right? so having a too few of the microservice might not be the best choice, right? but having too many of them either, is not a good choice. so what happens is, if you have too many of microservices, then you might end up having a mess of interconnected and interdependent subsystems, and you would be, you would be plucking your hair out: key- which component is talking to which other component and how that is happening. and if one goes down, then there is this ripple effect which takes our entire infrared on, and there are so many things that could go wrong. so having too few is not a good choice. having too many is not a good choice either. so then, how should we approach it? so this is a classic dilemma. on basically none of the choices seem better, and obviously we know that the middle ground works the best. but how right? that is what we would be answering in this one. so we would be defining two guiding principles that would help us design or that would help us model the micro services such that they are not too big or they are not too small either. so the two concepts that we talk about here is loose coupling and high cohesion. loose coupling in loose sense is when you change something in one service, it should not require a change in another, which means two services are loosely coupled to each other. you are flexible enough to change one service, architecture of one service, cicd of one service and whatnot, or the entire tech stack, everything in one service without having other service to even know about it. right? so that is what loose coupling is all about. and the second one is high cohesion. cohesion with respect to you clubbing the related components together. you don't want to break it two minute where your related components sit separately. then you will have a lot of inter-service communication and a lot of cascading failures because of one component going down, and so the idea here is: keep all of your related components together, no matter if it results that service to be a gigantic one. that is okay, so long as the related components are together, right, so these are two key things that we would be discussing in detail. uh, moving forward and so that it would help us build a very robust, flexible and extensible architecture. right, so we'll start with loose coupling. so loose coupling, as i just said, it's changing one service should not require change in another one. so this, in general, is the core ideology behind any micro service like like. this is the ideology with which a micro services based architecture even started. okay, so the idea is: let's say, you have two services and orders and logistics. they have their own tech stack. one isn't written in java, another one is written in golang- right, but the way these two services communicate, it could be an api contract, it could be synchronous communication, could be asynchronous communication, could be anything, but the communication is always through this interfacing layers. it is not something that one breaches into other and have this sort of tight coupling between them. so so long as the in like, if orders want to communicate to logistic service, this interfacing layer talk to each other could be rest api, grpc, raw tcp connections, what not right. but so long as these two interfacing layers do not change the api contract, do not change the change in one service. let's say order service is transparent to logistics, so logistics do not care on how order services model, which database it chooses and what. not, so long as interfacing listing remains the same, there is no requiring like order service change, no required to change the logistics part of it. but it's easy to say in theory: we need abc or we need loose coupling and all. but how do we even achieve that? so few things to remember is a service should know as little as it needs about other service. for example, when logistics service or when order service is talking to logistics service, order service does not need to know the architecture of logistics services, does not need to know you know what kind of database it is using, or does not even need to know the credentials of those databases, right? so which is where what we do is we can have a very broad guidelines. depends on the organization, on what kind of interoperability or what kind of transparency do you need from that other system, like what kind of information is allowed for you to be exposed? so a few basic things that we can think about is: hey, does a service like. does order service needs to know public api is a logistics service? yes, because it might need to call it. does order service need authentication apis for logistic service? yes, otherwise, how would order service call logistics service? does order service require it to know the database of logistics service? probably no, because order service will never connect to the database. ideally it should not, right? then rate limits: yes, order service need to know the rate limits of- uh, the logistics service. otherwise, if auto service bombards a lot of requested logistics service, it can get overwhelmed. it will have its own rate limiter. you will say: area, something is breaking. there will be clashes between the team and whatnot. so you need to know rate limits of the logistics service. and communication protocol: hell yes, otherwise, if you are talking in dressed, other one is using grpc, then you'll see here, how am i communicating? you need to know the end points. you need to know if it's tcp, if it's over grpc, if it's web sockets, if it's what. right. you need to know the api contracts behind it, right? so expose as minimal of an information about one service to the world. what is it? your internal infrastructure, right? so if a service knows too much about other service, this typically leads to tight coupling. a small, a simple example of this: if your order service know that your logistics uses a my sequel database and it knows the credential, then the order service might actually talk to the database directly to get that information, rather than going through this. rather than going through this interfacing layer of logistics service, it would directly connect to the database to get that information. and now what happens? if logistics service, without informing order service, changes to move from is equal to mongodb, order service would fail, right. so that is where, in order to have a seamless communication between the two services or in order to have low coupling between the two services, it is better to keep the information masked. you don't need to share unnecessary information to other teams, right, so to other services. so that is where you would see isolation as one of the key requirements whenever you go into a microservices phase architecture where you are not even exposing the db or the db credentials or any other internal details from of one service to another service. right to allow, to allow low or to allow lose coupling. right. otherwise, if this happens and if logic service decides to upgrade the database or change the database, then order service is unnecessarily impacted and if orders go down, it takes everybody with it, right? so you don't know the ripple effect. that is where it is always better to have those very rigid boundaries here. i am not telling you this information, no matter what you do right? the second and the final point that we discuss is high cohesion. so what high cohesion means is related behavior, not services. related behavior sits together, right. so, for example, payment service requires payments worker- they sit together in one code base- and payment service three apis: make payment, del, uh, make payment, revoke payment transfer. and what thought they said? you don't need to create separate services for that. give one to make the payment, another to refund the payment. that's a very stupid way of doing it. make all of your related components sit together in one micro service and expose all of those endpoints together. and when? when we say related coupons together, it is equally important to specify that unrelated components sit separately, because if unlimited components sit together in one place, then again that same problem comes up: change in one affects the other. we will talk about that detail in few minutes. so the core idea behind high cohesion is: services should operate independently if you have related components sitting together, working in a close knit team or teams like a couple of teams, it is always faster for you to roll out the new changes to it. if you have two separate components sitting together in one place, then deploying changes in one would require both the teams to be known. for example, hypothetically, in order service you have orders module and customer model. so anyone who needs customer model model also talks to this service and someone who needs order details also talks to this service. now, when you have that, if you change one module, you will need to get approval from the other team to deploy your changes because both of you are sharing the same code. suppose if you're sharing the same micro service, so it would make a development slower. it would have this entertaining dependency, unnecessary entertainment, dependency for two seemingly unrelated things, right? so, which is where you would always need to keep in mind that, hey, ask this question: i am trying to put these two modules on this microservice. are these two related? if they are yes, go ahead and put it. if they are not, create a separate service out of it. this way, you would gain reusability and that is much, much, much advantageous than anything else. one classic example, classic example of having this would say: hey, when? when does it happen? when, like, two services will share the same codepersonal? it's really practical. i'll give you an example. let's say our company started, and it started with a monolith, because you know you need speed of deployment and speed of development and you don't need over complexity. you don't even know your business is going to survive or not. so you started with the monolith architecture and then you decided to move into micro services based architecture. now what would happen? from monolith to microservices, you, not like, all of a sudden rewrite the entire code, right? you would want to show continuous progress to your senior management, which is when you say, hey, because all of my code base is already residing in my monolithic code base, let me create a new service out of it which uses the same code base, right, and it only exposes. let's say, you have two apis, uh. let's say you're monolith. you have, uh, all the codes about. you have profiles, uh, orders, customers, logistics, everything right, and you were serving it very well. now you know that, hey, logistics needs a separate service of its own. so you keep the monolith assist. you create the same code base, right? you, sorry, you create a micro service using the same code base, but it only exposes the logistics apis. it does not export, uh, the the other monolithic apis. right? so now you have a monolith that has commented out the logistics endpoint and you have the logistics service that has commented out non-logistic endpoints, but both are using the same code base. now, what would happen if someone changes the code base? right, so both of these services would need to be deployed because both of, because the code base change, both of them would be would have to be redeployed so that the new changes reflect. now they might be using a same module whose logic is changed, so both of them would need to be redeployed at the exact same time. and that is a much bigger problem, or a much bigger headache. right, because this way you are again going into this. this strong coupling between the two systems, like your monolith and your logistics service, unnecessarily unnecessarily, and deploying multiple services at once is more risky than anything. what if one of the service goes down due to any reason while deploying, some bug happened and that service is not starting, but the over the other service is deployed with the new changes? very messy situation, which is where, whenever you are transitioning, always ensure, whenever you have this situation where you are sharing things. always ensure that you have this very strict, rigid boundaries on how you would want to fork those things out. otherwise unnecessary complications, deploying multiple services at once, plus depending on other teams to get that approval to do the deployment- very messy. so always stay back from these sort of complications and keep things extremely simple, because good architectures are always simple. good architectures are never complex. it is very simple to understand the flow, the dependency, the coupling, everything right. so hence, whenever you see the requirements in, whenever you want to decide if you want to create a separate microservice for this to solve this specific problem, ask this question like: how do you fence it is? are these two components, uh, tightly coupled or loosely coupled? if they are loosely coupled, then is the communication very robust? is it transparent enough? is on, and then you pick that component and see: are all the related entities or are all the related behaviors or functionalities, are part of this one service or not, or are they spanning cross service? right, try to avoid as much of cross service communication as possible because it would make things slower. so don't create an interconnected mess out of your architecture. nice, so yeah, that's it for this video. i hope you learned. like i hope. i gave you a basic, broad guidelines on what to and how to approach it. all that was very subjective, but in future videos we will dive deeper into each one of them to understand, like exactly how. i will take very detailed example of this to understand: hey, this is where we are splitting. this api should not lie here, should go here, something that i'm planning very soon, nice challah. so that's it for this video. again, if you guys like this video, give this video a thumbs up. if you guys like the channel, give this channel a sub. i post three in-depth engineering videos every week like this, and i'll see you in the next one. thanks again.