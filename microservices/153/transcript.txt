so everyone is doing microservices but what are they after all from a distance it looks like a function put over the network is it really just that there are so many things to explore about microservices so let me introduce you to this amazing world today in this video we talk about what are microservices understand how it all begins with a very simple monolith eventually to evolve into micro services based architecture look at their key characteristics understand their advantages and conclude with some anti-patterns that we all should keep in mind to ensure that we are not doing it wrong but before we move forward i'd like to talk to you about a course on system design that i have been running for over a year now the course is a cohort based course which means i won't be rambling a solution and it will not be a monologue instead a small focused group of 50 60 engineers every cohort will be brainstorming systems and designing it together this way we build a solid system and learn from each other's experiences the course to date is enrolled by 600 plus engineers spanning nine cohorts and 10 countries engineers from companies like google microsoft github slack facebook tesla yelp flipkart dream 11 and many many many more have taken this course and have some wonderful things to say the coolest part about the course is the depth we go into and the breath we cover we cover topics ranging from real-time text communication for slack to designing our own toy load balancer to greek buses live text commentary to doing impressions counting at scale for any advertisement business in all we would cover roughly 28 questions and the detailed curriculum uh split week by week can be found on the course page which is linked in the description down below so if you're looking to learn system design from the first principles you will love this course i have two offerings for you the first one is the live cohort discourse which you see on the left side and the second one is the recorded course which you can see on the right side the live code base course happens every two months and it will go on for eight weeks while the recorded course contains the recordings from one of the past cohorts as is if you are in a hurry and want to binge learn system design i would highly recommend you going for the recorded one otherwise the live code is where you can participate and discuss things live with me and the entire cohort and amplify your learnings the decision is totally up to you the course details prerequisites testimonials can be found on the course page at fifth birthday dot me slash master class and i would highly recommend you to check that out i put the link of the course in the description down below so if you are interested to learn system design go for it check out the link in the description down below and i hope to see you in my next cohort thanks so what are micro services a theoretical definition of microservices say that they are processes slash workflows that are highly maintainable and loosely coupled to many journals right let me simplify it for you the way i would like to put it is micro services are like reusable functions the functions that we normally write in our code like that but little bigger with a bigger set of responsibilities and put over the network that's all what are micro services right when it comes to words like highly maintainable and loosely coupled it's more about that given that a service would be having a limited set of responsibility it would be easy to maintain it if your code base grows big you find it hard to navigate through it you find it difficult to understand hey what all functions are there how how do i call and you know what all things happen it becomes hard to maintain or hard to even build on top of it right so that is where microservices come in very handy they are very or they are highly maintainable because they operate with a very limited set of responsibility but they do it very well second point around loose coupling is all about how two services should not very closely depend on each other it should be more about that if i would want to change a tech stack of a particular service i should be able to do it if one of the service goes down a lot of service should not be impacted right this is about highly maintainable and loose coupling we'll talk about this in detail in some time so micro services are typically structured around business teams so it is a true fact that engineers exist because business exists otherwise we don't really have any job right so the way an organization is typically structured like you might have a team that does analytics you might have a team that takes care of a certain function so depending on what your business needs is depending on any new feature that your business wants to start if any new thing that a business wants to introduce that the business typically creates a small team of people not engineers but in general a small team of people whose only responsibility is to ensure that that thing is done perfectly right take this concept and put it into this one so when a business is creating a team of focused individuals to get a particular task done that particular set of people or that particular set of product features and all evolves into or they own this particular part of microservice like it's basically a one-to-one mapping from the business side to the product side right so for example you started with a free product but now you would want to have a paid product you would want to introduce payments so that is where you might work you would create a service that handles payments for you everything around payment goes over here it exposes the necessary functions that your application can use to get everything done around payment and there would be a focus set of team looking after payments similarly there will be a focus set of people looking after analytics a focus set of people looking after notification so that those set of people can do that one thing really really really well this is the idea around how we structure micro services with respect to business requirement now when you have these services now these services are basically a set of instances who do one thing very well for example the profile service will be a bunch of instances all running a profile code or every function that is required by or or that constitutes to be part of your profile service and when profile and notification wants to talk to each other there are the communication happens over some well-defined apis so every service exposes a set of apis for every other service to consume right and this is how like this is typically your office where you have to do let's say you are an engineer and you want to uh get a new laptop will you go and get that laptop from the shop and use it no you'll ask your itt id team will get you the laptop and ship it to you exact same thing so ip it's all your id team might have exposed an interface which says hey please create a ticket on any of your ticketing tool and then we will procure the laptop and give it to you correct so the ticketing tool is the api that is exposed you are consuming that api it team is going and procuring the laptop for you and handing it out to you that is exactly how your for companies function that is exactly how microservices are structured so what are we trying to optimize by going for micro sizes what if i put everything into one code base right so microservices they try to optimize typically two things first is rapid feature delivery that when if you are just putting all of your code into one codebase it becomes highly unmaintainable becomes overwhelming for most developers and it takes time for you to add new features to it as time passes or as the code break or as the code base becomes little more complex right so that is where over time you would see the speed of delivery of features products uh and what all it reduces so that is where by having a micro services based architecture it is trying to optimize for rapid feature delivery so that when a focus set of people are only working on that one set of service it is easy to make changes there because it's a very small code base it's a gigantic code base second is it's easy to upgrade the stack so for example i can choose the best stack possible for a particular service and then if let's say i want to upgrade let's say i was using python and now i'd say hey golang is a new shiny thing and it would give us very solid advantages if we move to if you move our payment service to that so then you would go for it it would be easy because there is no close coupling between the two services what would happen is you can independently upgrade your stack from python to go live no one else would have to know because everyone's just using the apis to talk to your service it's all happening over network they don't know what internals are how you evolve so these are two key advantages or two key reasons or two key things that micro services try to optimize right and obviously micro service is not a silver bullet it's not a thing that would solve all of your problems it has its own set of drawbacks and it's not something magical that hey i'll just adopt microsoft and everything would be sort but before we talk about that let's just see how things evolve so most microservices architecture they they never start as micro service architecture they start with a simple monolith architecture so what is a monolith monolith is i the idea of monolith is pretty simple have one code base put everything inside it right and it's not that these are different processes it's more like these are different modules you are just just invoking the function and getting things done so most product most product out there starts as a monolith may be written in django java springboard pick your favorite framework and all but everything is put into this one code base and where they start and then because you don't know when you're starting up you don't know if you'd even survive for a year or not why to think about microservices on day zero so most of them start with the monolith everything is part of this one code base and it's just that one deploy thing or one thing which is deployed across all ec2 instances right easy transit any instances in your production environment right so everything is part of this one code base one deployable artifact which is deployed across all of your machines and this and is talking to a few set of databases this is your typical monolith architecture where everything is just everything is part of this one code base and that one code base is deployed across all of your machines right but then folks slowly move out of this mono because as code base because everything is part of this one code base or one thing which is deployed so then what happens if you would want to you know if you would want to it's it's easy to develop like obviously you just don't have to clone multiple git repositories and work on it and all it's just one code base to rule them all one time deployment everything gets shipped and it seems very simple and to be honest when a company is starting up you don't have to think about micro services you start with monolith and get things done right there are solid advantages and that's why most startups starts here and then when they realize okay now we are in market for next three or four years and our monolith is becoming a bottleneck let me move to microservices so key advantage of going for monolith would be simple to develop you just have one code base to do it simple to build there is just one artifact that gets built your jar your code base or binary just one thing that gets tripled across all machines it's easy to test it's just one thing to test like one code base to test someone just spinning up or running a web server on that you can just test on that one input you don't have to remember multiple endpoints to do it and it's easy to scale like there is just one thing to be deployed you would want you are not able to handle load add more machines to it everyone is just identical copy of itself it's so so so so simple to do it right that's why everyone starts with not every most of them starts with the monolith some over engineering folks are there to start with micro services i would personally not recommend that start monolith keep it simple once you know you are in market for a long run then you break into micro services let it become a problem and then solve it right but there are disadvantages disadvantages of going monolith so you might not realize this problem on day zero but as time passes and your code base grows or your complexity grows you would start to realize these are these disadvantages of going with monolithic architecture first is tight coupling between modules because all of them are part of this same code base they're having very strong inter-module dependency like for example you import a package in python you know that that function is written in some payments module although it's a util function written in payment module you just import from payments import that util function right unnecessary dependency between modules there will be very tight coupling between these modules so then harder to break right second is your containers or your binary or your deployment artifact are bulky because you have one code base or one thing which is deployed across all machines over time this deployment artifact will grow big big brick pick it would grow to 1 mb 2 mb 5 mb 30 mb 100 mb it could grow that big so what happens is deployment would start to take time loading of your application would take time overall consumption of your infrastructure would take time or would be a little higher right third is you'd have to have homogeneous and single tech stack because you have this one code base that has everything because your architecture is monolith everything is part of this one code base so the text tag that you are picking the database offering everyone has to use that the language that you are picking everyone has to use it it's a homogeneous single text otherwise how would you do function calls right it is homogeneous single tech stack that you would have to work with then the next disadvantage is bug in one module affects others for example if let's say there was a semicolon missing or some random bug that was there that prevented that module from loading but it's not that only that module is loading when the application is started when monolith is starting it would load all the modules so then because of that one bug the entire production would go down because the web server itself is not starting right so bug in one module affecting everyone else right this would happen when your team grows big when there are multiple deployments happening in a day or multiple changes going into production every single day the next is scaling one module requires scaling everything again because you only have one artifact and that one thing is deployed across all the machines if let's say you are getting higher traffic on payments you would want to add more instances to it so unnecessarily everything is scaled up because it's all part of this one thing right it is all part of this one artifact so scaling is not precisely i can i don't i just want to scale up my this payments function and not everything else but you cannot do it right because it's all one artifact so eventually your overall infrastructure utilization goes down when you are growing in your monolith because you are over provisioning for a particular set of function but unnecessarily everything else also gets loaded the next disadvantage is large monolithic code base is intimidating to most developers and it eventually slow down to a delivery right because there are so many things so many functions so many things to look at it becomes very intimidating that you and given that you know that there is like if you introduce a bug it would take your entire production down so even developers would think twice before making any changes to that right so the code base becomes intimidating the risk of production going down increases and it eventually slows down your uh delivery speed right these are some solid disadvantages of going with monitors but obvious this does not mean we should not start we should start with monolith when you have a lean team then think about going into microservices let's talk about how we can evolve or how we typically evolve from monolith to microservices it would sound theoretical but i'll try to make it as practical as possible so monolith to microservices so we know that we all start with monolith but now we have to go to microservices because of all the disadvantages we discussed so how should we approach the idea is pretty simple when you go from monolith to microservices you would typically be clubbing functions or grouping functions that do related work and create a micro service out of it for example all the functions related to user profile can be clubbed together and given its own code base its own set of infrastructure to run profile service exposing a proper set of api interfaces right so the idea would be when you're transitioning from monolith to microservices you start extremely small extremely is the keyword you start extremely small pick a particular set of module and try to fork out things or try to club the functions that you want it to go into one microservice and you create that and then let everyone else who was initially just doing a function call here are making network calls to that particular service for example you chose to hey let me separate out my profile service so you separated out profile service put it over a network and created its own micro service now what you will need to do is anyone who is requiring any profile information first it was just making a function call which would get it from the db and all now they would make a network call to get it from that particular service right and slowly and steadily you start clubbing all functions or all related functions and create separate micro services out of it so eventually you might have a profile service which is written in python using mongodb to store that information a notification service written in node.js and using dynamodb to store it an analytic service that uses java as its tech stack and uses amazon red ship as a data warehouse and a payment service written in very performant golang and using mysql as its database right slowly you will start fred is spreading out and eventually your architecture would become entirely entirely micro services based and you will be getting rid of monolith right so that is how your transition and the way we would be transitioning in from micro service to monolith there are ways to do it will be talking into this series as we move forward don't want to over complicate it right now but the idea is to take very small steps and then move forward now let's talk about characteristics of micro services so obviously micro services are great advantages and all are okay but what are key characteristics that are essential for a micro service so the first characteristic of a mic of any micro services based architecture is autonomous like every micro service based architecture is autonomous such that every micro service in itself is independent in taking its own decision and driving its own operation decision with respect to tech stack decision with respect to storage decision with respect to api contract right decision with respect to the kind of infrastructure on which it needs to run okay and this is evolutionary so if it wants to upgrade its text stack if it's one if it wants to change its database let's say from mongodb wants to move back move to let's say mysql it is independent to do so because everyone else is talking over apis to this particular service so a particular microservice in itself is autonomous in nature independent to take its own decision second it's specialized every micro service that you create is very specialized which is focused on solving just one problem really well for example your profile service would do the best it can to ensure that getting a profile of a user is it does in a very optimal way for example it might use mongodb as its database but it might have an optional caching layer that ensures that when you request for a particular profile information you get it as soon as possible it would pick the right set of or it would pick the right tech stack to do that particular job so focus set of responsibilities but doing it really very well right in the most optimal way possible third a micro service is typically built for business when i say this built for business it means for a particular business need for example we didn't have payments but i want to introduce payment so let payment be a separate microservice which is taken care by a separate team whose only responsibility is to ensure that payment service never goes down and is very robust resilient and performant right so this is how you would think about micro services so a business product feature requirement mapping directly to one of the service that you have right well let's talk about advantages of microsoft just will just skim through it there is already a detailed video of it in this series but just to skim through it the advantages of adopting microservices-based architecture number one agility because it's a small team of focused engineers working on that one problem really when they can move very fast second is scaling your scaling of a service is very precise because now if you're getting large traffic on your let's say notification service only those set of machines needs to scale so it is very much possible that your notification service might have 100 machines but a profile service might have 10 and your payment service might only have two so you can define a very precise scaling strategy for each one of your service giving you or ensuring that you utilize your infrastructure very well third is take freedom picking the right stack for your service we have talked about it so much right bringing the right stack to solve that problem to solve that one problem really well fourth it's very simple to understand because your mono uh because your micro service is just a small code base that does that one thing really well it is become it becomes very simple for anyone to understand because that would be like 10 or 15 functionalities that it would be driving so any new engineer onboarded into your team it becomes very simple for him or her to do it next is reusability of resource so for example this is the key thing the way we uh arrange our low level code we try to create functions whenever we would want to have a reusable component we know that time to string is something that would be used across all the models let me create a common function out of it and you just invoke that function right so that you don't have to write that same logic again and again right same thing goes over here with micro services based architecture the micro service that you create is reusable so anyone let's say you create a micro service for profile information any service that ever needs profile information would go to this service and get the data so they don't have to do anything on their own they would just talk to the service and get those things done why to reinvent the wheel when you can reuse right and another is the last advantage of that that we'll discuss is faster defect isolation let's say a particular service went down it becomes very easy for you to isolate that service very quickly for example circuit breaker pattern in itself does this very thing so for example you are making a call to profile service and let's say profile service is down so you can stop making calls to profile service as part of your configuration it is very easy to do so right in some cases it is unavoidable and everything else would go down but in case you'd want to have this defect isolation where if a particular service is malfunctioning due to downtime or a bug or something you can quickly stop sending your request to that particular service right so it's very quickly it is very efficient and quick to isolate the defect in your infrastructure that i'll not make calls to this service until it until the issue is resolved right now the final thing to conclude over here most important thing of all anti-patterns grass is not always green again you have to keep in mind these three things when you are either starting with microservices moving from monolith to microservices or starting your own company or just building your product from scratch these anti-patterns is very important so that you don't do micro services wrong first one of them do not start with micro services micro services is typically not a day zero architecture your daisy architecture should be a monolithic architecture where you are optimizing for the speed of delivery you are optimizing for because your team is small if you spend time doing micro services and all it would take a longer time for you to develop things with micro services it becomes very simple oh sorry with monolith because very simple you just have one code base five engineers working on that one code base to get things done because you don't even know if you would survive the market or not right next is do not make your services too small it's typical it's habitual that you think hey every function can become its own service this is very focused responsibility no don't create a service for each function it would make your network choke it would have a lot of uh network i o that would be required to do and it would increase your overall latency so don't don't make your services too small or too big there has to be a sweet spot between it it's called uh loose coupling and high cohesion a very simple strategy to do it is club all related functions together and create a service out of it it should not just be one or two things that that service does right understand that it should do just enough that it qualifies to be a big uh reusable service right and third use as many tools as possible when it's it's typically observed that when we are working in microservices space architecture we think hey i'll write this from scratch or or i'll or for example i'll do a particular thing from scratch even though the tools exist to get that exact same thing done as an engineer we have this urge of creating things from scratch don't do it use existing tools as much as you can so that you don't reinvent it like would you rebuild a load balancer no you would use what's available in the market right you would have that urge to think about a solution from scratch and hey let me just use build everything from scratch unnecessary don't do it it would just hamper your delivery time and add unnecessary complexity you might forget to handle a few edge cases which would go down a robust tool that is already available in the market which is battle tested used by a lot of organizations it will give you much better performance any day right so these are the three key anti-patterns that i want all of you to remember before you jump into the wagon of creating microservices right nice so yeah that's it that's it for this video i hope i gave you very detailed introduction about micro services these are some key things that i always wanted to talk about on how you should think about microservices right nice so yeah that's it that's it for this video if you guys like this video give this video a thumbs up if you guys like the channel give this channel a sub i post three in-depth engineering videos every week and i'll see in the next one thanks [Music]