[
  {
    "id": 154,
    "topic": {
      "id": 0,
      "uid": "microservices",
      "name": "Designing \u03bc-services",
      "one_liner": null,
      "youtube_playlist_id": "PLsdq-3Z1EPT0ug8eizS71G6LZb6-4FAFt",
      "bgcolor": "#FFFAE6",
      "themecolor": "#CAA200"
    },
    "yt_video_id": "yTSq6hJFmUg",
    "title": "10 Challenges in Adopting and Implementing Microservices",
    "description": "We always hear great things about Microservices. But, every few months every senior engineer gets a feeling, can we not go back to a simpler time and have monolithic architecture again?\n\nIn this video, let's understand the 10 challenges that come with adopting microservices. Today, we would spend time talking about both engineering or tech challenges and organizational challenges that we all should be aware of and address while we adopt microservices.\n\nOutline:\n\n00:00 Agenda\n02:34 Managing Microservices\n05:25 Monitoring and Logging\n08:26 Service Discovery\n10:44 Authentication and Authorization\n12:17 Configuration Management\n14:09 There's no going back\n16:56 Fault Tolerance\n18:43 Internal and External Testing\n20:05 Design with Failures in mind\n21:23 Dependency Management is a Nightmare",
    "img": "https://i.ytimg.com/vi/yTSq6hJFmUg/mqdefault.jpg",
    "gif": "https://media.giphy.com/media/14ppamy2aEFhOE/giphy.gif",
    "duration": "26:46",
    "view_count": 205,
    "like_count": 16,
    "comment_count": 2,
    "released_at": "2022-06-15",
    "gist": "We always hear great things about Microservices. But today let's talk about the top 10 challenges that come with adopting Microservices.\n\n## Managing Microservices\n\nAs the number of microservices increases, managing them becomes tough. If there is no plan or accountability then we might end up with a lot of tiny microservices or with a huge macro-service.\n\n## Extensive Monitoring and Logging\n\nMonitoring what happens across the entire infra is critical. Along with this, we would also need an ability to trace end user request path spanning services - also called Distributed Tracing.\n\n## Service Discovery\n\nIt does not take much time for our services to grow beyond 100 and at that scale, discovering a service becomes a pain requiring us to put Service Discovery.\n\n3 ways to do it are\n\n- a central service registry\n- load balancer-based discovery\n- pure service mesh implementation\n\n## Authentication and Authorization\n\nInter-service communication should be secure to ensure that a service does not abuse others; hence we need to put auth in place that allows authorized services to talk to each other.\n\n## Config Management\n\nEvery microservice has a set of configs, like DB passwords, and API Keys. Committing them to the repository is an unacceptable practice, and we would not want every service to have its own config server.\n\nHence we need to have about a central config management system that is fault tolerant, robust, and scales well.\n\n## No going back\n\nIt is extremely difficult to move back to monolith after the teams have tasted microservices. A few reasons would be\n\n- services are written in various languages\n- teams used to being autonomous\n- teams have adopted new tools and processes\n\n## Fault Tolerance\n\nOutages are inevitable and as engineers, we always try to minimize them. A way to achieve this is to keep services loosely coupled that keep outages isolated ensuring no cascading failures.\n\n## Internal and External Testing\n\nEnd-to-end testing becomes complex as it is hard to spin up environments with all services running fine.\n\n## Design with Failures in mind\n\nRobust microservices require a counter-intuitive approach, and we need to assume everything would collapse after every line of code. Then we amend the code and architecture to handle it and re-iterate.\n\n## Dependency Management is a nightmare\n\nManaging dependencies across services is tough and it leads to a slowdown. The 3 kinds of dependency to be careful about\n\n- sync dependency on other services\n- services sharing a common library\n- service depending on data coming from other services",
    "notes_gd": "https://drive.google.com/file/d/1qOCi_CaT5qYO_Qbm-6UB2IN-qcGc8AYB/view?usp=sharing",
    "slug": "10-challenges-in-adopting-and-implementing-microservices"
  },
  {
    "id": 153,
    "topic": {
      "id": 0,
      "uid": "microservices",
      "name": "Designing \u03bc-services",
      "one_liner": null,
      "youtube_playlist_id": "PLsdq-3Z1EPT0ug8eizS71G6LZb6-4FAFt",
      "bgcolor": "#FFFAE6",
      "themecolor": "#CAA200"
    },
    "yt_video_id": "qoAox0FGzRQ",
    "title": "What are Microservices?",
    "description": "Everyone is doing Microservices, but what are they after all? From a distance, it looks like a function put over the network. Is it really just that? There are so many things to explore about microservices, so let me introduce you to this world today.\n\nIn this video, we talk about what are microservices, understand how it starts with a simple monolith and eventually evolve into microservices, look at their key characteristics, understand their advantages, and conclude with some anti-patterns that we all should keep in mind to ensure we do not do it wrong.\n\nOutline:\n\n00:00 Agenda\n02:38 Idea of a Microservice\n09:26 Monolith Architecture\n16:19 Monolith to Microservice\n18:49 Characteristics of a Microservice\n21:09 Advantages of Microservices\n24:06 Anti-patterns in Microservices",
    "img": "https://i.ytimg.com/vi/qoAox0FGzRQ/mqdefault.jpg",
    "gif": "https://media.giphy.com/media/Nx85vtTY70T3W/giphy.gif",
    "duration": "27:34",
    "view_count": 1222,
    "like_count": 69,
    "comment_count": 9,
    "released_at": "2022-06-13",
    "gist": "Everyone's talking about Microservices, but what exactly are they? Are they just a set of functions hosted over a network or something more?\n\nMicroservices in simple terms are like the regular functions from our programming language but just a more extensive set of responsibilities and served via a network.\n\nSo, you may have a microservice that handles everything related to Payments, a service that handles Notifications, and a service that deals with analytics. We see each service having focussed responsibility.\n\nMicroservices are no silver bullet, and they would not magically solve all the problems you have. It has its own fair share of drawbacks.\n\n## Monolith\n\nAlmost all products start monolith where every feature is put into a single codebase which is deployed as one artifact across all the servers. For example, the code handling payments, notifications, and analytics are all part of the same codebase deployed within the same binary.\n\nMonoliths are always simple to build, develop, test, and scale. Given their simplicity, they are the go-to option for anyone starting up. With a lean team working on monolith would ensure very quick feature delivery.\n\n### Disadvantages of Monolith\n\n- monolith is tightly coupled\n- the deployment artifact - binary/JAR is bulky\n- the tech stack is homogeneous\n- bug in one module affects other modules\n- scaling one module requires scaling everything\n- large monolithic codebase is intimidating and it slows down delivery\n\n### Monolith to Microservices\n\nMigrating from monolith to microservices is a slow process and to start you would club a related set of functions and fork out a service out of it. The process would be repeated for other sets of functions, eventually breaking the entire monolith.\n\n## Characteristics of Microservices\n\n- microservices are autonomous\n- microservices are focused and specialized\n- microservices are built around a business usecase/need\n\n## Advantages of Microservices\n\n- agility: small independent teams can move much faster\n- scaling: you can precisely scale one service as per the load\n- freedom: you can pick the best-suited tech stack for the service\n- given the scope is focused, a microservice is simple to understand\n- microservices can be reused across the platform\n- if a service goes down, it is easy to isolate it using a circuit breaker\n\n## Anti-patterns\n\n- do not start with microservices; start with a monolith\n- do not make services too small; they should a larger responsibility\n- don't reinvent the wheel, use existing tooling as much as possible",
    "notes_gd": "https://drive.google.com/file/d/1SaDvF80ZirInE4XyVRu8F6PnIm-1b8vl/view?usp=sharing",
    "slug": "what-are-microservices"
  },
  {
    "id": 151,
    "topic": {
      "id": 0,
      "uid": "microservices",
      "name": "Designing \u03bc-services",
      "one_liner": null,
      "youtube_playlist_id": "PLsdq-3Z1EPT0ug8eizS71G6LZb6-4FAFt",
      "bgcolor": "#FFFAE6",
      "themecolor": "#CAA200"
    },
    "yt_video_id": "5pYLlYsy6fQ",
    "title": "API Composition Pattern in Microservices",
    "description": "Say, we have very happily created 6/7 microservices and everything is going well. Now for a new usecase that is introduced in the product, we have to talk to not one but 3 services together to compile a response. So, what is a good way of implementing and supporting this kind of request? A high-level pattern that helps us do it is called API Composition.\n\nIn this video, let's in-depth talk about this super simple pattern to query Microservices, see what it is, how to implement it, understand how it not only helps in improving end user experience, and conclude by going through the advantages and disadvantages of adopting it.\n\nOutline:\n\n00:00 Agenda\n02:54 Introducing API Composition\n04:53 Implementing API Composition using API Gateway\n06:44 Sequential vs Parallel Invocation\n09:21 Improving end-user experience using API Composition\n12:43 Branch or Multi-level API Composition\n14:03 Advantages of API Composition and Gateways\n18:49 Disadvantages of API Composition and Gateways",
    "img": "https://i.ytimg.com/vi/5pYLlYsy6fQ/mqdefault.jpg",
    "gif": "https://media.giphy.com/media/l2Jee4sAi8emF3Q40/giphy.gif",
    "duration": "25:50",
    "view_count": 925,
    "like_count": 62,
    "comment_count": 10,
    "released_at": "2022-06-08",
    "gist": "Say, we have 3 microservices - Order, Payments, and Logistics - and to get the order details we need data from all of them, merge it, and then respond to the client. A common pattern to achieve this is API Composition.\n\n## API Composition\n\nIt is a high-level pattern to query microservices. It puts a composer right in the middle abstracting out the microservices.\n\nWith the composer sitting in between, the request from the client first hits the composer, and the composer then talks to the relevant services to get the response. It then merges the responses before sending them to the client.\n\n## Implementing API Composition\n\nInstead of building it from scratch, we can use tools that specialize in achieving this - ex: API Gateways like KrakenD, Kong, and AWS API Gateway.\n\n## Improving user's experience using composer\n\nAn API Composer not only helps in making the backend simpler, but it also helps in gaining a good UX.\n\nIf we do not have an API composer, the client (browser/app) would have to make multiple API calls to microservices to get the information and render the interface. The multiple calls would require multiple round trips of the data increasing the latency and will also eat up the user's data.\n\nBy having an API composer sitting in between the client would only need to make one API call and the fan-out happening at composer will be within the infra. This would reduce the latency for clients and improve the UX.\n\n## Branch Composition\n\nFor a complex usecase, it is quite possible that a downstream service may use another composer to reach out to another set of services to get things done. A dependency like this would create a multi-level API composition also called Branch composition.\n\nThis would create a hierarchical dependency between services solved through multiple API composers and it is a common pattern observed in complex e-commerce platforms.\n\n## Advantages of using API Composition\n\n- Simple to implement\n- Client has a single point to interact\n- Hides the implementation complexities\n- Security and Limiting applied only to the composer\n- Can cover the \"bad\" design decisions with a shiny new interface\n- Hides legacy system allowing us to gradually move out of it\n\n## Disadvantages of using API Composition\n\n- If the dataset we fetch from microservices is large, it would make the composer in-efficient\n- Overall availability is challenged as the number of services increase\n- Having a transactional data consistency is difficult\n- Composer needs to be managed and maintained\n- Composer may become a bottleneck at scale",
    "notes_gd": "https://drive.google.com/file/d/1e5AqRKDRQ8c_3rqWWfBTDa3cKXkuCvTt/view?usp=sharing",
    "slug": "api-composition-pattern-in-microservices"
  },
  {
    "id": 148,
    "topic": {
      "id": 0,
      "uid": "microservices",
      "name": "Designing \u03bc-services",
      "one_liner": null,
      "youtube_playlist_id": "PLsdq-3Z1EPT0ug8eizS71G6LZb6-4FAFt",
      "bgcolor": "#FFFAE6",
      "themecolor": "#CAA200"
    },
    "yt_video_id": "la2q1vFA5q0",
    "title": "Database per Service Pattern in Microservices",
    "description": "Microservices should be loosely coupled and autonomous so that they can take their own decision and be as performant as they can be. A high-level architecture pattern that allows us to achieve this is the database-per-service pattern in which each microservice owns its database and take independent decisions about it.\n\nIn this video, we quickly talk about the database-per-service architecture pattern, look at how it helps in modeling massive systems, understand the advantages of adopting it, and conclude by going through some drawbacks of this architecture pattern.\n\nOutline:\n\n00:00 Agenda\n02:39 INtroducing Database Per Service Pattern\n04:02 Modeling Social Networks\n07:33 Advantages of adopting Database Per Service Pattern\n16:22 Downsides of adopting Database Per Service Pattern",
    "img": "https://i.ytimg.com/vi/la2q1vFA5q0/mqdefault.jpg",
    "gif": "https://media.giphy.com/media/3TCBh8i6H3bz2/giphy.gif",
    "duration": "22:49",
    "view_count": 2237,
    "like_count": 97,
    "comment_count": 12,
    "released_at": "2022-06-01",
    "gist": "Should every microservice have its own database?\n\nMicroservices need some persistence to store the state of the application. They also need to be loosely coupled with others so as to be autonomous and having a separate database for itself really helps, and this is the Database Per Service pattern.\n\n## Modeling a social network\n\nThe importance of having a database per service can be seen when we model a social network. For every usecase, we would need a specialized database to keep our latencies to a bare minimum.\n\n- Chat: a partitioned non-relational database like Cassandra\n- Auth: a simple relational database with replicas like MySQL\n- Profile: a nonrelational schemaless database like MongoDB\n- Analytics: a massively scalable columnar storage like Redshift\n- Videos: blob storage like S3\n\n## Advantages of Database Per Service Pattern\n\n### Loosely coupled components\n\nBecause the databases are separate, the services could not connect to other databases and would have to directly talk to each other making them loosely coupled.\n\n### Specific DB for specific usecase\n\nServices can pick the best database for their usecase making them super performant and efficient. For example, picking a Graph database to model relations in social networks instead of relational.\n\n### Granular control and scaling\n\nServices can choose their scaling strategies as per the load it is getting; be it vertical, horizontal, replicas, partitioned, or decentralized.\n\n### Smaller blast radius\n\nWhen any database is experiencing an outage only the services that are directly or indirectly dependent on it get affected and everything else continues to operate normally. For example, we can continue to accept the payments even when the profile service is down.\n\n### Compliance\n\nCompliance requires us to make changes in how our data is stored and moved across. Separate databases would help us in implementing changes on a fraction of data instead of the whole.\n\n## Downsides of Database Per Service Pattern\n\n### Transactions are distributed and expensive\n\nIf we need strong consistency across, we would need distributed transactions and those are expensive and complex to implement.\n\n### Conveying updates requires brokers\n\nConveying updates from one service to another would require us to have message brokers, thus adding more things to manage and maintain.\n\n### More infra to manage\n\nHaving a database per service bloats up our infra and we would need to build expertise in maintaining and managing them.",
    "notes_gd": "https://drive.google.com/file/d/1D7bEh7tacBZsBxzxnVbH4OvFuTOgY-yh/view?usp=sharing",
    "slug": "database-per-service-pattern-in-microservices"
  },
  {
    "id": 147,
    "topic": {
      "id": 0,
      "uid": "microservices",
      "name": "Designing \u03bc-services",
      "one_liner": null,
      "youtube_playlist_id": "PLsdq-3Z1EPT0ug8eizS71G6LZb6-4FAFt",
      "bgcolor": "#FFFAE6",
      "themecolor": "#CAA200"
    },
    "yt_video_id": "uFGJVQvR59A",
    "title": "Everything you need to know about REST",
    "description": "REST is how browsers talk to our servers. 99.99% of all your API requests that originates from your browser and go to your API servers are REST. So, what is REST? How is it different from HTTP? Is it a protocol or what? There are so many unanswered questions like this.\n\nIn this video, we in-depth talk about REST, understand the foundations of it, see how and why it gels so well with HTTP, find out why everyone is using it, and conclude by going through the downsides of using REST over HTTP.\n\nOutline:\n\n00:00 Agenda\n02:38 Introduction to REST\n03:14 Everything is a Resource\n07:20 Representation in REST\n09:07 Underlying protocol in REST\n09:20 REST and HTTP\n17:32 Downsides of using REST over HTTP",
    "img": "https://i.ytimg.com/vi/uFGJVQvR59A/mqdefault.jpg",
    "gif": "https://media.giphy.com/media/A6aHBCFqlE0Rq/giphy.gif",
    "duration": "26:20",
    "view_count": 1828,
    "like_count": 118,
    "comment_count": 18,
    "released_at": "2022-05-30",
    "gist": "Is REST all about just exposing an HTTP endpoint?\n\nREST is an abbreviation that stands for Representational State Transfer. A lot of complex words but stick with me.\n\nREST is a specification that suggests how a client should demand/request information from the server and how the server should respond; it does not enforce anything.\n\n## Everything is a Resource\n\nIn REST, everything is a resource. Any actionable entity in your application eg: book, student, customer, or order is a resource for REST. The client can demand action on a resource like get, create, delete, or update.\n\nREST does not put any restriction on how the data is stored in your application, but it allows clients to specify how it wants the data from the server eg: XML, JSON, CSV, etc. So long as the server supports the representation the server would respond in the demanded format.\n\n## Underlying Protocol for REST\n\nREST does not enforce any restriction on the underlying protocol to be used. All it cares about is that we have a defined way to act on a resource. So, we can implement REST over HTTP or even hardware like USB.\n\n## Why REST over HTTP?\n\nThe most common implementation of REST is over HTTP and it gels very well together. Why so?\n\nHTTP has verbs like GET, POST, DELETE, and PUT and these become actions on our resource. The resource is specified by the URL of the HTTP request. For example, to get a student's details whose `id = 1` we fire\n\n```\nGET /students/1\n```\n\nWe are representing the student with `id = 1` using the URL `/students/1` and are specifying action `GET` using the HTTP verb `GET`. Similarly to update the student with `id = 1` we could\n\n```\nPOST /students/1\n```\n\nHere we see how REST is resource-oriented and we have a way to specify the action to be taken on it.\n\n### Existing tooling\n\nOne very important reason why HTTP is so commonly used in implementation is the availability of existing tooling. We can reuse the existing set of tools to get the job done, which includes.\n\n- using existing HTTP Clients like Postman, cURL, Requests\n- use caches like Ngnix, HA Proxy, and Varnish to boost performance\n- use monitoring tools like Distributed Tracing\n- use load balancers to uniformly distribute the load\n- use SSL to get out-of-the-box security\n\n## Downsides of doing REST over HTTP\n\n- all clients would have to serialize and deserialize the HTTP body\n- all clients would have to repetitively handle failures and retries\n- some web servers might not support verbs like PUT, DELETE\n- HTTP payloads are JSON and hence huge\n- HTTP would not support switching underlying protocols",
    "notes_gd": "https://drive.google.com/file/d/18edhW0hhSUp-7Vn3-Mz8Xfge8xRBmJ6W/view?usp=sharing",
    "slug": "everything-you-need-to-know-about-rest"
  },
  {
    "id": 140,
    "topic": {
      "id": 0,
      "uid": "microservices",
      "name": "Designing \u03bc-services",
      "one_liner": null,
      "youtube_playlist_id": "PLsdq-3Z1EPT0ug8eizS71G6LZb6-4FAFt",
      "bgcolor": "#FFFAE6",
      "themecolor": "#CAA200"
    },
    "yt_video_id": "eRndYq8iTio",
    "title": "Introduction to RPC - Remote Procedure Calls",
    "description": "One of the most interesting things that revived itself after a decade is Remote Procedure Calls, fondly called as RPCs; and they are widely adopted to do inter-service communication over the network.\n\nThe core highlight that sets RPCs apart is that they are designed to make the network call look just like a local function call. It does this by abstracting out all the complexities like serialization, deserialization, and transport.\n\nIn this video, let's take an in-depth look into what RPC is, where it fits, what are stubs, how communication happens between the services, and conclude by going through the advantages and disadvantages of using RPCs.\n\nOutline:\n\n00:00 Agenda\n03:01 Introduction to Inter-Service Communication\n03:43 Why RPCs were conceptualized?\n08:50 What is RPC?\n11:42 What are stubs in RPC?\n17:07 Interface Definition and Stub Generation\n22:09 Communication in RPC\n22:57 Advantages of using RPC\n29:16 Concerns while using RPC\n\nhttps://github.com/arpitbbhayani/grpc-advcalc",
    "img": "https://i.ytimg.com/vi/eRndYq8iTio/mqdefault.jpg",
    "gif": "https://media.giphy.com/media/100iCPYcAQx3WM/giphy.gif",
    "duration": "33:5",
    "view_count": 1805,
    "like_count": 115,
    "comment_count": 18,
    "released_at": "2022-05-13",
    "gist": "What are Remote Procedure Calls? How were they conceptualized? and Why are people adopting them? Here's why \ud83d\udc47\u200d\n\nThe two services need to communicate with each other so as to get things done. The most common way to do it today is to make a REST call over HTTP to the other service.\n\nWith this approach, every service needs to write logic to make HTTP call to the other service and handle things like failures, retries, compression, and security. Can we not abstract these complexities in some way?\n\nRPCs were conceptualized to solve this problem.\n\n## Remote Procedure Calls\n\nRPCs are designed to make remote network calls look and feel like local procedures. They abstract out all the complexities of remote invocations like Marshalling, Unmarshalling, Compressions, Retries, Security, etc.\n\nRPCs achieve this level of coherence using Stubs that sit in between the two services and convert incoming and outgoing packets into native objects.\n\n## Stubs\n\nStubs are the common piece of auto-generated code that defines the interface, in a given language, exposed by the server, and used by the client to consume the data.\n\nThe interface is defined in a common language like Protobuf and holds the information about functions that the server exposes and the request response object types. A generator is shipped with the RPC runtime that would take this interface and generate code in the target language.\n\nFor example, if the Auth service is written in Golang, the generator would generate a working code with the interface along with the transport details. This way, we can solely focus on writing the business logic and not worry about the network or other repetitive things.\n\n## Communication RPC\n\nRPC can use any transport protocol for communication - Raw TCP, UDP, HTTP 1.1, or even HTTP 2. The transport is just a way through which the marshaled information will be sent across systems; and depending on the features an RPC runtime plans to support, an appropriate protocol will be chosen.\n\n## Advantages of using RPC\n\n- easy to use\n- strong API contract\n- remote invocations are just local function calls\n- cross language communication is a breeze\n- mundane tasks like retries, compression, etc are abstracted\n- get performance out-of-the-box - streaming, connection pool\n- security is just a plug\n- no need to write client libraries, they can be auto-generated\n\n## Concerns while adopting RPC\n\n- stubs need to be re-generated whenever the signature changes\n- testing RPC is n trivial for beginners\n- getting started can be a little challenging\n- browser support for RPC is pretty limited",
    "notes_gd": "https://drive.google.com/file/d/1UiyrR6YbvzWa_yTzXlSIL-lvaS23eMED/view?usp=sharing",
    "slug": "introduction-to-rpc-remote-procedure-calls"
  },
  {
    "id": 139,
    "topic": {
      "id": 0,
      "uid": "microservices",
      "name": "Designing \u03bc-services",
      "one_liner": null,
      "youtube_playlist_id": "PLsdq-3Z1EPT0ug8eizS71G6LZb6-4FAFt",
      "bgcolor": "#FFFAE6",
      "themecolor": "#CAA200"
    },
    "yt_video_id": "HiwOx-W1TIA",
    "title": "Designing Workflows in Microservices - Orchestration vs Choreography",
    "description": "In a microservices architecture there will always arise a need to design workflows; for example: when on an e-commerce website someone places an order, we need to send an email confirmation to the user, notify the seller to keep the shipment ready, and also assign a logistic delivery partner so that the package is delivered to the user.\n\nModeling these workflows is a challenge as it requires multiple microservices to coordinate. So, how can we implement them? There are two high-level architecture patterns to implement workflows, and they are - Orchestration and Choreography. In this video, we take a detailed look into the two patterns and see what they are, how they are implemented, and which one to use when?\n\nOutline:\n\n00:00 Agenda\n03:02 Introduction to Workflows in Microservices\n03:55 Orchestration\n06:28 Choreography\n09:51 When to use Orchestration, and when to use Choreography",
    "img": "https://i.ytimg.com/vi/HiwOx-W1TIA/mqdefault.jpg",
    "gif": "https://media.giphy.com/media/nMq17xl0Ls0xO/giphy.gif",
    "duration": "17:26",
    "view_count": 1860,
    "like_count": 120,
    "comment_count": 4,
    "released_at": "2022-05-11",
    "gist": "Say we are building an e-commerce website and upon every purchase made we need to send a confirmation email to the user, notify the seller to keep the shipment ready and assign a logistic delivery partner to deliver the package to the user. So, how do we implement this?\n\nTwo high-level architecture patterns help us achieve this\n\n- Orchestration\n- Choreography\n\n## Orchestration\n\nOrchestration is the simplest way to model workflows. The core idea of the Orchestration pattern is to keep the decision logic centralized and have a single brain in the system.\n\nIn our example, the Orders service can be that brain, and when the order is placed the order service talks to Notification, Seller, and Logistics services and get the necessary things done. The communication between them is synchronous and the Orders service acts as the coordinator.\n\nThe workflow as part of our example is a one-level simple workflow but in the real world, these workflows could become extremely complex and the Orders service would be needing to handle the coordination.\n\n## Choreography\n\nThe core idea of the Choreography pattern is to keep the decision logic distributed and let each service decide when needs to be done upon an event. It thus laid the foundation for Event Driven Architecture.\n\nIn our example, when the order is placed the Orders service will simply emit an event to which all the involved services subscribe. Upon receiving an event, the services will react accordingly and do what they are supposed to.\n\nAll the 4 involved services are thus totally decoupled and independent; making this a truly distributed and decentralized architecture\n\n## Orchestration vs Choreography\n\nMost model systems are inclined towards Choreography as it gives some amazing benefits\n\n- loose coupling: services involved are decoupled\n- extensibility: extending the functionality is simple and natural\n- flexibility: search service owns its own decision on the next steps\n- robustness: if one service is down, it does not affect others\n\nObservability might become a challenge here; given that we need to track each service, action it took, and completion of it.\n\nAlthough people prefer choreography, it does not make Orchestration bad. Orchestration has its advantages and can be used in modeling services that are involved transactionally.\n\nFor example, sending OTP during login is best modeled synchronous instead of doing it async. Another example is when we want to render recommended items the Recommendation service talks to relevant services to enrich the information before sending it to the user.",
    "notes_gd": "https://drive.google.com/file/d/1h-YVs2toYWW0qnRKGoPbPdlkpDgp9M9m/view?usp=sharing",
    "slug": "designing-workflows-in-microservices-orchestration-vs-choreography"
  },
  {
    "id": 136,
    "topic": {
      "id": 0,
      "uid": "microservices",
      "name": "Designing \u03bc-services",
      "one_liner": null,
      "youtube_playlist_id": "PLsdq-3Z1EPT0ug8eizS71G6LZb6-4FAFt",
      "bgcolor": "#FFFAE6",
      "themecolor": "#CAA200"
    },
    "yt_video_id": "ewUw0sUxHI4",
    "title": "Synchronous and Asynchronous Communication between Microservices",
    "description": "How should two microservices talk to each other? Picking the right communication pattern is super-important as a good decision will ensure a great user experience and scalability while a bad one will ruin the party.\n\nThere are overall two categories of communication: Synchronous and Asynchronous; In this video, we in-depth discuss what synchronous communication is and how it is done, what asynchronous communication is and how it is done, the advantages and disadvantages of both of them, and most importantly understand how to decide which one to opt for with some real-world examples.\n\nOutline:\n\n00:00 Agenda\n03:08 Need for Communication between Microservices\n05:10 Synchronous Communication\n08:17 Advantages of Synchronous Communication\n09:07 Disadvantages of Synchronous Communication\n15:58 When to use Synchronous Communication\n18:40 Asynchronous Communication\n23:01 Advantages of Asynchronous Communication\n31:41 Disadvantages of Asynchronous Communication\n34:39 When to use Asynchronous Communication",
    "img": "https://i.ytimg.com/vi/ewUw0sUxHI4/mqdefault.jpg",
    "gif": "https://media.giphy.com/media/3orif4qbRS6WjGJ2zC/giphy.gif",
    "duration": "40:10",
    "view_count": 1941,
    "like_count": 118,
    "comment_count": 12,
    "released_at": "2022-05-04",
    "gist": "Say, we are building a Social Network and anytime someone reacts to your post, you need to be notified. So, how should the Reaction service talk to the Notification service to send out a notification?\n\nThe communication would be much simpler and reliable, just a function call if it was a monolith; but things become tricky as we go distributed.\n\nMicroservices need to talk to each other to exchange information and get things done; and there are two categories of communication patterns - Synchronous and Asynchronous.\n\n## Synchronous Communication\n\nCommunication is synchronous when one service sends a request to another service and waits for the response before proceeding further.\n\nThe most common implementation of Sync communication is over HTTP using protocols like REST, GraphQL, and gRPC.\n\n### Advantages of Synchronous Communication\n\n- It is simple and intuitive\n- Communication happens in realtime\n\n### Disadvantages of Synchronous Communication\n\n- Caller is blocked until the response is received\n- Servers need to be pro-actively provisioned for peaks\n- There is a risk of cascading failures\n- The participating services are strongly coupled\n\n### When to use Synchronous Communication\n\n- When you cannot proceed without a response from the other service\n- When you want real-time responses\n- When it takes less time to compute and respond\n\n## Asynchronous Communication\n\nThe communication is asynchronous when the one service sends a request to another service and does NOT wait for the response; instead, it continues with its own execution.\n\nAsync communication is most commonly implemented using a message broker like RabbitMQ, SQS, Kafka, Kinesis, etc.\n\n### Advantages of Asynchronous Communication\n\n- Services do not need to wait for the response and can move on\n- Services can handle surges and spikes better\n- Servers do not need to be proactively provisioned\n- No extra network hop due to Load Balancer\n- No request drop due to target service being overwhelmed\n- Better control over failures and retires is possible\n- Services are truly decoupled\n\n### Disadvantages of Asynchronous Communication\n\n- Eventual consistency\n- Broker could become a SPoF\n- It is harder to track the flow of the message between services\n\n### When to use Asynchronous Communication\n\n- When delay in processing is okay\n- When the job at hand is long-running and takes time to execute\n- When multiple services need to react to the same event\n- When it is okay for the processing to fail and you are allowed to retry",
    "notes_gd": "https://drive.google.com/file/d/16T1TszFP0yXXxFWAk9wQnzii5JIeo5O2/view?usp=sharing",
    "slug": "synchronous-and-asynchronous-communication-between-microservices"
  },
  {
    "id": 133,
    "topic": {
      "id": 0,
      "uid": "microservices",
      "name": "Designing \u03bc-services",
      "one_liner": null,
      "youtube_playlist_id": "PLsdq-3Z1EPT0ug8eizS71G6LZb6-4FAFt",
      "bgcolor": "#FFFAE6",
      "themecolor": "#CAA200"
    },
    "yt_video_id": "tV11trlimLk",
    "title": "Shared Database Pattern in Microservices",
    "description": "Microservices need to communicate with each other. Communication between them is always about getting or updating data that is owned by the other service. What if a service gets direct access to all the data it wants? This is the simplest way for the microservices to communicate with each other, and this pattern is called Sharing the Database. The core idea here is to let anyone who needs the data from a service or wants to update something, can directly talk to its database - no middlemen needed.\n\nAlthough most people think it is the wrong way of communication, we should not discard it completely. In this video, we talk about what this architecture pattern is, the 4 challenges associated with it, see ways to mitigate them, and understand when and where it could be beneficial for us to share the database rather than going through a middleman.\n\nOutline:\n\n00:00 Agenda\n03:13 Introduction\n04:14 Advantages of a sharing a database\n06:55 Challenge 1: External parties getting internal details\n10:30 Challenge 2: Replicating business logic\n13:31 Challenge 3: Risk of data corruption and deletion\n14:50 Challenge 4: Abusing the shared database\n16:27 Should we share the database then?",
    "img": "https://i.ytimg.com/vi/tV11trlimLk/mqdefault.jpg",
    "gif": "https://media.giphy.com/media/fxwvlpoM7NwP7i4jFB/giphy.gif",
    "duration": "21:21",
    "view_count": 2127,
    "like_count": 103,
    "comment_count": 22,
    "released_at": "2022-04-27",
    "gist": "Microservices need to communicate with each other, and one such way of doing it is through a shared database.\n\nFor example: While building a multi-user blogging application, say we have a Blogs service that manages all the blogs-related information and we have an Analytics service that takes care of all the analytics like Likes, Shares, Views, etc.\n\nAnalytics service updates the information asynchronously directly in the blog's database; eg: total_views that happened on the blog. This can be easily achieved by sharing the database between Blogs and Analytics, and this pattern is the Shared Database pattern.\n\n### Advantages of sharing the database\n\n- the simplest way of integration\n- no middleman involved\n- no latency overhead\n- quick development time\n\n## Challenges with Shared Database\n\nThere are 4 challenges to using this pattern\n\n### External parties know internal details\n\nBy sharing the database across services, an external party (Analytics) would get to know the internal details of the Blogs service; eg: deletion practice, schema, etc.\n\nThis leads to a very tight coupling between the services; which then restrains the maintainability and performance of the system. For example, whenever the Blogs service changes the schema, the Analytics Service would have to be informed about the change.\n\n### Sharing the database is sharing the logic\n\nTo compute some information we need to query a set of tables; and say, this information is required by the Blogs, Analytics, and Recommendation service.\n\nThe business logic to compute the information has to be replicated across all the 3 services. Any change in the logic needs to be made across all the services.\n\n### Risk of data corruption and deletion\n\nThere is a risk that one of the services might corrupt or delete some data given that the database is shared between the services.\n\n### Abusing the shared database\n\nOne service firing expensive queries on the database will affect the performance of other services sharing the same database.\n\n## When to share a database?\n\nA shared database pattern is helpful when you are seeking quick development time. Although it is not the best practice, sharing the database does reduce the development effort by a massive margin.\n\nSharing the database is also seen where it is inconvenient to have a middleman for the communication; for example: sending a notification to a million followers of a person is simple when the Relationship database is shared with the notification fan-out service; instead of iterating the millions of followers through some middleman API.",
    "notes_gd": "https://drive.google.com/file/d/1ql0chRVpcjgV4Fv_MJTRaXbtIZ3QJwcI/view?usp=sharing",
    "slug": "shared-database-pattern-in-microservices"
  },
  {
    "id": 129,
    "topic": {
      "id": 0,
      "uid": "microservices",
      "name": "Designing \u03bc-services",
      "one_liner": null,
      "youtube_playlist_id": "PLsdq-3Z1EPT0ug8eizS71G6LZb6-4FAFt",
      "bgcolor": "#FFFAE6",
      "themecolor": "#CAA200"
    },
    "yt_video_id": "nfkdKHcKxbE",
    "title": "How to scope a microservice?",
    "description": "Microservices are extremely tempting and you will always feel like writing a new service for every problem at hand. You might build a service with very fine-grained responsibilities or you can build one that covers a big spectrum. So, what is the best approach? How should you decide?\n\nIn this video, we talk about ways to model and scope a microservice such that the architecture remains robust and flexible; and to achieve this we use the two key guiding concepts - Loose Coupling and High Cohesion.\n\nOutline:\n\n00:00 What is the problem with Microservice?\n03:05 Why do we love building microservices?\n04:04 What happens if we do not scope our services well?\n05:52 Two key guiding principles to scope a microservice\n07:19 Loose Coupling\n12:15 High Cohesion",
    "img": "https://i.ytimg.com/vi/nfkdKHcKxbE/mqdefault.jpg",
    "gif": "https://media.giphy.com/media/fKvTY11icTAZIPCIQb/giphy.gif",
    "duration": "19:3",
    "view_count": 1341,
    "like_count": 74,
    "comment_count": 5,
    "released_at": "2022-04-20",
    "gist": "It is always exciting to create new microservices as it gives us so many things to look forward to- a fresh codebase, a new tech stack, or even maybe a clean CICD setup. But does this mean we should create as many microservices as possible?\n\nWhenever we decide to create a new microservice, it is very important to understand its scope of it. If you create a new service for every utility then you are effectively creating a mesh of network calls that is prone to a cascading failure. If your scope is too big, it would lead to the classic problem of a monolithic codebase.\n\nThere are a couple of guiding principles that would help us with scoping of microservice.\n\n## Loose Coupling\n\nServices are loosely coupled if changes made in one service do not require a change in other. This is the core ideology behind microservices as well, but while designing a system we tend to forget it.\n\nSay, we have an Orders service and a Logistics service. These services are loosely coupled when they do not share anything in common and are communicating with each other via API contracts.\n\nTo achieve loose coupling, make your microservices expose as little information as possible. The other service should just know how to consume the data and that is it. No internals, no extra details.\n\n## High Cohesion\n\nThe principle of High Cohesion says that the related behavior should sit together as part of one service while the unrelated ones should be separate. This would encourage services to be operating independently.\n\nIf the Orders service also owns the customer data then when the changes are deployed in one might affect the other module. So the scope of testing before taking things to production increases.\n\nIf there is a very strong coupling between the services then it may also happen that the changes in one lead to deploy a few other services- all at the same time. Deploying multiple services at the same time is very risky; because one glitch and the almost entire product is down.\n\nHence it is not favorable for heterogeneous components to be part of the same service. Keep it crisp and short; and while designing try to keep services loosely coupled and split it to a level where the unrelated components are split up.",
    "notes_gd": "https://drive.google.com/file/d/1_P8YVcw7uwr0wfs2V6W-1gpOwnoG2Zdf/view?usp=sharing",
    "slug": "how-to-scope-a-microservice"
  },
  {
    "id": 119,
    "topic": {
      "id": 0,
      "uid": "microservices",
      "name": "Designing \u03bc-services",
      "one_liner": null,
      "youtube_playlist_id": "PLsdq-3Z1EPT0ug8eizS71G6LZb6-4FAFt",
      "bgcolor": "#FFFAE6",
      "themecolor": "#CAA200"
    },
    "yt_video_id": "JPj6mhVLQN0",
    "title": "Advantages of adopting a microservices-based architecture",
    "description": "Microservices are great, and the overall microservices-based architecture has some key advantages. In this video, we talk about what are microservices, the key advantages of using a microservices-based architecture, and understand how to fence service and define its set of responsibilities.\n\nOutline:\n\n00:00 What are microservices?\n01:53 Key advantages of adopting a microservices-based architecture\n09:48 How to fence a microservice?",
    "img": "https://i.ytimg.com/vi/JPj6mhVLQN0/mqdefault.jpg",
    "gif": "https://media.giphy.com/media/lKXEBR8m1jWso/giphy.gif",
    "duration": "14:18",
    "view_count": 2601,
    "like_count": 172,
    "comment_count": 13,
    "released_at": "2022-04-08",
    "gist": "Microservices are small, autonomous, harmonic subsystems that work together to solve the bigger problem.\n\nThe core idea of microservices is Divide and Conquer. We break the big problem into smaller sub-problems, and solve each of the sub-problem optimally, enabling us to solve the bigger problem well.\n\nWhy Microservices?\n\n## Codebase grows over time\n\nThe product evolves and new features are added to it and that bloats up the codebase. It becomes difficult for multiple teams to coordinate and collaborate on a humungous codebase. One team breaking one module can take down the entire product.\n\n## Scaling is predictable\n\nWith microservices, scalability becomes predictable; you can linearly amplify the infrastructure requirements of individual microservices and be predictable in handling the load.\n\n## Teams become autonomous\n\nWith each team responsible for a set of microservices they can take charge of their tech stack and design decisions. These decisions will be best for their problem statement and can ensure that they are solving them the best way possible.\n\n## Fault Tolerance\n\nIf one microservice is down, it may lead to a partial outage of the product affecting a small fragment of the systems; while other components remain unaffected and can continue to service the traffic.\n\n## Upgrades are simpler\n\nSo long as a microservice adheres to the API contract, the team that owns it can upgrade the tech stack, architecture, and DB seamlessly.",
    "notes_gd": "https://drive.google.com/file/d/1lK2e3me09VNz51DWDunI5xDmlgLnOvfC/view?usp=sharing",
    "slug": "advantages-of-adopting-a-microservices-based-architecture"
  },
  {
    "id": 118,
    "topic": {
      "id": 0,
      "uid": "microservices",
      "name": "Designing \u03bc-services",
      "one_liner": null,
      "youtube_playlist_id": "PLsdq-3Z1EPT0ug8eizS71G6LZb6-4FAFt",
      "bgcolor": "#FFFAE6",
      "themecolor": "#CAA200"
    },
    "yt_video_id": "Hxja4crycBg",
    "title": "Handling timeouts in a microservice architecture",
    "description": "Handling timeout well is extremely critical as it makes your distributed system robust and ensures you provide a consistent user experience by adhering to SLA guarantees. In this video, we discover how a synchronous dependency on a microservice leads to long delays becoming a big problem, understand how timeout addresses the concern, and discuss 5 approaches to handle service timeouts.\n\nOutline:\n00:00 Why is handling timeout critical?\n01:13 Synchronous communication and timeouts\n05:39 A rule of thumb: Timeout\n07:52 Approach 1: Ignore the timeout\n10:28 Approach 2: Configure and use defaults\n11:27 Approach 3: Retry when timeout\n16:36 Approach 4: Retry only when needed\n20:06 Approach 5: Rearchitect and remove synchronous dependency",
    "img": "https://i.ytimg.com/vi/Hxja4crycBg/mqdefault.jpg",
    "gif": "https://media.giphy.com/media/3oriO4kSYahYQr6e1a/giphy.gif",
    "duration": "23:38",
    "view_count": 2534,
    "like_count": 157,
    "comment_count": 19,
    "released_at": "2022-03-18",
    "gist": "Microservices give us the flexibility to pick the best tech stack to solve the problem optimally. But one thing that ruins the real thrill is Timeouts.\n\nSay we have a blogging website where a user can search for blogs. The request comes to the Search service, and it finds the most relevant blogs for the query.\n\nIn the response, a field called `total_views` should hold the total number of views the blog received in its lifetime. The search services should talk to the Analytics service synchronously to get the data. This synchronous dependency is the root of all evil.\n\nThe core problem: Delays can be arbitrarily large\n\nBecause the delay depending on service can be arbitrarily large, we know how long to wait for the response. We for sure cannot wait forever, and hence we introduce Timeout. Every time the Search service invokes the Analytics service, it starts a timer, and if it does not get a response in the stipulated time, it timeout and moves on.\n\nThere are 5 approaches to handling timeouts.\n\n- Approach 1: Ignore the timeout and move on\n- Approach 2: Use some default value if you timed out\n- Approach 3: Retry the request\n- Approach 4: Retry only when needed\n- Approach 5: Re-architect and make synchronous dependency an async one",
    "notes_gd": "https://drive.google.com/file/d/1GjObZ3xpLFxDEOO3EGRCj0Pq8bWLixjU/view?usp=sharing",
    "slug": "handling-timeouts-in-a-microservice-architecture"
  }
]