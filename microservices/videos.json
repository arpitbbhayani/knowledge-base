[
  {
    "id": 140,
    "topic": {
      "id": 0,
      "uid": "microservices",
      "name": "Designing \u03bc-services",
      "one_liner": null,
      "youtube_playlist_id": "PLsdq-3Z1EPT0ug8eizS71G6LZb6-4FAFt",
      "bgcolor": "#FFFAE6",
      "themecolor": "#CAA200"
    },
    "yt_video_id": "eRndYq8iTio",
    "title": "Introduction to RPC - Remote Procedure Calls",
    "description": "One of the most interesting things that revived itself after a decade is Remote Procedure Calls, fondly called as RPCs; and they are widely adopted to do inter-service communication over the network.\n\nThe core highlight that sets RPCs apart is that they are designed to make the network call look just like a local function call. It does this by abstracting out all the complexities like serialization, deserialization, and transport.\n\nIn this video, let's take an in-depth look into what RPC is, where it fits, what are stubs, how communication happens between the services, and conclude by going through the advantages and disadvantages of using RPCs.\n\nOutline:\n\n00:00 Agenda\n03:01 Introduction to Inter-Service Communication\n03:43 Why RPCs were conceptualized?\n08:50 What is RPC?\n11:42 What are stubs in RPC?\n17:07 Interface Definition and Stub Generation\n22:09 Communication in RPC\n22:57 Advantages of using RPC\n29:16 Concerns while using RPC\n\nhttps://github.com/arpitbbhayani/grpc-advcalc",
    "img": "https://i.ytimg.com/vi/eRndYq8iTio/mqdefault.jpg",
    "gif": "https://media.giphy.com/media/100iCPYcAQx3WM/giphy.gif",
    "duration": "33:5",
    "view_count": 1344,
    "like_count": 88,
    "comment_count": 13,
    "released_at": "2022-05-13",
    "gist": "What are Remote Procedure Calls? How were they conceptualized? and Why are people adopting them? Here's why \ud83d\udc47\u200d\n\nThe two services need to communicate with each other so as to get things done. The most common way to do it today is to make a REST call over HTTP to the other service.\n\nWith this approach, every service needs to write logic to make HTTP call to the other service and handle things like failures, retries, compression, and security. Can we not abstract these complexities in some way?\n\nRPCs were conceptualized to solve this problem.\n\n## Remote Procedure Calls\n\nRPCs are designed to make remote network calls look and feel like local procedures. They abstract out all the complexities of remote invocations like Marshalling, Unmarshalling, Compressions, Retries, Security, etc.\n\nRPCs achieve this level of coherence using Stubs that sit in between the two services and convert incoming and outgoing packets into native objects.\n\n## Stubs\n\nStubs are the common piece of auto-generated code that defines the interface, in a given language, exposed by the server, and used by the client to consume the data.\n\nThe interface is defined in a common language like Protobuf and holds the information about functions that the server exposes and the request response object types. A generator is shipped with the RPC runtime that would take this interface and generate code in the target language.\n\nFor example, if the Auth service is written in Golang, the generator would generate a working code with the interface along with the transport details. This way, we can solely focus on writing the business logic and not worry about the network or other repetitive things.\n\n## Communication RPC\n\nRPC can use any transport protocol for communication - Raw TCP, UDP, HTTP 1.1, or even HTTP 2. The transport is just a way through which the marshaled information will be sent across systems; and depending on the features an RPC runtime plans to support, an appropriate protocol will be chosen.\n\n## Advantages of using RPC\n\n- easy to use\n- strong API contract\n- remote invocations are just local function calls\n- cross language communication is a breeze\n- mundane tasks like retries, compression, etc are abstracted\n- get performance out-of-the-box - streaming, connection pool\n- security is just a plug\n- no need to write client libraries, they can be auto-generated\n\n## Concerns while adopting RPC\n\n- stubs need to be re-generated whenever the signature changes\n- testing RPC is n trivial for beginners\n- getting started can be a little challenging\n- browser support for RPC is pretty limited",
    "notes_gd": "https://drive.google.com/file/d/1UiyrR6YbvzWa_yTzXlSIL-lvaS23eMED/view?usp=sharing",
    "slug": "introduction-to-rpc-remote-procedure-calls"
  },
  {
    "id": 139,
    "topic": {
      "id": 0,
      "uid": "microservices",
      "name": "Designing \u03bc-services",
      "one_liner": null,
      "youtube_playlist_id": "PLsdq-3Z1EPT0ug8eizS71G6LZb6-4FAFt",
      "bgcolor": "#FFFAE6",
      "themecolor": "#CAA200"
    },
    "yt_video_id": "HiwOx-W1TIA",
    "title": "Designing Workflows in Microservices - Orchestration vs Choreography",
    "description": "In a microservices architecture there will always arise a need to design workflows; for example: when on an e-commerce website someone places an order, we need to send an email confirmation to the user, notify the seller to keep the shipment ready, and also assign a logistic delivery partner so that the package is delivered to the user.\n\nModeling these workflows is a challenge as it requires multiple microservices to coordinate. So, how can we implement them? There are two high-level architecture patterns to implement workflows, and they are - Orchestration and Choreography. In this video, we take a detailed look into the two patterns and see what they are, how they are implemented, and which one to use when?\n\nOutline:\n\n00:00 Agenda\n03:02 Introduction to Workflows in Microservices\n03:55 Orchestration\n06:28 Choreography\n09:51 When to use Orchestration, and when to use Choreography",
    "img": "https://i.ytimg.com/vi/HiwOx-W1TIA/mqdefault.jpg",
    "gif": "https://media.giphy.com/media/nMq17xl0Ls0xO/giphy.gif",
    "duration": "17:26",
    "view_count": 1514,
    "like_count": 103,
    "comment_count": 5,
    "released_at": "2022-05-11",
    "gist": "Say we are building an e-commerce website and upon every purchase made we need to send a confirmation email to the user, notify the seller to keep the shipment ready and assign a logistic delivery partner to deliver the package to the user. So, how do we implement this?\n\nTwo high-level architecture patterns help us achieve this\n\n- Orchestration\n- Choreography\n\n## Orchestration\n\nOrchestration is the simplest way to model workflows. The core idea of the Orchestration pattern is to keep the decision logic centralized and have a single brain in the system.\n\nIn our example, the Orders service can be that brain, and when the order is placed the order service talks to Notification, Seller, and Logistics services and get the necessary things done. The communication between them is synchronous and the Orders service acts as the coordinator.\n\nThe workflow as part of our example is a one-level simple workflow but in the real world, these workflows could become extremely complex and the Orders service would be needing to handle the coordination.\n\n## Choreography\n\nThe core idea of the Choreography pattern is to keep the decision logic distributed and let each service decide when needs to be done upon an event. It thus laid the foundation for Event Driven Architecture.\n\nIn our example, when the order is placed the Orders service will simply emit an event to which all the involved services subscribe. Upon receiving an event, the services will react accordingly and do what they are supposed to.\n\nAll the 4 involved services are thus totally decoupled and independent; making this a truly distributed and decentralized architecture\n\n## Orchestration vs Choreography\n\nMost model systems are inclined towards Choreography as it gives some amazing benefits\n\n- loose coupling: services involved are decoupled\n- extensibility: extending the functionality is simple and natural\n- flexibility: search service owns its own decision on the next steps\n- robustness: if one service is down, it does not affect others\n\nObservability might become a challenge here; given that we need to track each service, action it took, and completion of it.\n\nAlthough people prefer choreography, it does not make Orchestration bad. Orchestration has its advantages and can be used in modeling services that are involved transactionally.\n\nFor example, sending OTP during login is best modeled synchronous instead of doing it async. Another example is when we want to render recommended items the Recommendation service talks to relevant services to enrich the information before sending it to the user.",
    "notes_gd": "https://drive.google.com/file/d/1h-YVs2toYWW0qnRKGoPbPdlkpDgp9M9m/view?usp=sharing",
    "slug": "designing-workflows-in-microservices-orchestration-vs-choreography"
  },
  {
    "id": 136,
    "topic": {
      "id": 0,
      "uid": "microservices",
      "name": "Designing \u03bc-services",
      "one_liner": null,
      "youtube_playlist_id": "PLsdq-3Z1EPT0ug8eizS71G6LZb6-4FAFt",
      "bgcolor": "#FFFAE6",
      "themecolor": "#CAA200"
    },
    "yt_video_id": "ewUw0sUxHI4",
    "title": "Synchronous and Asynchronous Communication between Microservices",
    "description": "How should two microservices talk to each other? Picking the right communication pattern is super-important as a good decision will ensure a great user experience and scalability while a bad one will ruin the party.\n\nThere are overall two categories of communication: Synchronous and Asynchronous; In this video, we in-depth discuss what synchronous communication is and how it is done, what asynchronous communication is and how it is done, the advantages and disadvantages of both of them, and most importantly understand how to decide which one to opt for with some real-world examples.\n\nOutline:\n\n00:00 Agenda\n03:08 Need for Communication between Microservices\n05:10 Synchronous Communication\n08:17 Advantages of Synchronous Communication\n09:07 Disadvantages of Synchronous Communication\n15:58 When to use Synchronous Communication\n18:40 Asynchronous Communication\n23:01 Advantages of Asynchronous Communication\n31:41 Disadvantages of Asynchronous Communication\n34:39 When to use Asynchronous Communication",
    "img": "https://i.ytimg.com/vi/ewUw0sUxHI4/mqdefault.jpg",
    "gif": "https://media.giphy.com/media/3orif4qbRS6WjGJ2zC/giphy.gif",
    "duration": "40:10",
    "view_count": 1571,
    "like_count": 99,
    "comment_count": 10,
    "released_at": "2022-05-04",
    "gist": "Say, we are building a Social Network and anytime someone reacts to your post, you need to be notified. So, how should the Reaction service talk to the Notification service to send out a notification?\n\nThe communication would be much simpler and reliable, just a function call if it was a monolith; but things become tricky as we go distributed.\n\nMicroservices need to talk to each other to exchange information and get things done; and there are two categories of communication patterns - Synchronous and Asynchronous.\n\n## Synchronous Communication\n\nCommunication is synchronous when one service sends a request to another service and waits for the response before proceeding further.\n\nThe most common implementation of Sync communication is over HTTP using protocols like REST, GraphQL, and gRPC.\n\n### Advantages of Synchronous Communication\n\n- It is simple and intuitive\n- Communication happens in realtime\n\n### Disadvantages of Synchronous Communication\n\n- Caller is blocked until the response is received\n- Servers need to be pro-actively provisioned for peaks\n- There is a risk of cascading failures\n- The participating services are strongly coupled\n\n### When to use Synchronous Communication\n\n- When you cannot proceed without a response from the other service\n- When you want real-time responses\n- When it takes less time to compute and respond\n\n## Asynchronous Communication\n\nThe communication is asynchronous when the one service sends a request to another service and does NOT wait for the response; instead, it continues with its own execution.\n\nAsync communication is most commonly implemented using a message broker like RabbitMQ, SQS, Kafka, Kinesis, etc.\n\n### Advantages of Asynchronous Communication\n\n- Services do not need to wait for the response and can move on\n- Services can handle surges and spikes better\n- Servers do not need to be proactively provisioned\n- No extra network hop due to Load Balancer\n- No request drop due to target service being overwhelmed\n- Better control over failures and retires is possible\n- Services are truly decoupled\n\n### Disadvantages of Asynchronous Communication\n\n- Eventual consistency\n- Broker could become a SPoF\n- It is harder to track the flow of the message between services\n\n### When to use Asynchronous Communication\n\n- When delay in processing is okay\n- When the job at hand is long-running and takes time to execute\n- When multiple services need to react to the same event\n- When it is okay for the processing to fail and you are allowed to retry",
    "notes_gd": "https://drive.google.com/file/d/16T1TszFP0yXXxFWAk9wQnzii5JIeo5O2/view?usp=sharing",
    "slug": "synchronous-and-asynchronous-communication-between-microservices"
  },
  {
    "id": 133,
    "topic": {
      "id": 0,
      "uid": "microservices",
      "name": "Designing \u03bc-services",
      "one_liner": null,
      "youtube_playlist_id": "PLsdq-3Z1EPT0ug8eizS71G6LZb6-4FAFt",
      "bgcolor": "#FFFAE6",
      "themecolor": "#CAA200"
    },
    "yt_video_id": "tV11trlimLk",
    "title": "Should some microservices share a database?",
    "description": "Microservices need to communicate with each other. Communication between them is always about getting or updating data that is owned by the other service. What if a service gets direct access to all the data it wants? This is the simplest way for the microservices to communicate with each other, and this pattern is called Sharing the Database. The core idea here is to let anyone who needs the data from a service or wants to update something, can directly talk to its database - no middlemen needed.\n\nAlthough most people think it is the wrong way of communication, we should not discard it completely. In this video, we talk about what this architecture pattern is, the 4 challenges associated with it, see ways to mitigate them, and understand when and where it could be beneficial for us to share the database rather than going through a middleman.\n\nOutline:\n\n00:00 Agenda\n03:13 Introduction\n04:14 Advantages of a sharing a database\n06:55 Challenge 1: External parties getting internal details\n10:30 Challenge 2: Replicating business logic\n13:31 Challenge 3: Risk of data corruption and deletion\n14:50 Challenge 4: Abusing the shared database\n16:27 Should we share the database then?",
    "img": "https://i.ytimg.com/vi/tV11trlimLk/mqdefault.jpg",
    "gif": "https://media.giphy.com/media/fxwvlpoM7NwP7i4jFB/giphy.gif",
    "duration": "21:21",
    "view_count": 1750,
    "like_count": 94,
    "comment_count": 22,
    "released_at": "2022-04-27",
    "gist": "Microservices need to communicate with each other, and one such way of doing it is through a shared database.\n\nFor example: While building a multi-user blogging application, say we have a Blogs service that manages all the blogs-related information and we have an Analytics service that takes care of all the analytics like Likes, Shares, Views, etc.\n\nAnalytics service updates the information asynchronously directly in the blog's database; eg: total_views that happened on the blog. This can be easily achieved by sharing the database between Blogs and Analytics, and this pattern is the Shared Database pattern.\n\n### Advantages of sharing the database\n\n- the simplest way of integration\n- no middleman involved\n- no latency overhead\n- quick development time\n\n## Challenges with Shared Database\n\nThere are 4 challenges to using this pattern\n\n### External parties know internal details\n\nBy sharing the database across services, an external party (Analytics) would get to know the internal details of the Blogs service; eg: deletion practice, schema, etc.\n\nThis leads to a very tight coupling between the services; which then restrains the maintainability and performance of the system. For example, whenever the Blogs service changes the schema, the Analytics Service would have to be informed about the change.\n\n### Sharing the database is sharing the logic\n\nTo compute some information we need to query a set of tables; and say, this information is required by the Blogs, Analytics, and Recommendation service.\n\nThe business logic to compute the information has to be replicated across all the 3 services. Any change in the logic needs to be made across all the services.\n\n### Risk of data corruption and deletion\n\nThere is a risk that one of the services might corrupt or delete some data given that the database is shared between the services.\n\n### Abusing the shared database\n\nOne service firing expensive queries on the database will affect the performance of other services sharing the same database.\n\n## When to share a database?\n\nA shared database pattern is helpful when you are seeking quick development time. Although it is not the best practice, sharing the database does reduce the development effort by a massive margin.\n\nSharing the database is also seen where it is inconvenient to have a middleman for the communication; for example: sending a notification to a million followers of a person is simple when the Relationship database is shared with the notification fan-out service; instead of iterating the millions of followers through some middleman API.",
    "notes_gd": "https://drive.google.com/file/d/1ql0chRVpcjgV4Fv_MJTRaXbtIZ3QJwcI/view?usp=sharing",
    "slug": "should-some-microservices-share-a-database"
  },
  {
    "id": 129,
    "topic": {
      "id": 0,
      "uid": "microservices",
      "name": "Designing \u03bc-services",
      "one_liner": null,
      "youtube_playlist_id": "PLsdq-3Z1EPT0ug8eizS71G6LZb6-4FAFt",
      "bgcolor": "#FFFAE6",
      "themecolor": "#CAA200"
    },
    "yt_video_id": "nfkdKHcKxbE",
    "title": "How to scope a microservice?",
    "description": "Microservices are extremely tempting and you will always feel like writing a new service for every problem at hand. You might build a service with very fine-grained responsibilities or you can build one that covers a big spectrum. So, what is the best approach? How should you decide?\n\nIn this video, we talk about ways to model and scope a microservice such that the architecture remains robust and flexible; and to achieve this we use the two key guiding concepts - Loose Coupling and High Cohesion.\n\nOutline:\n\n00:00 What is the problem with Microservice?\n03:05 Why do we love building microservices?\n04:04 What happens if we do not scope our services well?\n05:52 Two key guiding principles to scope a microservice\n07:19 Loose Coupling\n12:15 High Cohesion",
    "img": "https://i.ytimg.com/vi/nfkdKHcKxbE/mqdefault.jpg",
    "gif": "https://media.giphy.com/media/fKvTY11icTAZIPCIQb/giphy.gif",
    "duration": "19:3",
    "view_count": 1045,
    "like_count": 54,
    "comment_count": 4,
    "released_at": "2022-04-20",
    "gist": "It is always exciting to create new microservices as it gives us so many things to look forward to- a fresh codebase, a new tech stack, or even maybe a clean CICD setup. But does this mean we should create as many microservices as possible?\n\nWhenever we decide to create a new microservice, it is very important to understand its scope of it. If you create a new service for every utility then you are effectively creating a mesh of network calls that is prone to a cascading failure. If your scope is too big, it would lead to the classic problem of a monolithic codebase.\n\nThere are a couple of guiding principles that would help us with scoping of microservice.\n\n## Loose Coupling\n\nServices are loosely coupled if changes made in one service do not require a change in other. This is the core ideology behind microservices as well, but while designing a system we tend to forget it.\n\nSay, we have an Orders service and a Logistics service. These services are loosely coupled when they do not share anything in common and are communicating with each other via API contracts.\n\nTo achieve loose coupling, make your microservices expose as little information as possible. The other service should just know how to consume the data and that is it. No internals, no extra details.\n\n## High Cohesion\n\nThe principle of High Cohesion says that the related behavior should sit together as part of one service while the unrelated ones should be separate. This would encourage services to be operating independently.\n\nIf the Orders service also owns the customer data then when the changes are deployed in one might affect the other module. So the scope of testing before taking things to production increases.\n\nIf there is a very strong coupling between the services then it may also happen that the changes in one lead to deploy a few other services- all at the same time. Deploying multiple services at the same time is very risky; because one glitch and the almost entire product is down.\n\nHence it is not favorable for heterogeneous components to be part of the same service. Keep it crisp and short; and while designing try to keep services loosely coupled and split it to a level where the unrelated components are split up.",
    "notes_gd": "https://drive.google.com/file/d/1_P8YVcw7uwr0wfs2V6W-1gpOwnoG2Zdf/view?usp=sharing",
    "slug": "how-to-scope-a-microservice"
  },
  {
    "id": 119,
    "topic": {
      "id": 0,
      "uid": "microservices",
      "name": "Designing \u03bc-services",
      "one_liner": null,
      "youtube_playlist_id": "PLsdq-3Z1EPT0ug8eizS71G6LZb6-4FAFt",
      "bgcolor": "#FFFAE6",
      "themecolor": "#CAA200"
    },
    "yt_video_id": "JPj6mhVLQN0",
    "title": "Advantages of adopting a microservices-based architecture",
    "description": "Microservices are great, and the overall microservices-based architecture has some key advantages. In this video, we talk about what are microservices, the key advantages of using a microservices-based architecture, and understand how to fence service and define its set of responsibilities.\n\nOutline:\n\n00:00 What are microservices?\n01:53 Key advantages of adopting a microservices-based architecture\n09:48 How to fence a microservice?",
    "img": "https://i.ytimg.com/vi/JPj6mhVLQN0/mqdefault.jpg",
    "gif": "https://media.giphy.com/media/lKXEBR8m1jWso/giphy.gif",
    "duration": "14:18",
    "view_count": 2097,
    "like_count": 145,
    "comment_count": 13,
    "released_at": "2022-04-08",
    "gist": "Microservices are small, autonomous, harmonic subsystems that work together to solve the bigger problem.\n\nThe core idea of microservices is Divide and Conquer. We break the big problem into smaller sub-problems, and solve each of the sub-problem optimally, enabling us to solve the bigger problem well.\n\nWhy Microservices?\n\n## Codebase grows over time\n\nThe product evolves and new features are added to it and that bloats up the codebase. It becomes difficult for multiple teams to coordinate and collaborate on a humungous codebase. One team breaking one module can take down the entire product.\n\n## Scaling is predictable\n\nWith microservices, scalability becomes predictable; you can linearly amplify the infrastructure requirements of individual microservices and be predictable in handling the load.\n\n## Teams become autonomous\n\nWith each team responsible for a set of microservices they can take charge of their tech stack and design decisions. These decisions will be best for their problem statement and can ensure that they are solving them the best way possible.\n\n## Fault Tolerance\n\nIf one microservice is down, it may lead to a partial outage of the product affecting a small fragment of the systems; while other components remain unaffected and can continue to service the traffic.\n\n## Upgrades are simpler\n\nSo long as a microservice adheres to the API contract, the team that owns it can upgrade the tech stack, architecture, and DB seamlessly.",
    "notes_gd": "https://drive.google.com/file/d/1lK2e3me09VNz51DWDunI5xDmlgLnOvfC/view?usp=sharing",
    "slug": "advantages-of-adopting-a-microservices-based-architecture"
  },
  {
    "id": 118,
    "topic": {
      "id": 0,
      "uid": "microservices",
      "name": "Designing \u03bc-services",
      "one_liner": null,
      "youtube_playlist_id": "PLsdq-3Z1EPT0ug8eizS71G6LZb6-4FAFt",
      "bgcolor": "#FFFAE6",
      "themecolor": "#CAA200"
    },
    "yt_video_id": "Hxja4crycBg",
    "title": "Handling timeouts in a microservice architecture",
    "description": "Handling timeout well is extremely critical as it makes your distributed system robust and ensures you provide a consistent user experience by adhering to SLA guarantees. In this video, we discover how a synchronous dependency on a microservice leads to long delays becoming a big problem, understand how timeout addresses the concern, and discuss 5 approaches to handle service timeouts.\n\nOutline:\n00:00 Why is handling timeout critical?\n01:13 Synchronous communication and timeouts\n05:39 A rule of thumb: Timeout\n07:52 Approach 1: Ignore the timeout\n10:28 Approach 2: Configure and use defaults\n11:27 Approach 3: Retry when timeout\n16:36 Approach 4: Retry only when needed\n20:06 Approach 5: Rearchitect and remove synchronous dependency",
    "img": "https://i.ytimg.com/vi/Hxja4crycBg/mqdefault.jpg",
    "gif": "https://media.giphy.com/media/3oriO4kSYahYQr6e1a/giphy.gif",
    "duration": "23:38",
    "view_count": 2172,
    "like_count": 142,
    "comment_count": 18,
    "released_at": "2022-03-18",
    "gist": "Microservices give us the flexibility to pick the best tech stack to solve the problem optimally. But one thing that ruins the real thrill is Timeouts.\n\nSay we have a blogging website where a user can search for blogs. The request comes to the Search service, and it finds the most relevant blogs for the query.\n\nIn the response, a field called `total_views` should hold the total number of views the blog received in its lifetime. The search services should talk to the Analytics service synchronously to get the data. This synchronous dependency is the root of all evil.\n\nThe core problem: Delays can be arbitrarily large\n\nBecause the delay depending on service can be arbitrarily large, we know how long to wait for the response. We for sure cannot wait forever, and hence we introduce Timeout. Every time the Search service invokes the Analytics service, it starts a timer, and if it does not get a response in the stipulated time, it timeout and moves on.\n\nThere are 5 approaches to handling timeouts.\n\n- Approach 1: Ignore the timeout and move on\n- Approach 2: Use some default value if you timed out\n- Approach 3: Retry the request\n- Approach 4: Retry only when needed\n- Approach 5: Re-architect and make synchronous dependency an async one",
    "notes_gd": "https://drive.google.com/file/d/1GjObZ3xpLFxDEOO3EGRCj0Pq8bWLixjU/view?usp=sharing",
    "slug": "handling-timeouts-in-a-microservice-architecture"
  }
]