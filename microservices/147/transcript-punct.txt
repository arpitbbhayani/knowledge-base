so restless. our browsers talk to our api servers. 99.99 of all of our api requests that originates from a browser going to our api server are all rest. so what is rest? how is it different from http? is it a protocol or a specification, or a library or a framework? there is so many unanswered questions like this. in this video, we in-depth talk about rest, understand the foundations of it, see how and why it gels so well with http, find why everyone is using it and conclude by going through the downsides of using rest over http. but before we move forward, i'd like to talk to you about a course on system design that i have been running for over a year now. the course is a cohort based course, which means i won't be rambling a solution and it will not be a monologue. instead, a small, focused group of 50- 60 engineers every cohort will be brainstorming systems and designing it together. this way, we build a solid system and learn from each other's experiences. the course to date is enrolled by 600 plus engineers, spanning nine cohorts and 10 countries. engineers from companies like google, microsoft, github, slack, facebook, tesla, yelp, flipkart, dream 11 and many, many, many more have taken this course and have some wonderful things to say. the coolest part about the course is the depth we go into and the breath we cover. we cover topics ranging from real-time text communication for slack to designing our own toy load balancer, to quick buzzes, live text commentary to doing impressions counting at scale for any advertisement business. in all we would cover roughly 28 questions and the detailed curriculum- uh split week by week, can be found on the course page, which is linked in the description down below. so if you're looking to learn system design from the first principles, you will love this course. i have two offerings for you. the first one is the live cohort discourse which you see on the left side, and the second one is the recorded course, which you can see on the right side. the live cover based course happens every two months and it will go on for eight weeks, while the recorded course contains the recordings from one of the past cohorts, as is. if you are in a hurry and want to binge learn system design, i would highly recommend you going for the recorded one. otherwise, the live code is where you can participate and discuss things live with me and the entire cohort and amplify your learnings. the decision is totally up to you. the course details, prerequisites, testimonials- can be found on the course page at with binary dot me master class, and i would highly recommend you to check that out. i put the link of the course in the description down below. so if you are interested to learn system design, go for it. check out the link in the description down below and i hope to see you in my next cohort. thanks. so rest stands for representational state transfer, and here the key idea around this specification is representation of entities. so in a standard client server architecture that we have, your client sends a request and your server sends a response. the response that server sends is in some representation. more often than not, we have seen json as the representation. here your client is demanding something from the server and your server is basically serving the response. right, so here what you have unrest is everything is a resource, resource, implying that an entity in your system- for example, if you are building your library management system, then student is a resource, or book is a resource. if you are building an e-commerce, then your seller is a resource, your, your user is a resource, your item is a resource, or your purchase order is also a resource. so the idea here is that in rest, everything is a resource. it can have its own set of storage. we are not worrying about that. that is independent. rest is actually just a specification on how your client should be asking things from your server and how your server and how your server should responds. that's it. that's all about rest. so, rest being just a specification, it does not enforces us to do anything. it simply suggests that, hey, you should be doing these things, right? so that's where resource becomes the key entity. uh, in while while we are adopting rest, right, so any and every data that we have in our service, in our system, is an exposed resource. for example, students in my library management system is a resource which i am exposing through http endpoints, right, so the way we, the way we traditionally do, but the way student is stored in my db is up to me- like rest cannot enforce how i would want to store that information in my database. this just tells that when i'm talking to my api server. this is the format that i expected, but it does not enforce that. hey, you have to store it in tables rows, or you have to store it in mongodb, or you have certain document storage or key value. no, not like that. rest is only there to tell us how your client and server should communicate or the way it should communicate. everything else is part of our implementation. so say, we put all the students information in one table in our relational storage. all messages in our chat application maybe goes into apache, cassandra, we don't care about that. the idea is that the way your data is stored in your database is independent from how your data is served to your user. so you may choose to store your student information in tables, rows and columns and serve it as a json response. perfectly fine, you don't need to have synergy between the two. you don't need to have the exactness between the two. the idea is simple: store it however you want, but serve it the way client is asking your data for, or the representation in which client is asking your data to be served, right. so this is where what rest gives you the flexibility that your client can ask for a particular representation. where a client says, hey, give me this data in csv format, or give me this data in json format, or give me this data in xml format, your client has an option to ask, to ask from the server a particular data in a particular representation, which is why it is called as representational state transfer. so you- and obviously it is not mandated as such, but your server should be able to support that sort of representation, but at least there is a way to do it, which is why you see, the http request we make has a content type header that hey, i am sending new content in this type and i'm expecting a content in this type, which is why http is very widely adopted to implement rest. so here a a very solid rest representation would have multiple representation of your entities, maybe xml format, json format, but it is not mandated that you have to have all of them. you can choose to just have json as your representation format, which is perfectly fine, okay, so let's move to the next part, where what is all about this representation that we are talking. so here your client demands a particular representation of the entity. may be json text, xml, csv, and your server has to send the response in that particular format, so long as it is supporting it. internal representation can be different. your client would make in like: we know that most common implementation of rest is over http, so i'm just basically carrying forward on that. uh, your client makes an http request, let's say slash, customer, slash one, two, three. it gets to the server. server goes to the database, which is your relational database, gets it from rows and columns and creates this entire json object and sends the information in json to the client. so you have two different representation. one is internal representation of your entity, which is in table rows and columns, and one is external representation of your entity, which is in json. so it it purely depends on your server's implementation, or how it wants to send the data, or what all representation would it support, right? so here the idea is that any and every operation that comes, or any and every request that comes from the client, that request has to happen over a resource, and this resource is typically specified in the http url that we sent. so here you like, when you want to create a resource, update a resource or delete a resource, any sort of thing that you want to do, you can specify it as a verb: hey, that this is the action that i want to take and this is the resource on which i want to take this action. just a specification. so rest is again just as specific. so it does not enforce that. hey, you have to use this protocol. so rest is saying that, hey, you can choose to use tcp, you can choose to use http, you can choose any protocol you like that to implement. rest is just a specification. so the most common implementation of rest is with http and it gels so beautifully well that by default, when we now write apis, we write rest apis, right. the way we define our urls is how rest recommends us to do that, and both have become very synonymous. the way, uh, the way we expose endpoints, the way we ignore, we think we are writing rest. we may not even be writing rest, we met just exposing http endpoints, but we always think that we are writing rest endpoints, right? so it's that synonymous. so why did rest and http gelled so well? what? what happened? what happened here? so here, one thing that made http uh really solid for us to adopt rest is http verbs- verbs as it get put, post, delete, http methods that we have. that is a very powerful feature because with http, what you have is you have this verb or you have this http method- get put, post, delete- and you have a path or you have a url on which you are making that request, right? so this url is nothing but your resource and your http verb is the action. so, for example, if i want to delete a particular user, we expose an endpoint, slash users, slash user id, and we expose the method delete on that. so, because delete is the http verb or http method that is out of the box supported by all web servers out there, you can directly invoke an http delete on slash user, slash one, which is which becomes your resource identification. so what does this url imply? this url implies that for a type, so for a type user which is identified by id 1, delete it or delete the particular resource. so this fits so beautifully well that your action is specified by http method and your resource is identified by your url. and which is why we, when we expose uh http endpoint, we think we are doing rest slight difference, but you basically get digest. so this has to be the identification of the resource. the url that you have has to be the identification of the resource, while your delete get port post. all of these are actions that you want to take on top of it. the best part over here is, with http verbs, we can multiplex it on the same resource. so, for example, i, my url is slash students, slash one, which means for us, for an entity type student, anyone who is identified by id one. my url would become slash student, slash one. and here, if i would want to get the student detail, i would do a get on this url. if i want to update the student detail, i would do a post on this url. if i want to delete this student, i would do a delete on this url. so get put post delete, standard four operations that we we typically go for. so here, what we are so beautifully doing is we are so beautifully using the same url, just changing the method, and the entire connotation is changed. and this is a very well defined uh specification as part of http specification that, hey, these four methods would be there: get put, post delete or, obviously, options patch and others exist. but you basically get this idea that http, because it is so widely adopted, it has already support for http methods which every single client and web server understands. why not piggyback rest on top of it? which is why we still you and we still expose just normal http endpoint, but we chose to do it in a certain way, like slash student, slash one. no one's enforcing us to do it that way. that is the rest way of doing it. you could have also done something like this: let's say i want to get details of a particular student. i could have done. i could have exposed an endpoint, slash, get student, in which i am passing in body the student id and i'm getting this information out. that is also an http input, but that is not rest implementation. that is the difference. so rest says: use http methods wisely. the url should be an identification of your resource and not the action that you are taking. so, for example, if i want to update the student, i can say post. uh, i can expose a post method on slash student, slash id and that would update the details of that particular student. otherwise, i can expose slash update student as a method or as an end point and i can take all the required parameter in the post body and do that action. so this is why basic, this is exactly where the difference lies. rest is how we are now accustomed to build endpoints: slash, student, slash one is the resource and get put post delete is the action right. so that's the key difference between http and rest. so how we are using http to implement rest, rest is a specification on how you should be talking to your server, the way you should be specifying the input and the output. now let's talk about why http gels like. again, one very solid reason why http gels so well with the rest: because of two links. so because web is very widely allowed, obviously the internet is widely adopted, and because of the already established tooling that we have for http like, for example, you have clients like curl postman request in python and what not. you have clients to make http request, get http response, understand the headers part of it, set the response headers and whatnot. you have those two links in place, which means that you don't have to reinvent the v, you don't have to build something very different for this sort of representation or this sort of specification. so that's where existing tooling is so good. let's say, with respect to clients, that you can just import http or you can just import the request module in python and start making http request. you have the browser, you can directly make post request through form submission and you have your uh and you have your rest specification implemented on your api server. second, web caches, like nginx cache, varnish, ha, proxy- so many are there on which you can cash the responses out, which means you can get good sort of performance without changing a lot of things, because nginx and all you would anyway have with the rest, you are just leveraging what you already have. you don't have to build a separate caching mechanism to solve that problem. nginx coordinates hp proxy, so many things would do so well. third, monitoring tools like distributed request tracing, a packet sniffing, debugging, http request response monitoring, alerting, uh, then basically application performance monitoring. everything is very well built for http as a specification, so why would you want to define your other specification and rebuild those things? you have your existing monitoring tools. that would serve just well and get it adopted. that's why rest over https uh, it gels so well. next, load balancers. you want to distribute load uniformly. http based load balancers are there. they are ruling the world right now and you have all of those things. why would you want to have a separate load balancing strategy for your own specification? you don't need that, which is why it deals so so, so beautifully well that you are using your existing ecosystem of tools and libraries and frameworks and infra components and whatnot and just gaining the benefit out of it. and security control, ssl, uh optimization technically, competitions and all out of the box. http gives you those abilities or your web server gives you those abilities, so you don't really have to worry a lot. you can just piggyback up on existing tools. but obviously it gels so well. but there are few downsides. these are just downsides of using rest over http. this does not mean that we should not be using it. obviously the world uses it, we use it, but this does not mean that we should not be. just that. we have to be aware of what would be the potential downsides of using rest over http, just so that we don't make a mistake. that would prove very costly in the future. first of all, consumption is not easy. so here in in one of the previous videos we talked about rpcs, right, uh, remote procedure calls. there we saw how stubs are generated and that stubs makes things native to the programming language. we are using rest, on the other hand, because it runs on top of http, there is no standardization- standardization with respect to the stub generation or native objects. every single client of yours can. obviously you can use http client to make a call, but when you get the response- you are getting response, say, in json- you have to convert it to a native object and then consume. so that is that additional thing that you have to take care of, because it's restaurants on top of http. there is no native language involved whatsoever. it's just a way for you to send a request and get a response in some format. here we got it in json response, but then you have to write those things on your own that i want to. i got a json response, i'm converting it into, let's say, you're writing in python, you get the json response. you have to convert it into dictionary before you consume it, let alone the corresponding classes that you are expecting, right? so consumption is not easy. you have to uh do that extra civilization, digitalization, conversion into native objects and what not. that might become expensive for low latency application. second, consumption is repetitive. obviously it's not easy, but it is repetitive as well, which means anyone and everyone who wants to consume the same uh resource or do that operation on the same resource, you have to write it same stuff again and again, for example serialization, digitalization, logics to and from native objects, failures, timeouts, retries, compression, security and whatnot. everyone who is invoking the same resource or who is trying to do that same operation on that same resource, let's say through multiple services. they would all have to do it again and again. a company might have an internal standardization, let's say a common way to do it, but in most cases you would have to do that thing again and again. now you have to repeat or create a shared internal library so that you know not everyone has to write that same failures and retries and what. not something that grpc or not really give, but something that rpc abstracts it out for you. here you would have to build that shared internal library and everyone has to do it, and then they would be able to standardize the way the communication happens by masking or abstracting failures, retries and whatnot. the next is some web servers may not support all http works. so for a standard server like, let's say, jersey or nginx or your uws gi servers, they support all http works. but let's say you made a decision choice of picking a particular http server that only supports get and post, does not support put, delete, patch options. you are stuck with that. you are stuck with that, which means that you are limiting your potential of using rest because by changing the http method you are multiplexing actions on the same resource. here you would not be able to do it here. you would have just get and post on that. but if you want to delete, you may want to expose some other kind of end point. so slash student, slash one slash, delete something like that which is not really rest like right. so the kind of web server you pick or the kind of tech stack you go for, you have to ensure that it supports all the http verbs out there. but if your, uh, any of your component is not supporting verbs or all the http verbs, it will cause a problem. you then you are not really doing the rest way right. the next is http payloads are huge example: json. json is not the format built for low latency requirement. it is built for readability. it is not meant for low latency requirements. so that is where the http payloads in the request and the response that we get. in most cases it would be json. so it takes time for your clients or for your server to understand the json, create it or basically, uh, parse it into native object and then consume it. plus the amount of data that is transferred with rest is very repetitive. you have the double quotes, the string, the, the colon and then the value and then a comma. so many things are there which looks very redundant. so that is where the json payloads are very huge uh and not really suitable for low latency requirements. so that's where when you have ultra low lit, where you have low latency requirements, you would typically go for something like rpcs that use protobuf to to compress your message in a very, very, very short uh, in a very short payload and then send it right. but obviously it has its own uh disadvantages. but you basically get digest but have smaller uh unit of data transfer you would want to go. or for ultra low latency requirement you might not want to go- for uh rest over http plus. with http what you also get is every time you make a request you have to make a three-way handshake tcp connection, then file the request, then get a response, although you can use http 2, but again you have to be very of the fact that with http version are you using to communicate over rest. the final downside that i want to talk about is switching protocols. let's say, for some use case you don't want to use tcp, you want to use udp, changing or switching protocols with http. obviously it's not possible because http runs on top of tcp. but let's say, for some requirement. you wanted to switch to udp for better performance and it was okay for you to lose out on some packets, but you wanted performance out of your system, so then you would have to go for udp. but if you went for udp, uh, a rest over http won't understand, because http only under works on tcp, so, which is where you might not be able to extract the best performance out of your system, given your workload, right, it might not be like you always want udp, but for use case where you would want to switch protocol, it does not give you that flexibility. rpcs give you that flexibility. so, but obviously rest is widely adopted. in most cases you would need it, unless you're writing a very ultra low latency application. but still having that flexibility of changing the underlying protocol is a pretty solid advantage that you'll get. so using, but obviously going through this downside does not really mean that we should not be using rest over http. the entire internet is working on that and it is pretty, pretty, pretty solid. uh, very well, battle tested, all sorts of existing toolings works just fine with that. so unless you have a very specific requirement, don't, don't overthink too much. this was just, uh, my way of telling you: hey, grass is not always green. uh, there are some limitations and you have to be aware of it whenever you are adopting something. so if you're very strict requirement around uh, or not strict, but other very specific requirement, pick the right specification. you go for rpc, you go for rest, it's up to you, but it depends a lot on the sls that you would want to guarantee or the kind of use case that you have at hand, right? so just be very of the fact. this was my way of listing on all the downsides that you have to be aware of while using rest over http. and yeah, that's it. that's it for this one. i hope you now you get an understanding of what rest is and what https and what, and just a small glimpse of what rpcs if you want. if you are inclined into understanding more about rpcs, i already have a video on my channel you can. i would highly encourage you to check it out. if you have any confusion around rpc. that video would solve the problem for you or it would help you understand on what rpc is all about. but today we only talked about rest and how it is different from http, uh, upsides of using it, uh, how it gels so well with http and the downsides of rest over http, so that we are all aware of what we have at hand. so, yeah, that's it. that's it for this video again. if you guys like this video, give this video a thumbs up. if you guys like the channel, give this channel a sub. i post 3 in-depth engineering videos every week and i'll see you in the next one. thanks, saturn.