in a micro services based architecture, there will always arise a need to design workflows. for example, when on an e-commerce website someone places an order, we need to send an email confirmation to the user, notify the seller to keep the shipment ready and also assign a logistic delivery partner so that the package is delivered to the user. modeling these workflows is challenging, as it requires multiple micro services to coordinate. so how can we implement them? there are two high level architecture patterns to implement workflows in a micro services based architecture, and they are orchestration and choreography. in this video, we take a detailed look into the two patterns, see what they are, how they are implemented and which one to use when. but before we move forward, i want to talk to you about a code based course- coastal system design- that i have been running since march 2021. right, if you're looking to learn system design from the first principles, this course is for you. yeah, because this is a cohort based course. it will not just be me rambling a semi-optimized solution, thinking it's the most amazing solution out there. instead, it will be a collaborative environment where every single person who is part of the cohort will can pitch in his or her ideas, and we will evolve our system around that right. every single problem statement comes with a brainstorming session where we all together brainstorm and evolve our system. that's why everyone understands the kind of trade-offs we made while making that decision. instead of just saying, hey, we'll use a particular queue, we'll have the justification why we use only that queue, why we use that particular database, why sequel, why not no sequel? right? how are we leveraging throughput? how are we ensuring that our system scales? that's the highlight of this course. this course is taken by more than 500 engineers to date, spanning nine countries and seven cohorts right. people from all top companies have taken this course and the outline is very intriguing. it's very exciting. so we start with week one around. we start with the core foundation of the course, where we design online offline indicator. then we try to design our own medium. then we go into database, where we go in depth of database logging and take and see few very amazing examples of data log or database logging in in action and how do we ensure that our system scales through that. then the third week is all about going distributed, where we design our load balancer. i'll have oculus of the actual code of a toilet balancer and understand how pcb connections are managed and how simple it is to build load balancer. then week 4 is about all about social networks. week five is all about building your own storage engines, like we'll build that intuition on. if you were to ever design your storage agent, how would you do that right? then week six is about building high throughput system. seven is about building uh ir system- basically information retrieval systems, and adult designs where we design our own message brokers like sqs, where we design distributed tasks scheduler. and we conclude the course with week 8, where we talk about the super clever algorithms that has powered or that has made those systems possible. right, i have also attached a video, verbatim as is, from my first code where we designed and scaled instagram notifications. i will highly encourage you to check this video out. right? and now back to the video in our discussion. how are we going to implement workflows in a pure micro services based architecture? so say we are building. so say we are building an e-commerce website and whenever a user purchases something, we have to send an email confirmation to the user, notify the seller to keep the shipment ready and assign a logic delivery partner to ship it. so theoretically, or basically visually, it can be visualized into a very simple looking flowchart. whenever order is placed, order service accepts the order and somehow the user needs to be notified, seller needs to be notified, delivery partner needs to be assigned, right? so here there are three services which are involved after the order is placed. so how will these service get to know what they need to do? so there are two ways to model, uh, such workflows on microsoft space architecture. the first one is orchestration. second one is choreography. let's look, let's take a look at orchestration now. so the core idea of orchestration is that the decision logic should be centralized, right? so let there be a single brain who tells others exactly what to do. so a simple example would be: whenever the order service takes the order, it becomes the brain, it becomes a coordinator, and what it would do is it would invoke the api of the notification service to send an email notification to the user. it would invoke the app, the seller- in order to ask it to keep the shipment ready. i would then contact the logic service to basically assign a logic delivery partner, right? so here the order service is acting as that brain who would do that coordination and and ensure that the entire workflow is complete, right. so here all the three, and obviously this, this need not be a distributed transaction, not not going into that complexity- understand, oh, basically absorb the overall idea of orchestration as a, as a pattern, right? so here the thing is pretty simple. there is only one brain, which is order service. right now, the other three services are dump, so order service will tell them exactly what to do and they will just do that. right. so order service would know when to trigger what and it would do the and it would do the overall trigger part and all right. other services are not independent. so notification service, seller service, logics, logic service- they are not independent, so they cannot independently decide. okay, hey, now i want to send the notification to this, or now i want to assign a logic delivery partner. someone will tell them. who will tell them? the coordinator, the order service will tell them, right? this is a simplistic example for me, for you folks to understand what orchestration is all about, right? so this, uh, the analogy of this orchestration is basically from a gigantic orchestra where you see the coordinator or the conductor of the orchestrator to tell: hey, now you play the guitar, now you play the drums and all of that stuff, right. so that's the core idea behind the orchestration pattern, and the workflow we designed was just a one level workflow- key order service and then the three involved service. but in real world in- uh, in a very complex business, the workflow can also become very complex and you might need to have the when these two are done, then trigger the third workflow once five are done, then only do this. right. so the workflows can get as complex and you need a coordinator to do that and that is the orchestrator part of it, right? okay, second one: choreography. the idap choreography is basically is basically converse of orchestration. so orchestration says that, uh, this is logic should be centralized. what could be the other thing? decision logic is distributed, right, so the idea here is let every single service have its own brain, and the core concept of choreography is to make it event driven. so this laid the foundation for event driven architectures. you might have heard this term quite a bit in recent times, but this is the core idea behind event driven architecture. so let each service be independent and they need to think what they have to do when something happened, right, so the job of the order service is pretty simple now, so, or whenever order service accepts the order. so, basically, when the order is placed, the order service publishes a message somewhere into a pub, sub message broker, wherever it want to go. but it publishes an event. right, this event is subscribed by all the involved services. when the event is published, the notification service, seller service and logistics service which have subscribed to the event- let's say event is orders placed- they would take the action depending on the event. they are not told what to do, but the notification service, seller service and losses logic logistics service- whenever they get an event, they would take the decision: hey, now the order is placed, what do i need to do? law notification service will say: hey, i need to send a notification to the user. so that would be the business logic that would be handled there. right, so each of the involved services is having its own separate brain, right? an order service, once the order is accepted, just published a message and done. right so this is the core idea behind event driven architecture, right? this? basically the prince, the architecting complex workflows on a pure asynchronous basis is basically choreography and the foundation for event driven architecture. right? so now, whenever the order is placed and the order service simply publishes an event, simply emits an event into a pub, sub, kafka, whatever you want to use that's, that's not a concern of us, right? and the notification service, seller service and losses logistics logistics service- sorry, gets that a particular event and then they decide what to do with it, right? so here, if we see all the four services, they are not totally decoupled. every service is running on its own. whenever they receive the event, they take the action. right, and the best part is this makes a system very extensible. now, for example, if tomorrow we have to add the fourth service, that whenever the order is placed, i want to, i want to show it into the orders page of the user, that would be a poor example, but hypothetically, let's say we want to do that, right? so then it would just be adding one more service which is subscribe to the same order placed event and then, like your system is very extensible because the services are pretty decoupled, right? so that's the idea of choreography, right? and the ways to implement this is using message broker, uh, message streams, like kafka and whatnot, right, you can use any of this to implement this drop off sub box. but the core idea is publishing an event, subscribing from an event and every service independently taking its own decision now which one to use, when, where and by and how, and all of that right, how, how are we going to decide? so, if you see, in today's day and age, most modern systems, they are inclined towards choreography because it gives you loose coupling. we just saw how, uh decoupled all the four services were: order service: when it accepted the order, just need to publish an event and done. right, it does not have to do that coordination between other services. it made systems very loosely coupled. it made the system extensible as well, because we saw adding a fourth service as a consumption of the same order space event was so simple, right. it made our services very flexible because now services are independent to take its own change, like, for example, if notification service, earlier only used to send email notification, now also wants to send a mobile notification or an sms notification, can very easily do that because it does not require any sort of complex. the the services service in itself is deciding what to do. right and robust. so here the workings of oneself. so if one of the services down, let's say notification services down, it does not affect the other part of it, like the other services which are subscribing to the same event, they are not affected at all, right, so this makes our overall architecture pretty robust. so, which is why most modern architecture prefers- they prefer choreography in most cases, right, and. but with choreography, what we need to be very aware of is the observability becomes very complex because the entire communication is asynchronous and decoupled. what would happen is: how would you know if a message was sent, or or if an event was published? first of all, if the event is published, then the event is. then, uh, basically all the three involved services got that event. if they got that event, how are you sure that they have actually sent the message? so observability across all of this decoupled system is a big pain. so you need to be very of the fact that you might have to build a very complex observability uh module in order to visualize on what's done and what actually. there are tools to do that. uh, you can take a look- something called as distributed tracing, and you would get the idea. but observability becomes a challenge. so you need to know that everything is eventual. you need to know that, uh, you need to know the path that that event took and what action who did and where and why. so also a little bit bit of a challenge, but not as big, but still you need to be very of the fact that observability might be a little tricky. but one thing to note is, like i always say, this life is non-binary. why do you think if one is good, the order has to be bad? people think that, hey, everything is even driven. so, no, we should not be using orchestration. no, i agree that choreography is good, but this does not mean that orchestration is bad. right, because orchestration is synchronous. it's a request response based thing. we can use it at a lot of places where we need synchronous communication between services, for example, services that needs to be invoked transactionally, basically distributed transaction across services. in few few, few weeks back i i created a couple of videos on uh display transaction using two phase commit and exact and actually implemented a two phase commit disabled transaction to mimic a 10-minute grocery delivery thing, right? so do, do, do, take a look at on my channel, uh, in order to understand what distributed transactions are and how they're actually implemented. it's not just theoretical, but we have practically implemented that. so i would highly encourage you to check it out. but here, when we talk about this, that the sort of communication that we are looking at is, whenever we use orchestration we can, as we can, have distributed transition that ensures that all the three are done. then only one would happen, right? so if you would want to model distributed transactions- either all or none- that can very easily be modeled using orchestration, because the communication needs to be synchronous, right. so that is one great place where orchestration comes in extremely handy. second, for example, you want to send in. you want to send a otp for logging in. now this cannot be done asynchronously. that i just emit an event and my notification service will send an otp to the user. that is a very wrong way to design this, because if you do it asynchronously, it would add a delay for your user to get an otp. let's say, due to any reason, your consumers are down, then your user is not even receiving an otp, right? plus here your mobile carrier. it will take some time for your mobile carrier to deliver the sms to the user. so to ensure that the sms very quickly reaches the user, you need to ensure that the communication happens synchronously. so that's where your authentication service will synchronously talk to your will will synchronously be sending otp by invoking the api of your notification service to directly send otp to your user, so that the logging in time is bare minimum, right. plus you know if it failed you can retry and all right. all of that could be very is very easily modeled when the flow is synchronous. so orchestration comes in very handy with that right. third thing, where, let's say, you have a recommendation system. so your machine learning, data science team has built a a very nice recommendation system which gives you, for a particular item, these are the recommended items. or for a particular user, these are the recommended items. so what they give as an output is item ids. now what you need to do is: but you cannot just send item id store user, right, you need to send item details, hit photo title and what not. so what you do is, when you get item ids from your notification or from your- sorry, from your- recommendation service, you would want to enrich it with very rich details, right? so with the item details, so from ids, you get the details and then you send this detail to the user. this communication between your recommendation service and inventory, this, this thing should be synchronous, right? so you have two ways to implement it: your recommendation service, instead of just sending the ids. your recommendation service itself can talk to inventory service to get the item details and then send it to the user, so that your, your, your client does not need to do heavy lifting. your recommendation service itself is doing that right. so you invoke the api of the recommendation service. recommendation service has the id which are recommend, has the item ids which are recommended to the user. it talks to inventory service to get the item details and it sends this entire details to the user. this way you can render nice recommendation list right. so again, non-binary orchestration is also good. choreography is also good. you'll see a lot of people being inclined towards choreography, but it does not make orchestration bad or it does not make orchestration obsolete. there are places where choreography suits well. there are places where orchestration shoots well, right. so you need to be always aware, hey, which one i am picking, why. what are, uh, the overall sls that i want to meet, or what is the kind of requirement which is non-negotiable requirement from my system, right? so we always be very off that path, nice. so yeah, basically, that's it for this one. i hope you found this interesting. if you guys like this video, give this video a thumbs up. if you guys like the channel, give this channel a sup. i post three in-depth engineering videos every week and i'll see you in the next one. thanks again.