say, we have very happily created six or seven micro services and everything is going good. now for a new use case that is introduced in the product, we have to talk to not one, but three services together to compile the final response. so what is a good way of implementing this and supporting this kind of request coming in the future? a high level pattern that helps us do this is called api composition. in this video, we in depth talk about the super simple pattern to query microservices, see what it is, how it is implemented and understand how it not only helps in improving the performance of our backend systems, but also improve the performance or the experience of our end users, and we'll conclude our discussion with going through the advantages and disadvantages of adopting this. but before we move forward, i'd like to talk to you about a course on system design that i have been running for over a year now. the course is a cohort based course, which means i won't be rambling a solution and it will not be a monologue. instead, a small, focused group of 50- 60 engineers every cohort will be brainstorming systems and designing it together. this way, we build a solid system and learn from each other's experiences. the course to date is enrolled by 600 plus engineers, spanning nine cohorts and 10 countries. engineers from companies like google, microsoft, github, slack, facebook, tesla, yelp, flipkart, dream 11 and many, many, many more have taken this course and have some wonderful things to say. the coolest part about the course is the depth we go into and the breadth we cover. we cover topics ranging from real-time text communication for slack to designing our own toy load balancer, to qrik buzzes, live text commentary to doing impressions counting at scale for any advertisement business. in all, we would cover roughly 28 questions, and the detailed curriculum- uh split, week by week- can be found on the course page, which is linked in the description down below. so if you're looking to learn system design from the first principles, you will love this course. i have two offerings for you. the first one is the live cohort discourse, which you see on the left side, and the second one is the recorded course, which you can see on the right side. the live covered base course happens every two months and it will go on for eight weeks, while the recorded course contains the recordings from one of the past cohorts, as is. if you are in a hurry and want to binge learn system design, i would highly recommend you going for the recorded one. otherwise, the live code is where you can participate and discuss things, live with me and the entire cohort and amplify your learnings. the decision is totally up to you. the course details, prerequisites, testimonials can be found on the course page at pitt binary dot me slash master class, and i would highly recommend you to check that out. i put the link of the course in the description down below. so if you are interested to learn system design, go for it. check out the link in the description down below and i hope to see you in my next cohort. thanks say. we are building an e-commerce platform and we have three services with us: orders, payments and logistics. same. we want to get order details and in this, this is a very super detailed, super granular order detail that we would want to get for a given order. so in this case, what we would have to do is, in order to get the order detail, we will have to talk to the order service. in order to know the payment status of that particular order, we have to talk to payment service and in order to get the shipment, the information or the logistic information about that, we'll have to talk to logistics service about that. so here, our one client needs to talk to multiple services to get the things done. now, this is a classic case of how would we want to query the micro services? so we have added three services, but our user or our client has to talk to them to get the response. so how are we querying them? right, so to query microservices. a very common pattern, a super simple implementation, is api composition. right? so in api composition, what we do is we put a middleman, we put a composer sitting in between. the user makes a request to composer. this composer knows what to do when it gets a particular request. for example, user would make a request get order detail. this composer would then talk to order service to get order information. would talk to payment service to get payment information. would talk to logistics service to get delivery status. this is super simple, super straight forward on what could have been done. but this is exactly what api composition is all about. sitting or basically placing a middleman in your architecture to hide the complexities of the underlying systems, is what this particular pattern solves for us. right, and obviously, do we have to implement this from scratch? not at all, right. so what? what can we use here that would act as a composer. a very common component that solves this exact problem is called an api gateway. so api gateway is a classic example of a composer and we typically place it behind or basically before all of our micro services. so this typically, or api gateway, is the first point of contact for any request coming in from the user, and then api gateway would decide where it would need to forward the request to, or send multiple requests to multiple services and get the response and whatnot. so api gateway is the one who would be doing this for us. and what all popular api gateways can we use? two super popular good projects out there is? the first one is kraken d, the second one is con. really good projects out there. highly encourage you to at least explore them. write a hello world on your local machine. that would give you a very solid understanding of that. if you are on aws, then aws api gateway. if you are on google, if you are on microsoft, they have their own corresponding services. that serves as an api gateway, right. so anything that would give you an api gateway is something that you can use as a composer. you can also choose to write your own composer. no one's stopping you. but why do you invent the wheel if you already have a good, robust solution in place? right? so what we do in our architecture we place api gateway in front of all of our microservices and request directly comes to epa gateway. api gateway either forwards the request to multi up a background, basically forwards the request to multiple services, gets the response uh, merges them, joins them and sends it back to the user. okay, so this. but then when you get a request to your api gateway, how would it forward the request to the uh, to the downstream services? so obviously you might think that, hey, if i would want to make a call to three services, i should be doing it in parallel. right, no one stopping us from doing it in parallel. but here this is very useful specific: it might not be possible to make all the three calls to the three depending downstream services in parallel. it is very use case specific where we need to understand that, hey, do we have all the information to fire the queries in parallel? if yes, go for it. if not, do it sequentially. basically, parallelize where you can, where every data that you need it said, and then you parallelize it. it's perfectly fine, but it's very use case, specific, right, but in general, if we do it sequentially, pure sequentially, one after another, after another, it would take a long time for it to execute, but it is okay. it is not computationally intensive as such, but it would take a slightly longer time to execute, and but it has its own advantages. the second is doing it parallel. it's very tempting to do things in parallel. hey, let me just fork out multiple threads at once, which would basically fire individual queries to individual services. i'll grab the response, merge them and send it back. but what happens is when you have excessive parallelism in your system, it would require a lot of resources of your machine. so in this case it would consume a lot of resources of api gateway in order to do that parallelism: wait for the response, merge the result and send it back. and especially with respect to parallelism, you have limited cores on your machine, so parallelism is always limited by the number of cores that you have, although you may spin thousands of threads, but they would all be in waiting state, they would not be executing. so parallelism is very tricky. it would require a lot of resources on the machine. plus, it would also require programming language support. let's say, if you are writing in python, python does not have threads, or python doesn't have basically parallel threads. it has concurrent threads but it does not have parallel threads because it cannot leverage multiple cores of your machine. so in such cases you it also depends on the kind of language that you choose to implement your composer. if you are going for a managed solution, they would have made the best decision. but if you are writing out on your own, keep that thing in mind. on how would you want to structure it? right now let's talk about a very interesting thing, although the discussion seems purely on the back and back and side of things. but imagine how this adds up to improving the experience, the user experience, of our end users. so, for example, if we did not have a composer in the middle, then what would need to do your client? as in the browser of your user, would need to make calls to three services- order service, payment service and logistics service- to get that information, compile it together and show it in your ui. this is very expensive. expensive not with respect to computation, but expensive with respect to the number of round trips that your client machine has to or the packet has to make from your client machine to server and pack. so here your client would be, have to initiating three api calls to three services separately, wait for the response before it can render the page on its end. now this is very expensive because from your device, which might be thousands of kilometers away from your server, it would take time for the packet to go there, then the server to compute the response and then fly back. it would take time for it to do it. so that's why you would always observe a higher latency when you are making a lot of round trips in your system. and then your client needs to be smart enough to understand the three responses and merge it. so although this looks hey, let me just write three api calls on javascript and that would make a call, but it is not very efficient to do it. plus, it would eat up a lot of data of your end user because you are making three api calls. so users data would be eaten up. so how do we make the end users experience better using composer? so what composer would do? because composer is acting as a single point of entry, the user would make just one request, just one http call from browser to composer. composer in turn would fan out to three different services: get the response, merge them or join them and then send the response. so this way your client only has to make one api call and then composer internally will do fanout, and that is the headache of the composer. the client does not have to think about it. so it's better utilization of your clients data it would give. it would have lower latency as compared to the first approach that we discussed and there is just one round trip so and then your client can be dumped to just understand what the response is and start rendering. it does not have to have the merge logic kind of stuff, right. so this is where we in general, when we talk about systems or we talk about microsoft, we always think back end heavy. but this is a classic case on how a decision made in the back end positively influences the experience on the front-end side, right? so everything is a gigantic interconnected mesh. so whenever you are deciding something, see how it can impact, uh, basic possible things or the peripheral things around it, and okay. so next part. one thing that i want to talk about is, obviously this is not just one level of composition. let's say we have a very complex logic in our system and we just simply said, hey, the composer's address will talk to order service, member and service and larger six servers to get that information. but what if order service itself needs to talk to seller and inventory service to get its information? so here this is multi-level api composition. the idea is, let's say, your composer sends a request to order service, but order service would need to talk to seller service and inventory service to get the order details. could be possible, right? so that's where you would see in a gigantic system, maybe a 10 year old or 15 year old e-commerce would. you would see this kind of pattern where composer is not directly talking to all of the servers. it's talking to you, that it needs to, but that service might need to talk to few other services to get it information. obviously not very performant or not good for low latency application, but you get the risk that you might have to have multi-level api composition, something that i would not want to discard right. so multi-level api composition is a fact and we have to typically live with it, that in some cases, when our architecture evolves or when our product evolves, we might see multi-level composition. right now, let's talk about advantages of api composition. now this is where things start to become very interesting. so advantages of api composition. first of all, we'll start with simple, super simple to implement. we all see like, just add one api gateway. it would take care of uh, fanning out, uh and basically gathering all the responses, joining them and send it back right. pretty straight forward to implement. second, user as a single point to interact. so because this is the first point of entry, or the single point to interact, user only has to make one api call. it will internally fan out. so pretty solid, single point of interact, no smartness needed on the client side. third, it hides the implementation detail and complexity. so you, your user, made a request to your composer. it does not need to know internally it is making call to 5 services, 10 services, 15 services, 0 services. it does not need to know. it hides and abstracts out the implementation detail. otherwise what your user would have had to do is it would have to call. it would have to know. i had to call order service, payment services and logistics service. now it does not need to know. everything is hidden behind the composer. so user makes a call to composer, composer has those details. who should it talk to and get the response from, and then it would do the need for right. fourth is security and limiting. because we have a single point of contact for our users. so this is where, or on the composer side, or on the gateway side, we can implement security, limiting, caching and whatnot. right. so this becomes our first line of defense. so every single thing around logging, security, practic, basically logging, security practices, monitoring, uh, what, not everything could be applied on this composer site. this way, what happens is, if we secure one, everything else is secured right. so that that's that's pretty neat way of ensuring your complete infrastructure security, right. so that's why composer is again a very famous pattern to be implemented, because it makes life so simple for the internal teams. next is it can cover bad design decisions and wrap them with a new interface. this is classic case. let's say, you had a very tight deadline, very tight deadline, and you just like, randomly sent any response or any structured response without putting in a lot of thought into: uh, how are you structuring your response from one of your microsoft strings, let's say your, let's say your payments, micro services, right, the response is not ideal, uh, not very good for your client. but then what happened is: you made that bad design decision and now something needs to change. you have to restructure your response because your front-end team is saying, hey, we, we can't work with this kind of response. we want a little simpler response so that it's easy for us to render the interface. now your bad design decision cannot percolate to your front-end. so now what you do? because you have a composer sitting in between, you can alter the response there. you can restructure the response in your composer. very commonly seen in high growth startups, you would see a lot of hacks being applied at your composer level and that's how you hide your bad design decisions and wrap them with a very new, shiny interface. and the final thing, the most interesting application of this is: say, you are trying to move out of monolith and breaking it into micro services. this is where composer plays a very important role. so now, because composer is great at hiding the implementation detail, say we have this monolith that we had, which is a legacy monolith, and the first service you would want to fork out is payment service. so what we'll do is we'll put a composer in between, forward any request that comes to slash payment to payment service and every other request goes to legacy microservices, to- sorry, to- basically legacy monolith. this way your user doesn't need to know that, hey, there is a separate payment service or there is a separate monolith service and you can slowly keep forking out your monolith com or your monolith modules into separate microservices without impacting anything on the user side, but just by adding a layer of abstraction sitting in between. so this is a very common pattern that you will observe whenever you are planning to move from monolith to microservices, or hiding out or abstracting out the complexities of transition. very solid, uh use case for that. okay, now the final part. let's talk about disadvantage. obviously, again, as i always say, grass is not always green. let's talk about disadvantages of api composition. first one: our composition or our composer is uh, is basically firing a lot of request onto services, getting the response, merging them. what if? what if? the responses that it is getting from the services is huge, huge. for example- hear me out- let's say we are having a blogging application and we have a blog service. we have a comment service and let's say we have a clap service. so for a particular block, the block service would have the entire blog page, block details, everything that it would need for a particular blog. then the comments is part of a separate service because it requires special kind of scaling. so comment is part of a separate service that we have and clap service. now let's say you want to fetch 10 blogs of a user and you want to render all of them with the body everything. now this is a case that would be very heavy because it requires a heavy amount of data transfer. you'll say: array it, just blog. how, how long would it take? or how big the data would be? imagine every block is 2000 words. right, these are essays. like blogs is still small enough. these are gigantic essays that folks have written. imagine wikipedia pages so dense in information, right? so imagine these are all wikipedia pages. now what would happen? you get wikipedia pages, a lot of comments on those pages and claps that have been made there, and you gather all of that information. it might even go to half a mb size at api gateway. so api, and because what happens? you send a request, you get a response. everything is happening in memory. your api gateways. memory will be full very soon and it will start to choke and it might even crash when you, when it runs out of memory. so that's where, when you are transferring large amount of data or when you are merging large amount of data, you have to ensure that your api gateway is scaled enough and if it you that who you have written, or if it is you who has who has written composer, you have to ensure that it is well written and, uh, basically at best, efficient, right. but if you are doing large or if you are joining large data set, this is very expensive. second is your overall availability is challenge. here we can very clearly see that when the request comes to our composer and it goes to three of the downstream services, like blocks, commands and claps, what we know is our availability is challenge. if one of those services down, we are not able to compile the response right. so, even though your comments and your clap service never saw any outage, but if a block service is down right, your user, your end user, is not getting the correct response or your end user is not even getting the response right. so that's where, unknowingly, downtime of one service had an impact on your end user, which impacted the overall availability of your system. plus, what would happen is, as you have large number of services that you are talking to from your composer layer. your composer needs to manage and maintain a lot of state- who or which services, where and how, and how to connect to that and how to get the re uh, how to send the request and get the results and what not. if you have large number of services there, or if you're talking to large number of services in one request, it would add up to a lot of load on to your api gateway, which might turn it into a gigantic bottleneck which you can't get rid of. so whenever you are adding which looks like a single point- it is not a single point of it, but it looks like a a potential bottleneck- we always vary of the fact that availability will be at stake. not that big of a challenge, given that we have managed services, but still something to always think about when you are designing an architecture. next is when your, your user- is sending request to one, let's say, api gateway and it is forwarding request to three services. what you cannot get, or what you it is extremely difficult to get, is transactional data consistency. for example, you are storing some information and you want that the information is stored in blogs, comments and claps, all the three places or none. so doing that all or none across services is challenging. that's where you need distributed transaction. i already have a video on how to implement distributed transaction. i'll just link it in the i cards. uh, go through that. go through that. if you don't know how to implement disciple transaction, it would really uh help you understand like it's not just theoretical, practically we also do it. so, coming back to this use case, that if you need a strong data consistency or if you need rather transactional data consistency, it is very hard to get it when you have multiple micro services behind uh, an api gateway, to get that information right because your api get, we need to maintain or have to do the transactional part. it's very hard to do it at scale, so be very of that fact. next is composer needs to be managed, maintained. we added one more component in our uh system, which is your composer or api gateway, needs to be managed, maintained, observed, alerted and what not adds up to that part. even if it is a managed service, you would still need to monitor it just to ensure that if it goes down, you know the backup plan for that and the final thing is your composer may become a bottleneck again. not a single point of failure, but a bottleneck. so if you are getting a large amount of request coming to your composer, your composer might choke, because we saw that if you choose uh, parallel, uh invocation, it might add up to or it would require a lot of, a lot more machine resources to compute that information and, in general, handling a lot of search onto your single composer. maybe a few set of machines might be a little taxing, so it has a potential of becoming a bottleneck. so that's where have the right set of alerting and monitoring. place on that one component so that you ensure that you are not in the blind spot. you would know if something would go wrong. you can mitigate it before it goes bad. right, something to always think about, nice. so, yeah, that's it. that's it from me for this one. it's: look, it definitely looked like a very simple topic- api come with them- but it had a lot of intricate details to it. so i hope i added value. if you guys like this video, give this video a thumbs up. if you guys like the channel, give this channel a sub. i post three in-depth engineering videos every week and i'll see in the next one. thanks again. [Music]. [Music] you.