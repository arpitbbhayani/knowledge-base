so micro services are great, but should we be adopting it just because everyone else has been doing it?
in this video, i'll walk you through on what are micro services, what are the key advantages of being in a micro services based architecture, and understand how can we fence a particular micro service?
microservices are small, autonomous and harmonic subsystems.
like you have a massive product- let's say an instagram or a facebook- that product is broken into sub problems and each problem is then handled by a particular microservice and that service is designed in a very optimal way to solve that problem.
for example, a very standard break of a big product, like, let's say, amazon, flipkart, microsoft, google and whatnot, is typically like: let's say, you break it into an authentication service, a search service, an order service, a delivery service and a payment service, right?
so each of this service is specialized in solving that one problem.
from an outside view, it looks like one big company.
it looks like one big product that that is serving you, like, for example, twitter, but within that there are a lot of micro services that are interacted on a regular basis to get your things done- for example, the recommendation service to render your feed, or an authentication service to drive authentication right- but each one of them has this very small, peculiar, uh, set of properties and a set of problem that it solves, and it solves them really well, so, optimally.
when they all come together, the entire problem is solved in the most optimal way, right?
so that is a key idea behind microservices: to give each one of them a very specific set of responsibilities and ensure that it solves it very well, right, but why?
why should we adopt or why should we go for micro services space architecture?
so one major reason that why companies adopt micro services is because, like, when a company starts it, it starts from a pure idea.
then someone, like one or two engineer, quickly prototypes it and then, and then a small mvp is created for which someone is willing to pay for it, and then it becomes a full fledged product.
and once it starts to add more features to the product, what happens is your code base grows over time.
when your code base grows over time and now, because there are lots of features, there will be lots of teams, lots of teams.
so so that's where the problem lies, where having to have so many people coordinate over one code base, just imagine how many merge conflicts would we get, how many deployment issues, like some team broke or added or or introduced some bug into a code and everyone else is suffering from it.
or, let's say, with respect to deployment, it will become a major choke point where, where one team is ready to ship while other is not, so the entire pipeline is blocked because it's just one.
so when a company grows over time, when the team grows over time, this when you just have one monolith to solve and you don't have micro services, it would reduce your overall product development velocity right, plus add so many blockers and what not into the scheme of things.
the second key reason is scaling becomes predictable now if you have just one code base or one monolith to solve that problem.
if you would want to scale something, that entire monolith is scaled right, and once your code base grows beyond a certain limit, the amount of ram it requires to run that one process is huge- might not be the best way.
so instead what we do is when we break it into micro services.
for example, search might be on 10 instances because it's a very computation heavy process, or or it's a very heavy with respect to finding out relevance and talking to other microservices and all.
authentication, because it is invoked on every single api call, would be scaled to, let's say, 20 instances- right.
and then payments not so frequent can work on just three, right.
so every service is independently skilled without having to know on what the overall scale is right.
and because of this particular like everyone is working in its own space, you get autonomous and isolation.
so your, like, your service becomes auto numbers or your team become autonomous and you get very nice isolation.
like a particular service needs a very high concurrency at a very low latency or or very low a memory footprint or an overhead.
so service might adopt golang using a mysql database, while other services- hey, i am, i, i have a traditional thing, or, and, and my team has expertise in java, let me build it in java, but i want to use mongodb with it, right, because that use case is more suited for a nosql based database.
so here, because of the autonomous nature of microservices, every service gets to decide its own tech stack.
so service a and service b would agree on a contract that hey, like, for example, services says, hey, i only understand http.
so service b, if you want to talk to me, talk in http with me, right.
otherwise, in a modern stack where this might say, hey, that where the service b says, hey, i only know tcp, so createtcp connections and talk to me, right?
so depending on what kind of problem a particular service is solving, it can expose the corresponding set of contracts for other service to consume the data.
so every service is is autonomous and it's uh is is basically autonomous and k and can take decisions on their own for the kind of uh api contracts that they would want to adhere to right and you can change your code wherever you want and deploy whenever you want, like with microsoft, with just monolith, having just one code base to rule them or having just one service to rule them all.
they want to ship it, but team build cannot ship because they have their changes partially merged into the main branch and they cannot ship it.
but here, with microservices, each service can deploy on its own time, at its own convenience.
that's a best advantage because it overall it improves the overall development velocity of your team.
this is one of the key reasons why microservices work really well, where, if a particular service is down, the entire product is not done right.
for example, if let's say, this is payment service and this is search service, so service a is a payment service, service b is a search service if search service is down, only that search bar of that website is not working, but everything else is actually functional.
so with micro services based architecture, the key advantage you get is, even in case of an outage of a service, you might still have a partially working product, which means that the overall experience of your end user is not drastically- uh, it basically does not drastically degrade.
then the final and and a really interesting reason why microservices is because your upgrades become simpler, like, for example, with time, new technologies come in, new frameworks come in, new database come in and whatnot.
so what you or your team might want to do is they would might want to evolve the service.
and, and when they would want to evolve the service, they might want to change the tech stack, be it a better language, be it a better database, be it a better infrastructure.
and in order to do this seamlessly, what happens is because each service is autonomous in itself, they can upgrade transparently so long as they are adhering to the same api contracts.
so a service can move from java to golang without any other service getting to know about it, so long as they expose the same set of api contracts that were exposed in java, in golem.
so that is a key advantage where every service can now evolve independently.
hey, today i made a decision: mysql was the best database for me, but now, because mongodb is there, let me just use mongodb for that, right.
so they might want to change the database without having others team even affected.
so these are the main key reasons why people adopt, or why companies adopt, micro services, or why, in general, if you would want to adopt, why you should be adopting micro services.
right, and coming to the final part of it, how do we define or how do we fence a micro service?
like, we know that micro services needs to be small, but small is a very subjective term.
but how, how can we fence a micro service such that it, it, it's, it's better for the it's, it's better for the overall velocity of a team or of a company?
you also need to know when should i break things into micro services like what is that one fence of a micro service, so the services when you are breaking it or when you are fencing it?
it cannot be too big, because if it is too big it is the problem is same as the monolith right because you have multiple teams coordinating on it and that, and then the same set of problem comment, but just at a smaller scale.
a problem would be there, you, it cannot be too small, otherwise there would be so many inter team or inter service dependency, like internet.
and secondly, if each one of that sub component is handled by separating, then inter team dependencies very, very, very messy.
so a good start to breaking things into micro service is go feature wise, so a feature.
so typically the way your organization is structured, right, so there would be teams that that would be looking at a specific set of uh features.
so, for example there, like if, if we were to build- uh- let's say, if you were to were to build, uh, something like a netflix or or maybe an amazon prime, right?
so you might have one team taking care of live streaming.
you might have one team taking care of authentication.
you might have one team taking care of payments, right.
so there will be a live streaming microservice, an authentication, a payments, a notification and delivery- right.
so each one of them has its own set of responsibilities, one team to look after it and, obviously, as you grow bigger and larger, each one of them will break into a set of microservices.
for example, someone just takes off prepayment flow, a team takes care of post payment flow, so then those two become to separate micro services, right?
so a good indicator of that is the way your organization or the team is structured, depending on which you would want to break your things into micro services.
in overall, improving your development velocity, right, and as an engineer, when you are starting to build or to break your monolith into micro services, this is a very solid way to do to go about it right.
you can call them micro services, but overall, in a bigger picture, notification becomes your big micro service and then you might have smaller components that are again between them.
they are working harmonically, right.
so, approaching it, fencing a micro service, is purely subjective and it is always designed so to optimize your overall development cycle, right.
that is the key reason on why you would w, why you broke your monolith into microsoft in the first place.
but a good head start, good- is going feature-wise, right, amazing.
i hope you learned something new about micro services.