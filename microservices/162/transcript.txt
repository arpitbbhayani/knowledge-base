so as your application evolves supporting multiple types of clients like desktop mobile apps etc becomes very tricky the backend becomes complicated and you start applying a lot of hacks to serve them properly in this video we take a look at an interesting high level architectural pattern used in microservices that solves this exact problem and the pattern is called back end for front end fondly called as bff we would see in detail what this pattern is all about where it is actually used how to implement it look at its advantages and disadvantages and conclude by building an understanding of when should we actually start using it but before we move forward i'd like to talk to you about a course on system design that i have been running for over a year now the course is a cohort based course which means i won't be rambling a solution and it will not be a monologue instead a small focused group of 50 60 engineers every cohort will be brainstorming systems and designing it together this way we build a solid system and learn from each other's experiences the course to date is enrolled by 600 plus engineers spanning 9 cohorts and 10 countries engineers from companies like google microsoft github slack facebook tesla yelp flipkart dream 11 and many many many more have taken this course and have some wonderful things to say the coolest part about the course is the depth we go into and the breadth we cover we cover topics ranging from real-time text communication for slack to designing our own toy load balancer to quick buzzes live text commentary to doing impressions counting at scale for any advertisement business in all we would cover roughly 28 questions and the detailed curriculum split week by week can be found on the course page which is linked in the description down below so if you're looking to learn system design from the first principles you will love this course i have two offerings for you the first one is the live cohort discourse which you see on the left side and the second one is the recorded course which you can see on the right side the live cover based course happens every two months and it will go on for eight weeks while the recorded course contains the recordings from one of the past cohorts as is if you are in a hurry and want to binge learn system design i would highly recommend you going for the recorded one otherwise the live code is where you can participate and discuss things live with me and the entire cohort and amplify your learnings the decision is totally up to you the course details prerequisites testimonials can be found on the course page at pitmany dot me slash master class and i would highly recommend you to check that out i put the link of the course in the description down below so if you're interested to learn system design go for it check out the link in the description down below and i hope to see you in my next cohort thanks so say you have a monolith that serves all the apis that your clients ever need and that api you expose it through your favorite web server and what you support right now your support only one type of client a desktop web interface is what you're supporting so given that uh as your current situation your your typical three-tier architecture would look something like this you would have your users which are talking to your monolithic apis which are then uh which in turn fires the query together to the database gets the response and sends it back to the user a very standard three-tier architecture that you will have right and to take more concrete example let's say you are building an e-commerce app right and in this e-commerce app what you need is you have an api that sends product details so on the web page what you are displaying you are displaying the detail about the entire product so that person if he or she would want to purchase click on that button makes the purchase but to make that informed decision you sent all the details all the details might include the name of the product the description about the product this different sellers that are selling that product so that you can render the drop down variants of a product for example if you're selling a t-shirt red blue black green violet purple and what not so those variants you might want to store faq use a bunch of faqs are there that you render it on the web page you might also want to render that and reviews let's say the product has uh 1000 reviews you might pick top 50 and you would want to render it so that it make helps people make very informed decision if they would want to purchase a product or not now what you might do is you might expose an endpoint that looks something like this slash v1 slash product slash product id firing a get request on this would give you this entire detail right so all of this is what you are sending in in one api response because when you do this in one api like you might think hey let me fetch reviews separately let me fetch faq separately let me fetch something else separately when you do this the problem that would happen is your client would have to make a lot of network calls you don't want that to happen so what you'll do you'll expose a single api you'll expose a single api which makes an http request internally it may do whatever it wants to do because it's a monolith it goes to one place gets the detail and sends it back if it was micro services it would have made multiple calls to multiple uh microservice get the details and send it back to the user irrespective for your client it is just one request which is exposed from this uh monolith or from your front facing proxy that you have now when that happens every single thing that the page required you are exposing it on that end point which is get slash v1 slash product slash product id now this is very straightforward to do it because you're only supporting one client now what if you foray into mobile what if now you are also having a mobile application so mobile application might look uh your mobile application has a critical thing to note here your mobile application has a very limited real estate like your screen size is small you have very small place to show all the information that you would want to show so on your desktop web there is a lot of real estate you can render a lot of information which is seemingly non-critical but you have space so you would render it you might want your page to look filled right so when you foray into mobile you have now two types of clients to support your desktop web and your mobile app right both of them if they invoke the same product endpoint get slash v1 slash product slash product id and it both of them would get the same set of information but if you think about it the information that we sent to desktop web was okay for us to render the entire page but on mobile screen you don't have that space to render that stuff so that is where let's say you might want to skip all the reviews you don't want to show them because you might have a button show reviews clicking on which might take you to a different screen and on that you might want to render the reviews right similarly faqs can also go to the next screen so that what you show in the front face on the front viewport that you get it should be the most critical information that you have you would show the user the most essential most critical information that he or she needs to make the product decision a lot of things might be non-critical per se so you should be moving that to a different screen right so because that you are not rendering that information in the first viewport why do you even send it in the api response so what would happen with that is if this if you are using the same endpoint that you used for desktop web and your mobile app you are sending a lot of extra information with it for example because you decided that you will show reviews on the next screen you will choose faq on the next screen uh so why do you want to even send that right so if we just want to ensure the great user experience with very low network bandwidth being consumed and being very efficient on your mobile device you should be sending only the data that your mobile is definitely going to use to render the screen this would help you save network bandwidth processing power of your mobile battery of your mobile uh memory and whatnot plus it would load your page very quickly because now there is a very small amount of data that your mobile needs to process and render so it's very efficient so that is where to give a great user experience you might want to have different set of responses depending on different types of client that are coming in a very and just to extend this problem it's not just limited to mobile apps this problem like for example you have a desktop app your mobile app but now let's say you would want to create an alexa plugin and you can do that if you want to have an alexa plugin the kind of responses alexa would need is very different the format in which it would need is very different it is not the stream format like the json that you resent in the response of product details is not how alexa would understand what to communicate it would have its own format in which it would be expecting the result right so different types of clients might have different types of requirements a very nice way of implementing this would be hey in my api request or in my uh exposed endpoint let me accept query parameters or which says that hey question mark platform is equal to web platform is equal to app platform is equal to alexa for example if you are doing that you are adding so much of ifs analysis and so much of complication in your back end unnecessarily right so is there a better way to solve it a better way to solve it is through a pattern called back and forth front end what back and forth front end does is it creates like it keeps your monolith as is you don't have to apply any hex on monolith keeper monolith as is what it would do is imagine your monolith is very generic it gives you it every time gives you all the information that you ever need without anything being filtered out the filtering happens at your bff layer your backend for front-end layer the idea for this is your desktop apis your uh your uh desktop clients your desktop web would invoke apis that would go to desktop bff desktop bff would then talk to monolith monolith then then talks to db get the data sent to the bff and bff forward set to the desktop client similarly request from your mobile devices would go to mobile bff mobile bff goes to monolith monolith goes to database gets the response sends to bff and which is then sent to user at this layer at this bff layer what you change you don't apply any logic the bff is simply going to be the presentation layer for example whatever information it got from the monolith or from the backend apis it would filter out the things that it does not need to send to the corresponding type of client so desktop bff or mobile bf4 in general your bff service would only take care of the presentation part of it that hey what i need to send what i don't need to send if i'd want to make something extra call it to some another back-end micro service to get some information it will only take care of the presentation layer it would not have any business logic not at all right so this is the advantage or this is what the bff pattern is all about it sits between your core back-end system and your client acts as a proxy for a corresponding type of client and all the presentation hacks go there right they're very similar to api gateway the api composition pattern that we saw earlier it's very similar to that and each bff you can consider each bff as your api gateway right so multiple bff is equal to multiple api gateways that you have one for each type of client so one now what would happen is instead of having a single point of entry into a system earlier what used to happen your client used to directly call monolith monolith used to call dbn done but now you have multiple points of entries for each type of client they are talking to each of the uh bff and bff is internally making calls to other services right so bff does a lot of fancy things so it needs to know like every single bff decides given an api request that is coming to it what it needs to fetch how it needs to fetch and what it needs to send in the response it needs to have all of these three configurations in it but if you look at it all of these three are purely presentational they are not business logic they are just presentational on what it needs to fetch how it needs to fetch and what it needs to send in the response purely presentational uh it purely works on the presentation layer of your data right might match extra information here or there but that is not a business logic that is just that is still a presentation logic so here your mobile bff would have a very big job it let's say you are fetching a product detail your request goes to your request from your mobile app goes to mobile bff mobile bff talks to monolith gets this gigantic response and then decides to drop reviews faqs and other stuff that it does not want to send to the mobile right so that's where bff comes in handy but now you will have one question oh but why are we even fetching the data from the back end if we are eventually going to drop it we are keeping our back ends very generic plus with this being so generic it's very easy to cache it's very easy to cache your entire response other than saying if this is there then cache this if this parameter is that then cache this entire response it's very simple to keep your back ends very generic while having a bff layer that takes care of the presentation depending on the client okay up until now we looked at uh the back end being a monolith this also works very well if your backend is micro services so for example in the same e-commerce application you might not have a monolith you would have a bunch of micro services right i'll give a very nice example here again so you have a desktop app oh sorry you have a desktop web and a mobile app right now in microservices architecture what you have is you have your product detail service which gives you the detail of a product you have a seller service that gives you seller information you have a review service that gives you the top reviews for a particular product and then you have augmented reality experience right now what you need to do is the request from your back request from your desktop web comes to a desktop bff in order for desktop bff to gather that information that needs to be rendered it would have to talk to your product detail service seller service and review service to grab all the information and send it out to the user right when the request comes from your mobile app goes to mobile bff it would fetch product detail seller detail it does not need to fetch review service it doesn't have to talk to review service because it is on the next screen so only product details there are detail but mobile because it is accelerometer it can or it has ar support you can talk to ar service and get the net necessary information so that you can literally place the object that you are buying let's say you are buying a chair it would give you that sense that a chair is right here through the lens of your camera right so ar experience might not be suitable for desktop web but would be very suitable for mobile so this is an advantage that we get this who to talk to only the logic only has to be with the corresponding bff layer right so that's why it fits very beautiful in the micro services space architecture now let's take a look at advantages of bff service or of a bff layer first of all it gives you support for multiple isolated interfaces so the idea here is your desktop player does not need to know your mobile layer it gives you ability to support uh multiple isolated interfaces that does not interfere with each other at all right your client specific tweaks are much faster to push like for example if tomorrow your android team says or the mobile team says hey we also need this information it is very easy you don't need to change more your monolith or your backend services they can send the same set of response that it was sending to any anyone and everyone on your bff layer you can tweak that thing now also send this information or also stop sending this information those tweaks are much much faster third is hiding sensitive information for example you might not want to send a particular sensitive information due to any like your back end is generating that but you would want to filter it out on your bff layer you can do that your back end is not directly exposed to your end user so now you can filter out the things that you don't need hide sensitive information then picking the right stack for their protocols for a client and it's not just for client but even for backend because you have a bff layer sitting in between let's say you have a client that you have a legacy client that only understands xml but your backend is sending response in json your bff layer can do the transformation because for a particular type of client it only understands xml so i'll take json convert it into xml and send it back to the client right then you might also pick the best network stack tcp udp websocket grpc http one http 2 whatever you would want to do you can pick that depending on what works the best for the client your back end can remain as is right also this also applies on bff to microservices layer so when bff interacts with the backend services you can pick the best protocol out there for example you can use a very crude grpc from because bff is also server in your infrastructure microservices also server in your infrastructure that could be very lightning first communication with the best most complicated protocol that you could think of that gives you the best performance out there your user does not like for example your client would not know what grpc is you're like your desktop browser would not know grpc is bff because it's a server bff to microsoft communication can happen over grpc right big advantage that you will get next advantage is improved security now earlier we talked about hiding sensitive information but this is about improved security for example depending on the types of clients that you have different types of attacks are possible for example the attacks that are possible through mobile device are very different from attacks that are possible through web interface right so depending on the client that you have you might want to apply the corresponding checks onto your bff layer and that makes it very easy you don't have to apply all the checks at all the layers right you can apply very specific client or very client specific security checks at your corresponding bff layer ensuring that no that no information is preached or no user uh is at stake next is you need a single you need a single general purpose backend for everything and bff can take care of a customization this is a very big advantage very big advantage because now your backend the core backend that you have can send all the information is very generic in nature now anyone who needs any specific details or does not need any specific drill can just filter out at the bff layer this is very very beautiful optimization because this would ensure your back end it makes a life for back end very simple caching of your responses on back end very simple because it's not doing filter outs filter outs is happening at bff layer so your back ends are very performant on the caching side the final advantage that we take a look at is bff can also act as a request aggregator because bff is sitting in between and let's say you have multiple microservices your client does not have to talk to individual microservice to get the information it can just make one api call to bff bff can act as an aggregator similar to how api gateways are same thing because bff are like api gateways request comes to bff bff fans it out gets the response gathers it and sends it back right so bff can also act as a request aggregator making your clients very lightweight just one api call from them we are finding out a lot of calls internally right solid solid solid advantages that you get by using uh bff pad but obviously grass is not always green there are disadvantages the first disadvantage is fan out although that work that i just talked about as an advantage of bff it also falls as a disadvantage of bff because now if we think about bff doing the fan out with it is very network heavy process right so bff might become very bloated over time where it has to talk to a lot of services doing a lot of things and every call that it makes to a micro service is a network call very expensive in nature so you would have to provision your bff in such a way that it could support large number of concurrent network calls second the language that you would pick or the text that you would pick for bff has to be very proper for example you should not be using python to create your bff because you would want concurrency you would want ability to fire multiple network calls like when i'm talking about python python 2.7 python 3 with asynchro you can still use so your tech stack has to be very limited which supports multiple concurrent network calls efficiently that's what you would want to use right so that is a not desired but a challenge that you need to ensure like you should be using this second is code duplication you could see that mobile desktop multiple types of client they would be interacting with similar set of services just skipping a few here or there so most of the code across your bffs for different client would be very similar so there is a risk of code there will be code duplication so now if you change a logic at one place you have to ensure that all the bffs get those changes so might be a little tricky over time when your bff code becomes complicated where you would have to do dip or changing in one might you might need to roll out changes for all the bffs out there next is you are adding more moving parts in your infrastructure now with this new bff layer sitting in between there is this new component that needs to be managed maintained monitored and deployed again a big pain point with large set of infrastructure large number of services you would have to ensure that all of these things are managed maintained monitored and deployed because you cannot have blind spots in your system might lead to a big outage and with this proxy layer with this bff electricity in between it would increase our latency slightly because you are making a call to one service that internally makes call to multiple services to get the data and send it back adding that one extra network hawk network hop but it's fine because the advantages that you get out of this are immense but just to be very that adding one network hop might not be the best decision if you are building something like a very super low latency application if it's a normal rest based user web 2 use case like e-commerce and all it's still okay but if you are building something very uh if you're building something very low latency uh this might not be the best decision that you will take right so to conclude when should we introduce bff although it sounds super interesting to have pff but two specific cases when it would it should prompt you to think this is the place where i should use bff first when the interface are slightly different across clients for example where you have your where your interface for your web is very different from your interface in your mobile app like you are rendering 50 things over here but only 10 things over here it varies very huge like so the variation is huge when the variation is huge that is a prompt point key can i use bff over this because then you are unnecessarily fetching all the details from the back and sending it to your mobile device basically consuming the mobile data of your user draining his or her battery very poor user experience don't do that this is a trigger point where you might think hey can i use bff over here because your interface varies very slightly your interface varies hugely because there is a huge variation you should be using bff in this case second is when your communication format of a client is very different for example if you have a legacy integration or a very specific integration which only expects you to send a data in a particular format i gave an example of alexa that's that's a very good example for this use case like you'd want to send the product details or you would want to share send the details on what's the shipping status of a product alexa might expect it in a certain format so that it can utter those voices or order that sound and basically tells you about it right it might expect response in a particular format but you cannot change your backend and say if alexa written this format that is a very poor implementation keep your backend generic have a layer for alexa to say that hey when the request comes to excel it goes to back and fetches the generic information transforms it into the format that alex understands and sends it out right similarly for supporting mobile device it would go to the backend service get the information transform it or basically filter out the things that it doesn't need and send it to the mobile another use case is let's say you have an you have a legacy uh integration or let's say you're integrating you have a very nice robust backend and you want to integrate it with a bank right where you might want to directly talk to the bank and accept payments and whatnot but that bank is built in a very legacy system it understands the information in a particular format let's say xml hypothetical example let's say your bank understands xml but every other client that you have your mobile app your desktop app everything understands json so what you can have you can have just one layer of bff that is specifically for xml so you have a monolith you have your user monolith exposes json endpoints client all other types of clients understand json they directly talk to monolith and problem solve but your specific banking client understands xml so you would add an xml uh backend for front end in between so client with that understands xml talks to xml bff xml bff talks to monolith it gets the data from the database sends it into the bff it does the transformation of json to xml and adding or basically enriching the information or filtering out the information and sending it back to the xml client so this way you can now support multiple types of plan that understands totally different formats through a very simple and elegant solution called bff and yeah this is all about back and forth front ends this is a very interesting pattern where you saw its advantage you saw how useful it can be uh in order to power a very good user experience so yeah that's it that's it for this video i hope you learned something new if you guys like this video give this video a massive thumbs up if you guys like the channel give this channel a sub i post three in-depth engineering videos every week and i'll see in the next one thanks [Music] you