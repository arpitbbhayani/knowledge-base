so an engineer working on microservices should not only just focus on engineering things there are so many other aspects to look at that holds a potential to create massive impact for the organization to be honest building micro services is much more than an engineering problem to solve there are many pitfalls to avoid and decisions to be made and in the process build a solid functional high performing team in this video we'll look at some engineering and non-engineering things to remember while building microservices for example it being a massive massive massive opportunity for personal growth everyone should be okay with architectural evolution importance of periodically addressing technical debt and striking the right balance to keep engineering and business aligned to the same strategy goals but before we move forward i'd like to talk to you about a course on system design that i have been running for over a year now the course is a cohort based course which means i won't be rambling a solution and it will not be a monologue instead a small focused group of 50 60 engineers every cohort will be brainstorming systems and designing it together this way we build a solid system and learn from each other's experiences the course to date is enrolled by 600 plus engineers spending 9 cohorts and 10 countries engineers from companies like google microsoft github slack facebook tesla yelp flipkart dream 11 and many many many more have taken this course and have some wonderful things to say the coolest part about the course is the depth we go into and the breath we cover we cover topics ranging from real-time text communication for slack to designing our own toy load balancer to quick buzzes live text commentary to doing impressions counting at scale for any advertisement business in all we would cover roughly 28 questions and the detailed curriculum uh split week by week can be found on the course page which is linked in the description down below so if you're looking to learn system design from the first principles you will love this course i have two offerings for you the first one is the live cohort business which you see on the left side and the second one is the recorded course which you can see on the right side the live cover based course happens every two months and it will go on for eight weeks while the recorded course contains the recordings from one of the past cohorts as is if you are in a hurry and want to binge learn system design i would highly recommend you going for the recorded one otherwise the live court is where you can participate and discuss things live with me and the entire cohort and amplify your learnings the decision is totally up to you the course details prerequisites testimonials can be found on the course page arpitbihari dot me slash masterclass and i would highly recommend you to check that out i put the link of uh the course in the description down below so if you are interested to learn system design go for it check out the link in the description down below and i hope to see you in my next cohort thanks first key thing to remember while building micro services that it is a huge huge huge opportunity for growth right so when we have micro services based architecture or we are transitioning into microservices based architecture what it gives us is we are creating a lot of services which are very focused right which means there would be lot of engineers lot of teams lot of technologies to work with lot of interactions to happen between services so this is a clear short opportunity for any engineer or for any leader to step up to step up and earn some brownie points for example there is a technical problem to solve how two services should communicate to each other you as an engineer can step up and propose that hey why can't we use grpc why are we using rest right so this is that one place where you can get personal growth not just with respect to engineering practices but also with respect to leadership points right with respect to you owning up those things and leading it into it right this is a very very very good opportunity for you to showcase your leadership skills showcase very strong ownership very strong accountability attention to detail and overall leadership qualities this is something that would make you an asset for an organization right apart from all of these non-engineering things that we discussed with respect to engineering side when we are going from monolith to micro services what would happen is the problems are many right inter-service communication loosely coupling system high cohesion that you would want to ensure how would you split this service into two introducing new components into that these are all architectural decisions that you would have to take so as an engineer if you are stepping up to this challenge you would have a very very very solid growth trajectory in the organization right and obviously there are so many so many tools and technologies and frameworks and what not to learn right so always remember when you are in the microservices based architecture you are adopting them or you are into the transition this is a massive massive massive opportunity for growth where you can have a cross organization or rather across team influence right you can come out as a subject matter expert for this particular thing second thing to remember is conflicts are inevitable okay when you have a micro services based architecture each team owning a few set of services and let's say those two services needs to interact right conflicts are bound to happen someone would say hey this is how it should be built someone would say no this is not how it should be built there would be so many agreements disagreements in some cases fights also because engineers are very passionate about it and they are inevitable right this is where and you should always remember that there is no one right way to build any system any and every system can be built in hundreds of different ways right and it's just that you have to be good at making that trade-off that hey this one is better for this situation while the other one was better for that other situation right it's very subjective but you have to be like you have to understand that your way is not the only way through which this system can be built others approach might also be correct right so that's where the decisions that you are taking should be in most cases data-driven informed decision if you do not have data to back please step back right or if you are very sure about it your approach is the correct approach bring in the data bring in the necessary stats and pitch your solution up right in most cases if you are an early engineer consult your senior engineer so if you two engineers in the same team are having this disagreement bring in your senior engineers into the picture let him or her be the referee in the fight right he or basically that senior engineer would be helping you solve that issue and while doing that watch and learn watch and learn how senior engineers tackle such ambiguous situation there's so much to learn from them right always keep one eye on the scenery general how he or she is doing his day-to-day work and you so much to learn third it's okay it's okay to go along with something you disagree with for example your teammate proposes an architecture you propose in architecture you don't agree to that architecture it's okay to sometime sometime not always sometime to go along with something you disagree with sometime the overall team's happiness quotient is much more important than an engineering decision right and it's not something that i am promoting but something sometimes it is okay to do it not always but if it is happening too often bring in your managers bring in your senior engineers to resolve that part and this also spans multiple teams for example if you and engineer from other team are having that conflict bring it it's okay to sometimes budge on hey it's okay your approach is great let's move on with it and all and it's okay it happens it happens to every single one of us right and in most cases when could there is some cross-team conflict on how to integrate how to interface how to build let the seniors discuss and converge upon a solution that is the best way to do it let them fight let them discuss let them argue whatever they want to do you take a step back and focus on the implementation part sometimes it's okay to take a step back you can you cannot always be the alpha person in the room right always remember that it's okay in some cases let the seniors handle it at their level and then you would be happy implementing it right in any case observe them how they're dealing with that situation right deciding in a silo is fatal if you are deciding an architecture for a service and for sure if you think that you are the best engineer in the room you are 100 incorrect you cannot always take very optimal decisions it has to be it has to be a team's decision big the brains of others in the team cross team friends peers and whatnot if you are deciding yourself the architecture and building it on your thinking that hey i am the best engineer in the world it's stupid to be really honest it's stupid right you cannot always design the best architecture ever when you pick others brain you would you might uncover some edge cases that you would have not thought of some ex some possible extensions to a survey that you would have not thought of so never decide anything in a cider let it be a team's decision let's involve a few other bit i'm not saying in all the entirety invert two or three engineers right so that you first of all you get an assertion that the design is good second your team even understands that you have designed something good third in case you have missed out on some things right they might their input might help you uncover those some micro pitfalls that you might have left right and that happens right and the most important part is vision will evolve you have to adapt to it today you have product requirements abc tomorrow that same product requirement might change or while you are building that product requirement might change and it would become pqr right when these happens it's okay your code will be script it's perfectly fine that your code is script it's perfectly fine that the architecture is now now it does not exist it's perfectly fine right so there is no reason for you to create a conflict because of this because organization's vision would evolve so you have to adapt to it right for example it's like hey i designed this architecture thinking this scale or this feature for that's why i picked sql database otherwise i would have gone with no sql no it happens it happens your product your architecture your business will evolve right you have seen how a pandemic has shifted a lot of businesses to go digital like they cannot just say hey we were only offline only and now we are going online and what not right or we are using this kind of product and now you are suddenly asking us to build this feature right conflicts are inevitable handle it maturely right next is architectural just simple extension like just extending the last point into this this and basic giving its own space and architecture evolves right so say we decided to use mysql as a primary database but then while building it or after some time your requirements totally changed and this happens this happens a lot right so deviations happen the decisions or the things that you decided on might not be relevant after two months or after three months because your market did not accept the product or there was some fancy requirement that was more essential or more critical than your current setup right so then you have to be ready that whatever decision you made is going to be reverted or you would have to build upon that and and that happens that happens so you have to be aware that architecture is going to evolve and you to the best of your ability needs to design an architecture your microservices needs to be architected in such a way that any change that would happen or that would come in any for any unforeseen uh any unforeseen change that comes in you are able to handle it gracefully right this is where future extensibility this is where uh architectural abstractness come in the way you would be designing needs to be abstract enough so that any changes that might come in does not affect you much right and wherever let's say you are for some reason you would want to change your database from one to another this is a big decision right so this requires consensus again you cannot do it on silo it has to be a combined decision right and in some cases you might also have to prove your seniors that hey are we really going to do this because in some cases people might have not thought it that's where you as an engineer or you as a early leader needs to step in and say hey have we really given a thought on this because if we move from a database to another there is no going back right if you make them aware about these kind of situations they would be putting in twice the amount of thought and coming up with hey yeah we are definitely doing this no matter what and we are okay having this one way route that from database one to move to database two we have we cannot go back right so architecture revolves be ready with it and the next is the most important one technical debt we cannot always build the system the best way possible and it is always that because we engineers or vs engineering teams we are always running a race against time we always have to ship things faster we do not have all the time in the world to design the best architecture possible so that is why you would always see we cut some corners some things we leave out or tk this is not scalable that is okay we'll just push it for now right you make a lot of not a lot of but some definitely some inefficient decisions and although you are making those decisions to ship your things faster for the present what this would lead to is this would lead us to prevent to prevent us shipping things faster in the future so today you are getting very high velocity but tomorrow you would be slowing things down because this when today shipping a feature let's say takes you three days and six months later it might take you one month right and your manager or your senior manager will come in and say why why is it taking too long the answer to that is technical debt right technical debt is a concept which is basically bonging you down because of all the inefficient decisions or not so best decisions that you took just to ship things faster at that moment that is technical debt and this in exist in every single organization out there typically rebranded as backlog right this is very much the reality of entire software industry so if you are piling up a lot of technical debt it would slow you down from shipping things faster or extending your things or building new things at a much slower rate in the future so this is where you have to ensure that you are prioritizing solving of technical debt at least reserving 10 percent of bandwidth every sprint into resolving technical debt otherwise it would slow you down so much that adding a new feature adding new uh feature or supporting your request would take you a very long time and this is not just because of inefficient decisions we took or something to ship things faster but also it might be possible that organization's vision changed in midway because of which the architecture that you had earlier is not so relevant it's not so efficient for you so ideally you should have altered your architecture but you don't have enough time to do it so that's where you hack your solution into existing architecture and solve it so these are couple of reasons because of which technical debt exists but it is very important to solve technical debt periodically right at least without 10 percent of bandwidth every sprint to resolve technical debt so that as a team who are owning a bunch of services you would be moving at a much faster pace in the future next is service templates and enforcing standardization we saw how important uh setting up standard or rather setting up standardized service is important right we saw that and when we say standardization it implies that hey to do inter-service communication you have to use grpc to expose any endpoint you have to use a rest just small examples for that so when we have situations like this when we are enforcing some some sort of standardization that hey you cannot use mongodb in our infra you have to use dynamodb just a small example or for search will only use elasticsearch if you are having these sort of standardizations these are good because it gives us all necessary best practices that our organization is aware of right or people know how to manage them or we or every engineer in the organization is skilled to work on them it has very solid advantages right but what happens is with standardization what you are primarily what you are primarily trying to solve is you are trying to solve avoiding duplicate like avoiding redundant efforts so what you can typically do is if you have a set of standards that you want every engineer to follow every micro service that is spun up to follow you can create a service template for it for example a github repository with a boilerplate code with all necessary extensions or all necessary plugins that it would require right for example you want uh like in that repository in that template repository you would have an uh you would have a small hello world server that exposes grpc for inter service and http for or rest based endpoints for user basic communication it would have hysterics for circuit breaking it would have prometheus for metrics and reduce as a cache already clients integrated now this would make life simple for everyone right so this would avoid duplicate efforts where every engineer who is spinning up on your microservice needs to add those things separately and every team might have a different folder structure that is very bad for an organization that's where creating a service template would really help but enforcing standardization may backfire this is something that everyone should be aware of like every leader every engine should be aware of that hey if an organization is trying to enforce standardization by saying that hey you only have to use java or you only have to use python to build this thing a lot of engineers might feel strangled when this is the case this needs to be solved and how do you solve it two approaches that we could do over here first is by providing proper reasoning for every single decision that we are making that hey why did we pick hysterics for circuit breaking why did we pick grpc for inter-service communication there has to be proper listening for this which can be addressed right there should be an open forum where this is these things are discussed openly that hey why are we not supporting other languages why are you only supporting java and goliath right something around that so this has to be an open discussion which entire team or entire organization comes in collectively or they basically come in in a forum and they try to address this particular situation so that no one feels strangled no one feels that hey they are thrusted upon by some random standard that some random person in the organization created there has to be proper reasoning for every single thing second way to solve this is when you have a central team trying to enforce a standard to all the teams in the organization this would have a negative sentiment so that is where there should never be a central team who is making the changes in the central template and allowing or enforcing it into every other team so this is where it has to be a collective effort so any changes made into a template ideally should be there should be an open forum where anyone who has any problems anyone who is interested in to be part of that should be part of that this way it would not look like an autocratic environment but more of a democratic setup and it is very important to do so so in a microsoft especially in a microservices based architecture this is very important that hey it should not be that hey one team is enforcing all the things on us now what do we do so that's where make it a collective effort right and the final thing that i want to talk about the most most most important part business is more important than engineering this would offend a lot of you engineers but but this is true this is true if business exists then our jobs exist if business doesn't exist we are gone right so that's where whatever we do whatever we do any task we pick any project we pick it has to be aligned to the strategic goal of the business let's say during this economic slowdown you know that a lot of businesses are focusing on profitability imagine your businesses is is focusing on profitability but your machine learning team just giving an example no need to be offered at ml engineers but your ml team is requesting your sre team to provision 50 massive gpu clusters does not go hand in hand right because one place your business is trying to reduce the cost while your mldm is requesting fit okay they might need it but can that project be deprived every single team should know what the strategy of the business is or what the strategic goals of the business is for next couple of months or three months or six months or a year and every single project you pick has to be aligned to that vision if you are not aligning yourself to the business you are not creating outcome you are just running your small hobby project if the work that you do is not aligned to the business then you are not creating an impact you are giving output but you are not driving outcomes right so you can drive massive outcomes only when the things that you pick are aligned to the vision of an organization if you are not doing that you are just doing something right but it's not going to be impactful so everything and anything that you pick up should be should be should be aligned to the business's strategic goals right always remember this and this is one uh very solid way through which you can uh strive for solid outcomes instead of just focusing on outputs right similar words but big big difference in meaning right always focus on outcomes and not on output so yeah that's all that's all for this video uh i know it was not so technical video but i always wanted to highlight few things few key aspects to remember when we build micro services because these are things that are typically that most people overlook but if an engineer or an early leader spots them can create massive impact for them so i was just trying to ensure that everyone who is following this series avoids such pitfalls early engineers learn from it and try to drive impact in their organization early leaders ensure that your teams is not suffering from the pitfalls that i mentioned and overall just always align yourself to the business goals rather than running your own side projects nice so yeah that's it that's it for this one uh if you guys like this video give this video a thumbs up if you guys like the channel give this channel a sub i post three in depth this time it was not so technical but three in-depth videos in three depth three in-depth engineering videos every week and i'll see in the next one thanks [Music] you