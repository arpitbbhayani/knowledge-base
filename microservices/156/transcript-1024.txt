thanks, first key thing to remember while building micro services, that it is a huge, huge, huge opportunity for growth, right.
so when we have micro services based architecture or we are transitioning into microservices based architecture, what it gives us is we are creating a lot of services which are very focused, right, which means there would be lot of engineers, lot of teams, lot of technologies to work, with lot of interactions to happen between services.
apart from all of these non-engineering things that we discussed with respect to engineering side, when we are going from monolith to micro services, what would happen is- the problems are many right: inter-service communication, loosely coupling system, high cohesion that you would want to ensure.
so, as an engineer, if you are stepping up to this challenge, you would have a very, very, very solid growth trajectory in the organization, right.
okay, when you have a micro services based architecture, each team owning a few set of services and, let's say, those two services needs to interact.
the overall team's happiness quotient is much more important than an engineering decision, right, and it's not something that i am promoting, but something sometimes it is okay to do it, not always, but if it is happening too often, bring in your managers, bring in your senior engineers to resolve that part, and this also spans multiple teams.
it happens to every single one of us, right, and in most cases, when could there is some cross-team conflict on how to integrate, how to interface, how to build?
in some cases, let the seniors handle it at their level and then you would be happy implementing it right.
if you are deciding an architecture for a service and for sure, if you think that you are the best engineer in the room, you are 100 incorrect.
if you are deciding yourself the architecture and building it on your thinking that, hey, i am the best engineer in the world, it's stupid.
so there is no reason for you to create a conflict because of this, because organization's vision would evolve, so you have to adapt to it, right?
for example, it's like: hey, i designed this architecture thinking this scale or this feature, for that's why i picked sql database, otherwise i would have gone with no sql.
your product, your architecture, your business will evolve, right?
so deviations happen, the decisions or the things that you decided on might not be relevant after two months or after three months, because your market did not accept the product or there was some fancy requirement that was more essential or more critical than your current setup, right?
if you make them aware about these kind of situations, they would be putting in twice the amount of thought and coming up with, hey, yeah, we are definitely doing this, no matter what, and we are okay having this one way: route that from database one to move to database two we have.
we cannot always build the system the best way possible and it is always that because we engineers- or vs engineering teams- we are always running a race against time, we always have to ship things faster.
so today you are getting very high velocity, but tomorrow you would be slowing things down because this, when today shipping a feature, let's say, takes you three days and six months later it might take you one month, right, and your manager or your senior manager will come in and say why?
right, technical debt is a concept which is basically bonging you down because of all the inefficient decisions, or not so best decisions, that you took just to ship things faster at that moment.
and this is not just because of inefficient decisions we took or something to ship things faster, but also it might be possible that organization's vision changed in midway, because of which the architecture that you had earlier is not so relevant.
so these are couple of reasons because of which technical debt exists, but it is very important to solve technical debt periodically right at least without 10 percent of bandwidth every sprint to resolve technical debt, so that, as a team who are owning a bunch of services, you would be moving at a much faster pace in the future.
right, or people know how to manage them, or we, or every engineer in the organization is skilled to work on them.
so what you can typically do is if you have a set of standards that you want every engineer to follow, every micro service that is spun up to follow, you can create a service template for it, for example, a github repository with a boilerplate code with all necessary extensions or all necessary plugins that it would require.
for example, you want uh, like in that repository, in that template repository, you would have an uh, you would have a small hello world server that exposes grpc for inter service and http for or rest based endpoints for user basic communication.
so this would avoid duplicate efforts where every engineer who is spinning up on your microservice needs to add those things separately and every team might have a different folder structure.
hey, if an organization is trying to enforce standardization by saying that, hey, you only have to use java or you only have to use python to build this thing, a lot of engineers might feel strangled.
second way to solve this is when you have a central team trying to enforce a standard to all the teams in the organization.
uh, i know it was not so technical video, but i always wanted to highlight few things, few key aspects to remember when we build micro services, because these are things that are typically that most people overlook, but if an engineer or an early leader spots them, can create massive impact for them.
early engineers: learn from it and try to drive impact in their organization.