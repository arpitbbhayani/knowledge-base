thanks, so almost all micro services need some kind of data store to hold and persist the state of its information.
for example, order service will need to store the incoming orders somewhere in some database.
payment service would need to store the incoming payments or the refunds that they are making into some database.
by having a service owning its own database, we are creating loose coupling between the two services, making them independent and autonomous: independent to build, test or deploy and scale their applications autonomous to take the decision on their own database or any other peripheral decisions, for example, for example, the communication business logic, api contracts.
for example, a chat service where there is a very high ingestion volume of information coming in, where people are chatting and everything needs to be stored and persisted.
the chat service needs to have a database that is right, heavy or that can handle large amount of rights and should also be able to support a specific kind of reads.
you might want to go for a non-relational database which is schema less like a mongodb, and in order to scale reads, you might want to configure it in a read replica setup, right, so that would give the best performance, uh, or extensibility for that particular use case.
you would not want to fire your, your super complex analytics query onto your main transactional database.
so that's where analytics query would need its own database which would be its data warehouse, like amazon redshift.
you might want to go for something like an aws s3 or any kind of blob storage to hold that information right.
so here we see how a simple looking social media that we use on a day-to-day basis has so many micro services and each service has to take its own decision about its database so that it could give the best performance for itself, like for chad to be performant with respect to, because that is a use case where it is read heavy and right heavy, more more so than that.
this is the heart and soul of micro services based architecture, where, because of loose coupling, what we would definitely want is every service to run independently and, uh like, not just service, but also the team owning that service should not be dependent on other teams.
this way, any changes that can happen onto a database will keep the service unaffected and you can very easily scale out the system now.
tomorrow, if we have another service who needs the same profile information could just talk to profile service rather than sharing the same database or doing that part.
you have a very specific need, for example, in order to, in order to model relations on social network, for example, a follows b or a is friends with b, you might want to go for something like a graph database.
so if you are modeling something like a social network or social relationship on a network, you might want to go for a graph database because you need those algorithms you might not not want or, if you do it on a relational debate, would be very inefficient to do so.
so that's where, in order to fulfill the specific need of a particular use case of your application, you would want to go for a specialized database.
a small example to conclude on this point would be: uh, to power a full text search engine, you might want to go for elastic search, so that, because that's meant for that particular use case, why would you want to do it on a relational database using like queries, right, very poor way to design that.
so that's where to, in order to fulfill the specific need of a specific service or a specific use case, you would want it to be as isolated as possible and as autonomous as possible.
for example, in case of a chat system, a partitioned way of scaling is good for right ingestion or a right heavy system.
on the other hand, where you are building something like a payment service, you might want to go for a very strong, asset compliant database like mysql or postgres, so that your data never goes in an inconsistent state.
scaling for system like chat, you could add, read replicas or you could to handle rights.
so that's where, for your specific service, for your specific use case, you would want to pick- or you should be picking- the best scaling strategy that would keep the cost in check.
now here what would happen is if you have database per service architecture, you would only need to encrypt that database or that table and like, for example, your entire data size is 2 terabyte, but your pi information under financial information only comes in 10 gb.
so i would highly recommend you check that out on my channel or on my website: uh, implementing distributed transaction using two phase commit, where i've actually implemented that, and if you are- and you would realize that disabilities are not just theoretical- you can actually physically implement those things and i would highly encourage you to check that out, okay, second disadvantage is con, not disadvantage, but a little, uh, a little hiccup where conveying updates across services is difficult, like, for example, if the two services would have shared the database, they could like directly talk to the database and see the latest state of it, right.
but here let's say you have, you are building social network and you have a post service on which, like whenever user posts something that comes to this service, and it has its own database where it is persistent.
or graph database- right, your teams need to, your sre team, or even, in your case, if you are managing it, you need to have those expertise into, first of all, writing efficient queries.
so, yeah, now you understand database per service architecture, uh, advantages of it, disadvantages of it: modeling a social network, different kinds of databases- we just trust upon it a few times.