so micro services should be loosely coupled in autonomous so that they can take their own decision and be as performant as they can be a high level architecture pattern that allows us to achieve this is the database per service pattern in which each microservice owns its database and can take independent decisions about it in this video we quickly talk about database per service architecture pattern look how it helps in modeling massive systems understand the advantages of adopting it and conclude by going through some drawbacks of this architecture pattern but before we move forward i'd like to talk to you about a course on system design that i have been running for over a year now the course is a cohort based course which means i won't be rambling a solution and it will not be a monologue instead a small focused group of 50 60 engineers every cohort will be brainstorming systems and designing it together this way we build a solid system and learn from each other's experiences the course to date is enrolled by 600 plus engineers spanning nine cohorts and 10 countries engineers from companies like google microsoft github slack facebook tesla yelp flipkart dream 11 and many many many more have taken this course and have some wonderful things to say the coolest part about the course is the depth we go into and the breadth we cover we cover topics ranging from real-time text communication for slack to designing our own toy load balancer to greek buses live text commentary to doing impressions counting at scale for any advertisement business in all we would cover roughly 28 questions and the detailed curriculum uh split week by week can be found on the course page which is linked in the description down below so if you're looking to learn system design from the first principles you will love this course i have two offerings for you the first one is the live cohort discourse which you see on the left side and the second one is the recorded course which you can see on the right side the live code base course happens every two months and it will go on for eight weeks while the recorded course contains the recordings from one of the past cohorts as is if you are in a hurry and want to binge learn system design i would highly recommend you going for the recorded one otherwise the live code is where you can participate and discuss things live with me and the entire cohort and amplify your learnings the decision is totally up to you the course details prerequisites testimonials can be found on the course page at pitt binary dot me slash master class and i would highly recommend you to check that out i put the link of the course in the description down below so if you are interested to learn system design go for it check out the link in the description down below and i hope to see you in my next cohort thanks so almost all micro services need some kind of data store to hold and persist the state of its information for example order service will need to store the incoming orders somewhere in some database payment service would need to store the incoming payments or the refunds that they are making into some database now here the two databases where the orders is storing the orders or payments storing the payments information could be same or different the pattern we talk about today is database per service pattern in which what we get is every service has its own database rather every service has its own independent database which the service owns this promotes something that we strive for in a good micro services based architecture which is loose coupling by having a service owning its own database we are creating loose coupling between the two services making them independent and autonomous independent to build test or deploy and scale their applications autonomous to take the decision on their own database or any other peripheral decisions for example for example the communication business logic api contracts but here we are putting our focus on database per se so autonomous in making their own decisions for the database that they have so if for example let's say we are building a social network social network is not just one small set of code based gigantic code base there are so many services that you would have to build in order to run or in order to have just one social network for example a chat service where there is a very high ingestion volume of information coming in where people are chatting and everything needs to be stored and persisted the chat service needs to have a database that is right heavy or that can handle large amount of rights and should also be able to support a specific kind of reads so that's where a partition nosql database like apache cassandra would be a very good choice for a chat microservice for an authentication service a simple relational model or a simple relational database with master and replica setup is good enough to have a large amount of load or in case of a profile service well let's say you have a very schema less information about uh some information that a profile of a person might hold it's not it's not it's not fully adhered to a particular schema you might want to go for a non-relational database which is schema less like a mongodb and in order to scale reads you might want to configure it in a read replica setup right so that would give the best performance uh or extensibility for that particular use case another for your analytic system you might want to have a gigantic data with house you would not want to fire your your super complex analytics query onto your main transactional database so that's where analytics query would need its own database which would be its data warehouse like amazon redshift or if your social media supports videos you have to store videos you cannot store videos in your transactional db you might want to go for something like an aws s3 or any kind of blob storage to hold that information right so here we see how a simple looking social media that we use on a day-to-day basis has so many micro services and each service has to take its own decision about its database so that it could give the best performance for itself like for chad to be performant with respect to because that is a use case where it is read heavy and right heavy more more so than that it's more right heavy than read heavy because of that we need to have a database that supports very high right throughput and that too in and that to it and hence it needs to be partitioned you may not need partitions or you may not need sharding for authentication service or for profile service but for chat definitely yes right similarly for video you would not put into the same transactional db because why to do so 2gb of videos in one transaction will be very bad design decision that's why you would need a blob store and some meta information to be stored in some some transactional tv analytics queries are very heavy you do joins across 50 60 tables to get some information why would you want to fire that query into your main transactional system or into a shared database that would take down other services so one bad query or one gigantic analytics to be done would take down your entire database that's why having that separation of concerns or having that independence to take their own decisions pays a very good way to get the max performance out of your overall system so now let's talk about advantages now that we understand uh the kind of decisions we would be making or the kind of things that we are signing up for let's talk about the advantages of adopting database per service of adopting the database per service pattern the biggest advantage the biggest advantage that we get is we create loosely coupled components this is the heart and soul of micro services based architecture where because of loose coupling what we would definitely want is every service to run independently and uh like not just service but also the team owning that service should not be dependent on other teams this promotes that so for example you have a recommendation service you have a profile service because recommendation service has its own db profile service has its own db what we would get is for them to talk to each other they would not get access to cross database like recommendation service might not have access to the the database of the profile service or profile service will not have access to recommendations db so that's where when the two services would have to talk to each other instead of directly talking to the corresponding databases they would have to talk to each other and talk via api contracts this way any changes that can happen onto a database will keep the service unaffected and you can very easily scale out the system now tomorrow if we have another service who needs the same profile information could just talk to profile service rather than sharing the same database or doing that part and now each of the service will have its own c uh will have its own team to build and develop and whatnot right so you get loosely coupled components that's the heart and soul of micro services based architecture through this database per service pack second is you have a need of a you have a very specific need for example in order to in order to model relations on social network for example a follows b or a is friends with b you might want to go for something like a graph database let's say we are building linkedin and on that you see two people a and b are connected or not or how far are they is it one order connection or basically the second order connection or the third order connection right so how far are they this could be very well modeled not saying that they have modeled uh modeled it this way but this cool this could be modeled on a graph database like neo4j amazon neptune d graph what not you can model it there so if you are modeling something like a social network or social relationship on a network you might want to go for a graph database because you need those algorithms you might not not want or if you do it on a relational debate would be very inefficient to do so so that's where in order to fulfill the specific need of a particular use case of your application you would want to go for a specialized database a small example to conclude on this point would be uh to power a full text search engine you might want to go for elastic search so that because that's meant for that particular use case why would you want to do it on a relational database using like queries right very poor way to design that so that's where to in order to fulfill the specific need of a specific service or a specific use case you would want it to be as isolated as possible and as autonomous as possible next point is you want to have granular control of scaling or of scaling your service database is that one component that is super important super important for scaling like if your database scales your service scales because api server the scaling of api servers is pretty much sorted like you put it behind road balancer add an auto scaling group and that is sorted but scaling your database is tricky because you your databases are not elastic like you cannot just say hey increase the size of my database it would happen in two seconds it takes time right so that's a very infrequent activity that you would do so that's where you would want a very granular control of scaling first of all to keep the cost in check second of all to take the best decision for your infra for example in case of a chat system a partitioned way of scaling is good for right ingestion or a right heavy system that's where you might want to have a partition database on the other hand where you are building something like a payment service you might want to go for a very strong asset compliant database like mysql or postgres so that your data never goes in an inconsistent state the scaling for both of these databases are totally different scaling for system like chat you could add read replicas or you could to handle rights you would want to go for partitions for scaling payments you might want to go for vertical scaling because you want a very consistent view of data so that is where you can pick any of the scaling strategy for your use case it could be horizontal vertical replica basically read replicas to scale reads partitioned or decentralized it's all up to you right so that's where for your specific service for your specific use case you would want to pick or you should be picking the best scaling strategy that would keep the cost in check next is if your database goes down when you have data and in most cases most outages that happen in the world are either due to dns or due to a database so because it's in most cases it is due to database or your database choking or your database is under heavy load or it went into a reboot state something something happened with your data in most cases it is always the database that is that is the root cause of all evil and chances of that going down is very high when your database goes down it takes everybody with it imagine having a common database for your entire social network what would happen if that database goes down your entire site is done so that is where what we can see is if we have database per service architecture if a particular database is down then only the services dependent on not on those database directly or indirectly will be affected for example if a profile database system then your profile service is definitely affected and any service which is dependent on profile service synchronously will be affected on the other hand if your payment service never depends on profile service then your payments is working fine you are getting revenue and you are happy because your even if your website is down or your profile service is down you are still accepting payments you are not you are not losing out on revenue next is you have a separate compliance need for a certain type of data see this is something that when if you are a senior engineer you would have definitely seen it if you are not a senior engineer you would see when you turn the senior engineer compliance something that you have to worry so much about that hey i have i am storing pii information of data pi is basically personally uh is basically personal identifiable information like your email aadhaar card or your social or your social security number and so on so forth your piis information is very critical so for example if you are storing a critical information like let's say financial data or payments you might want to have a a policy where you would want to encrypt the data at rest which means that whereby while you're storing the data in your database it should be stored in an encrypted way or the disk on which a database is stored that should be encrypted and so on and so forth so there are multiple uh or there are many checks that you would have to put in or many things that you would have to adhere to when you're dealing with data that uh has some global compliance applied on top of it now here what would happen is if you have database per service architecture you would only need to encrypt that database or that table and like for example your entire data size is 2 terabyte but your pi information under financial information only comes in 10 gb encrypting 10 gb is much simpler as compared to encrypting 2 terabytes and it's not just one time encryption every time when you're inserting how to encrypt it and whatnot your database implicitly has to do it and that would impact the response time of your services given that you would be encrypting on every call and decrypting while you are retrieving it every single time so that is where for a separate compliance and it is always better to to keep your database granular so that you can put those necessary checks only on those databases and not touch upon any other right so these are the advantages of having database per service architecture the second or the things that or the thing that we conclude with today is looking at disadvantage obviously again as i always say grass is not always green we have to look at disadvantages of going for database per service architecture it's not just that because of this we would not be adopting it obviously hybrid approach always works but we should know uh what we are signing up for right first disadvantage is your cross service transactions are super complex and super expensive i cannot add more super to that it's very complex and very expensive so cross service transactions for example uh if you have if you are building let's say a 10 minute grocery delivery system i have a video on actually implementing distributor transaction but let's say if you are building a 10 minute grocery delivery system and hypothetically you only want to accept the order when you have the inventory and you have a delivery person available inventory is as its own database is its own micro service logistics has its own database and is its own microservice so now what would happen is when the request comes to your order service order service would have to place an order only when you have an inventory and you have a delivery partner to deliver it this is a classic case of distributed transaction now in order to implement distributed transaction you have to implement either a two-phase commit protocol or some some way to implement distributed transaction and because it is distributed it's prone to failures network outages and what not and it takes time for you to even converge upon a distributed transfer it's not as simple as you start begin transaction and transaction like you do in your relational database so that is where implementation is complex and expensive expensive with respect to time and throughput as soon as you add a distributed transaction you are screwing down your throughput by at least 3x at least at least 3x you are actually slowing it down because it is that slow to implement because you have because there are a lot of distributed components that come into the picture and it takes time for you to guarantee consistency and what not as part of disabled transaction so i would highly recommend you check that out on my channel or on my website uh implementing distributed transaction using two phase commit where i've actually implemented that and if you are and you would realize that disabilities are not just theoretical you can actually physically implement those things and i would highly encourage you to check that out okay second disadvantage is con not disadvantage but a little uh a little hiccup where conveying updates across services is difficult like for example if the two services would have shared the database they could like directly talk to the database and see the latest state of it right but here let's say you have you are building social network and you have a post service on which like whenever user posts something that comes to this service and it has its own database where it is persistent and then you have a feed service in the feed service you are generating the feed of a user now what would happen is anytime a new post is created you have to trigger the feed service or you have to let the feed service know about that newly created post so that your feed service can put it into the feed of your followers right now how would this communication happen so this update flowing typically happens through a message broker mostly an asynchronous system message broker like amazon sqs kafka rabbit mq or basically even reduce as a message broker pick it pick your favorite but the idea here is from post service to feed service some way you have to flow the updates right so you have to convey the update that's a little uh complex although it's not really hard but you have to be very of the fact that it will take some indeterministic amount of time for the update to come out of your post and reach your feed it will not be strongly consistent it will always be eventually consistent and the final drawback uh which your sra temperature of stream would very heavily relate to is multiple infra components to be monitored and manage now that imagine you have different kinds of different flavors of database like graph database no sql database or key value store document store columnar warehouses what not or graph database right your teams need to your sre team or even in your case if you are managing it you need to have those expertise into first of all writing efficient queries second observing what's happening on the infrastructure third knowing how to scale it without any downtime fourth in case of a downtime how to mitigate it small small things it adds up a lot of things so you need to have that knowledge to manage the database monitor it and it's not very trivial so which is where this uh foreign engineering leader this becomes the biggest concern apart from all the technical challenges that are there this is the biggest concern for any engineering leader oh my god i have to manage more systems and it's not at all straightforward so that's why you would see whenever a new technology is being adopted a lot of teams have concerns about it it's not that they don't want to change but it's more like managing them or they might not have enough confidence in managing managing them or they would need time to build that sort of expertise in managing it so that's the harsh truth of our industry but that's how the industry works so these are disadvantages slash concerns about database per service architecture and i hope it was pretty uh exhaustive per se though i try to give you a little bit of insights around everything on how those things happen and uh how we function so yeah now you understand database per service architecture uh advantages of it disadvantages of it modeling a social network different kinds of databases we just trust upon it a few times uh understanding how it promotes loose coupling autonomous and independence right so yeah that's it that's it for this one uh if you guys like this video give this video a thumbs up if you guys like the channel give this channel a sub i post three in-depth engineering videos every week and i'll see in the next one trying saturn