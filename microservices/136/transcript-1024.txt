for example, your core api server needs to talk to your notification service to send notifications to the followers when you post something right now.
whenever user b post something, user a is allowed to react on it- like, like, share and comment- and as soon as that reaction happens, the notification needs to be sent out to the user who created it post, which means user b, right?
so here, this, the key highlight of synchronous communication, is that it is a blocking call, which means that when your user hits the like button, the api of the reaction service gets invoked.
the biggest disadvantage of synchronous communication is that the caller is blocked until the response is received, which means that, say, if reaction service is talking to a notification service and let's say, notification service does not respond in 5 millisecond, 50 millisecond, 100 millisecond, 200 millisecond, one second, two second, your reaction service is blocked and because your user made a synchronous api call to a reaction service, your user is blocked for that time.
when that is happening, what you definitely need to do, because the communication is synchronous, your reaction service will make a call to your api of your notification service.
if the request gets dropped or you see higher latency, it would impact the overall latency of that your user experiences, which is where you need to always ensure in case of synchronous communication.
right, and the worst part here is you have to do it for peak, which means that, let's say, if you see a sudden surge of users and if you don't have enough notification servers to who are sending out synchronous, or beat any service, not just, i'm just taking that as an example- beat any service if it does not have enough capacity to handle it.
but when you have synchronous communication in place, your service are tightly coupled, which means that if your a is synchronously communicating with b, if b changes something, a should be kept in the loop, right, like, for example, api contract changes, a needs to know about it.
so this is a classic standard diagram for a synchronous communication in which what you typically have is, whenever two services need to talk to each other, instead of directly invoking each other's api, they send out a message in a broker.
user making an api, a rest api call to register a like on a particular post, then the reaction service would update its database and then would send a message to your message broker saying that this user reacted to this post made by this particular user.
and because of the best part of going for an asynchronous communication is that there is no cascading failure, because this is above, in synchronous communication you always made a call right away, but here the messages are stored in message broker, which can eventually get consumed by the notification service.
so what would happen is because, uh, your user making an api call to a reaction service is synchronous.
so user registered a like reaction service, updated database, then it created an asynchronous task in a message broker.
this acknowledge: after your reaction service got that acknowledgement that the message is stored in the broker, it would send the okay response to your user.
so now when your user makes a like, the, the, the reaction gets registered and asynchronous message is pushed in, the broker gets a response, gets a response, and only for this much of time the api is blocked or the or your user is blocked, right and now?
so earlier your reaction service used to send communication to notification or synchronous connection notification and then you should get response.
so now what would happen is the api response time that your user sees, your end user sees- is pretty low because it stores one reaction in the database, sends out a message and done.
but for every request that you get over here, you are updating the database that you anyway have to ensure and it needs to send a message to the message broker, right, it is.
so here the key idea is, if there is one request per second or 1000 requests per second, the api response time, sees as experienced by your end user, remains unchanged, because your reaction service updates this database and sends a message broker, and that's exactly what it would always do: beat one user or one request per second or 1000 requests per second, right.
the next advantage is that you require fewer infra components like load balancer when your reaction service is talking to a notification service via broker in this communication, you don't really need a load balancer sitting in front of notification service because what's happening?
so it's purely horizontal, scalable consumers that you have over here, right, but in any case you'll not have any request drop whatsoever because your reaction service only has to put the message in the broker.
the next one is you get better control over failures because in synchronous communication, if their request field you had no way to retry, you had to do like your user had to do: retry, which is a very poor experience because having retries on your client side is not a good solution.
but with this asynchronous communication what do you get is you can retry like, let's say, you're while processing a particular message or notification server crashed.
the next one is your services are truly decoupled because, like your, notification service can scale independently, your reaction service can scale independently because these are synchronous communication so long as a message broker is good enough for it to handle the traffic.
so that's what you do, is you add a message to a broker and let your notification service consume it, because it does not need to be real time.
so when it is okay for you to allow failures and retries, this is where you will go for an asynchronous communication rather than going for a synchronous one, right?